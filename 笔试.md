## 算法

### 并查集

- 解决连通性问题：

  1. 将两个元素添加到同一个集合中
  2. 判断两个元素是否在同一个集合中

- 关键方法：

  1. join(u,v): 将uv这条边加入并查集
  2. find(u): 寻找u的根节点
  3. init(): 初始化并查集，每个元素的根节点都是自己本身
  4. isSame(u,v): 判断是否有uv边，即u、v是否在同一个集合中

- 优化：

  路径压缩：不做优化的情况下，find可能需要递归好几层才能找到根节点，如果在递归的过程中重新设置每个元素的父节点，都将自己指向父结点的边改为指向原来的根节点，这样就可以把树的高度减为2，大大降低了递归深度

  由

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png" alt="img" style="zoom: 50%;" />

变成

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom: 67%;" />



代码：

```cpp
class UnionSet
{
public:
    UnionSet(int size)
    {
        size_ = size;
        father = vector<int>(size, 0);
        // 初始化，元素都指向自己本身
        for (int i = 0; i < size_; i++)
        {
            father[i] = i;
        }
    }

    // 查找u的根元素并且路径压缩
    int find(int u)
    {
        return u == father[u] ? u : father[u] = find(father[u]);
    }

    // 合并两个元素所在集合
    void join(int u, int v)
    {
        // 找到两个元素的根元素，然后合并两棵树，这样相当于在同一个集合里了
        u = find(u);
        v = find(v);
        // 已经在同一个集合就不需要再次合并了
        if (u == v)
            return;

        father[v] = u;
    }

    // 判断两个元素是否在同一个集合中
    bool isSame(int u, int v)
    {
        // 根元素相同就代表在同一个集合中
        return find(u) == find(v);
    }

private:
    int size_;
    vector<int> father;
};
```







### 排序算法

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序：将大数像泡泡一样冒到最后（稳定）
void bubbleSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            if (vec[j] > vec[j + 1])
            {
                int tmp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = tmp;
            }
        }
    }
}

// 选择排序：选择一个基准值，将其后面最小的值与其交换（不稳定）
void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = vec[i];
        vec[i] = vec[minIndex];
        vec[minIndex] = tmp;
    }
}

// 插入排序：将值插入到前面某个合适的位置
void insertionSort(vector<int>& vec) {
    int n = vec.size();
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        // 后移腾位
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }
}


// 快速排序：选一个基准值，小于它的放左边，大于它的放右边
class QuickSort
{
public:
    QuickSort() {};

    // 快速划分函数
    int partion(vector<int>& vec, int left, int right)
    {
        int pivot = vec[right];
        int index = left;

        // 大于pivot放右边，小于pivot放左边
        for (int i = left; i < right; ++i)
        {
            if (vec[i] < pivot)
            {
                swap(vec[i], vec[index++]);
            }
        }

        // 放置基准值
        swap(vec[right], vec[index]);
        return index;
    }

    // 快速排序
    void quickSort(vector<int>& vec, int left, int right)
    {
        if (left < right)
        {
            int pi = partion(vec, left, right);

            quickSort(vec, left, pi - 1);
            quickSort(vec, pi + 1, right);
        }
    }
};

// 归并排序：合并两个有序子数组
class MergeSort {
public:
    MergeSort() {};

    void merge(vector<int>& vec, int left, int mid, int right) {
        int size1 = mid - left + 1;
        int size2 = right - mid;

        vector<int>left_vec(size1);
        vector<int>right_vec(size2);

        for (int i = 0; i < size1; ++i) {
            left_vec[i] = vec[left + i];
        }
        for (int j = 0; j < size2; ++j) {
            right_vec[j] = vec[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while (i < size1 && j < size2) {
            if (left_vec[i] < right_vec[j]) {
                vec[k++] = left_vec[i++];
            }
            else {
                vec[k++] = right_vec[j++];
            }
        }

        while (i < size1) {
            vec[k++] = left_vec[i++];
        }
        while (j < size2) {
            vec[k++] = right_vec[j++];
        }
    }

    void mergeSort(vector<int>& vec, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(vec, left, mid);
            mergeSort(vec, mid + 1, right);

            merge(vec, left, mid, right);
        }
    }
};




int main()
{
    vector<int> vec{ 2, 1, 5, 4, 7, 6, 0 ,3 };

    // bubbleSort(vec);
    // selectionSort(vec);
    // QuickSort q;
    // q.quickSort(vec, 0, vec.size() - 1);
    // insertionSort(vec);
    MergeSort m;
    m.mergeSort(vec, 0, vec.size() - 1);


    for (auto& num : vec)
    {
        cout << num << " ";
    }
}
```



### 图

**迪杰斯特拉算法：**找某一起点到所有点的最短路径

时间复杂度：O(n^2)

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int INF = INT_MAX;

int main()
{
    int n; // 节点数
    int e; // 边数
    int s; // 起点
    cin >> n >> e >> s;

    // 起点到其它节点的最短路径长
    vector<int> dis(n, INF);
    dis[s] = 0;

    // 确保s到某个节点的路径已是最短
    vector<bool> check(n, false);

    // 图
    vector<vector<int>> graph(n, vector<int>(n, -1));
    for (int i = 0; i < e; i++)
    {
        int start, end, dis;
        cin >> start >> end >> dis;
        graph[start][end] = dis;
    }

    for (int i = 0; i < n; i++)
    {
        int min_dis = INF, min_idx = n;
        for (int j = 0; j < n; j++)
        {
            // 检查check可以避免重复在一个节点打转
            if (dis[j] < min_dis && !check[j])
            {
                min_dis = dis[j];
                min_idx = j;
            }
        }
        check[min_idx] = true;

        for (int k = 0; k < n; k++)
        {
            // 从min_idx节点到k节点距离更短，则更新，前提是min_idx节点和k节点是连通的
            if (graph[min_idx][k] > 0)
            {
                if (min_dis + graph[min_idx][k] < dis[k])
                {
                    dis[k] = min_dis + graph[min_idx][k];
                }
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        cout << dis[i] << " ";
    }
}
```

**最小生成树：**Kruscal算法和Prim算法（无向连通带权图）
prime算法复杂度由顶点数决定，更适合稠密图，而K算法由边数决定，故更适合稀疏图

- Prim算法：每次都选择到下一顶点权最小的边。

  - `Prim算法从一个初始顶点开始`，然后逐步扩展生成树，每次选择连接生成树和未加入生成树的顶点的权重最小的边。具体步骤如下：
    - 选择一个起始顶点作为生成树的根节点。
    - 将该节点标记为已访问，并将其与之相邻的所有边加入到优先队列中。
    - 从优先队列中选择权重最小的边，如果其连接的节点未被访问，则将该节点加入生成树，并将与该节点相邻的边加入优先队列中。
    - 重复以上步骤，直到所有节点都被访问过，生成树构建完成。
  - Prim算法的时间复杂度通常为 O(V^2) 或 O(E*logV)，其中V是顶点数，E是边数。

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  class Edge
  {
  public:
      Edge(int _to, int _weight) : to(_to), weight(_weight) {}
  
      int to;
      int weight;
  };
  
  int prim(const vector<vector<Edge>> &graph)
  {
      int minCost = 0;
      int n = graph.size();
      // 已访问节点为true
      vector<bool> visited(n, false);
      // 存放着所有已连接树 连接 未连接树的信息(权重，终点)
      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
  
      // 起始节点为0
      pq.push({0, 0});
  
      while (!pq.empty())
      {
          int w = pq.top().first;
          int u = pq.top().second;
          pq.pop();
  
          if (visited[u])
              continue;
  
          visited[u] = true;
          minCost += w;
  
          for (const Edge &edge : graph[u])
          {
              if (!visited[edge.to])
              {
                  pq.push({edge.weight, edge.to});
              }
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
      vector<vector<Edge>> graph(n);
  
      for (int i = 0; i < e; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          graph[u].emplace_back(Edge(v, w));
          graph[v].emplace_back(Edge(u, w));
      }
  
      cout << prim(graph);
  }
  ```

  

- Kruskal算法：每次都选择权最小的可以连通两个不同连通分支的边

  `边排序(权重从小到大) + 并查集`

  步骤：

  1. 边排序后，遍历边
  2. 如果边的两个顶点没加到并查集中，代表未连接，加入并查集、

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  
  struct Edge
  {
      int u;
      int v;
      int weight;
  };
  
  bool compare(Edge a, Edge b)
  {
      return a.weight < b.weight;
  }
  
  class Union
  {
  public:
      Union(int n)
      {
          parent.resize(n);
          rank.assign(n, 0);
          for (int i = 0; i < n; i++)
          {
              parent[i] = i;
          }
      }
  
      int find(int u)
      {
          if (u == parent[u])
              return u;
          parent[u] = find(parent[u]);
          return parent[u];
      }
  
      void join(int u, int v)
      {
          u = find(u);
          v = find(v);
          if (rank[u] < rank[v])
          {
              parent[u] = v;
          }
          else if (rank[u] > rank[v])
          {
              parent[v] = u;
          }
          else
          {
              parent[v] = u;
              rank[u]++; // 高度增加了
          }
      }
  
      bool is_connect(int u, int v)
      {
          return find(u) == find(v);
      }
  
      vector<int> parent;
      vector<int> rank; // 用于判断树的高度，将高度低的树加到高度高的树上可以减少整个树的高度
  };
  
  /// @brief 生成最小树
  /// @param edges 所有边
  /// @param n 节点数
  /// @return 最小权重
  int kruskal(vector<Edge> &edges, int n)
  {
      int minCost = 0;
      Union uf(n);
  
      sort(edges.begin(), edges.end(), compare);
  
      for (auto &e : edges)
      {
          if (!uf.is_connect(e.u, e.v))
          {
              uf.join(e.u, e.v);
              minCost += e.weight;
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
  
      vector<Edge> edges(e);
  
      for (int i = 0; i < e; i++)
      {
          cin >> edges[i].u >> edges[i].v >> edges[i].weight;
      }
  
      cout << kruskal(edges, n);
  }
  ```




### [旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 1.转置
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = i + 1; j < matrix[i].size(); ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // 2.反转数组
        for (int i = 0; i < n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```



### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n=matrix.size();
        int m=matrix[0].size();

        pair<int,int>left_up(0,0);
        pair<int,int>right_down(n-1,m-1);

        while(left_up.first<=right_down.first&&left_up.second<=right_down.second){
            int up=left_up.first;
            int left=left_up.second;
            int down=right_down.first;
            int right=right_down.second;

            // 只剩一行
            if (up==down){
                for(int j=left;j<=right;j++){
                    res.emplace_back(matrix[up][j]);
                }
                break;
            }

            // 只剩一列
            if (left==right){
                for(int i=up;i<=down;i++){
                    res.emplace_back(matrix[i][left]);
                }
                break;
            }

            for(int j=left;j<right;j++){
                res.emplace_back(matrix[up][j]);
            }
            for(int i=up;i<down;i++){
                res.emplace_back(matrix[i][right]);
            }
            for(int j=right;j>left;j--){
                res.emplace_back(matrix[down][j]);
            }
            for(int i=down;i>up;i--){
                res.emplace_back(matrix[i][left]);
            }

            left_up.first+=1;
            left_up.second+=1;
            right_down.first-=1;
            right_down.second-=1;
        }

        return res;
    }
};
```



### [打乱数组](https://leetcode.cn/problems/shuffle-an-array/)

![image-20240321112356263](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321112356263.png)

```cpp
class Solution {
public:
    Solution(vector<int>& nums) { this->nums = nums; }

    vector<int> reset() { return this->nums; }

    vector<int> shuffle() {
        vector<int> res = nums;
        int n = nums.size();

        for (int i = 0; i < n; ++i) {
            swap(res[i], res[i + rand() % (n - i)]);
        }
        
        return res;
    }

private:
    vector<int> nums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```



### [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

思路：

- 双向链表：最近访问的元素放在链表头，最长时间没访问的元素在链表尾，由于查找、放置和删除节点时只会对头尾节点做操作，因此可以加一对虚拟头尾节点管理
- 整体维护一张哈希表，键值是key，value值是双向链表中的节点
- get(): 查找哈希表中有无对应键值，有则返回对应元素，并把该元素移到头节点，没有则返回-1
- put(): 查找有无对应键值，有则更新value值即可，并移到头节点。没有就需要添加，先判断LRU缓存是否已满，如果没满则添加到链表头，满了的话删掉尾节点然后再加到链表头

```cpp
struct DoubleLinkedNode {
    int key, value;
    DoubleLinkedNode* prev;
    DoubleLinkedNode* next;

    DoubleLinkedNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {}
    DoubleLinkedNode(int key, int val)
        : key(key), value(val), prev(nullptr), next(nullptr) {}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        dummy_head = new DoubleLinkedNode();
        dummy_tail = new DoubleLinkedNode();
        dummy_head->next = dummy_tail;
        dummy_tail->prev = dummy_head;
        size = 0;
        this->capacity = capacity;
    }

    int get(int key) {
        // 如果不存在，返回-1
        if (link_map.count(key) == 0)
            return -1;

        DoubleLinkedNode* key_node = link_map[key];
        // 更新访问时间
        moveToHead(key_node);
        return key_node->value;
    }

    void put(int key, int value) {
        // 如果存在，更新值，并更新时间
        if (link_map.count(key) != 0) {
            DoubleLinkedNode* key_node = link_map[key];
            key_node->value = value;
            moveToHead(key_node);
            // 及时返回，否则出了if还会继续执行，不符合逻辑
            return;
        }

        // 如果不存在
        // 先判断是否还有空间
        if (size == capacity) {
            // 空间已满
            // 删除链表尾(最久未被访问的元素)
            DoubleLinkedNode* tail_node = dummy_tail->prev;
            removeNode(tail_node);
            // 从link_map中删去key值
            link_map.erase(tail_node->key);
            // 更新元素个数
            --size;
        }

        // 空间充足
        // 初始化节点
        DoubleLinkedNode* new_node = new DoubleLinkedNode(key, value);
        // 加入到链表头
        addToHead(new_node);
        // 加入到link_map
        link_map[key] = new_node;
        // 更新元素个数
        ++size;
    }

    // 将节点加入链表头，用于put新添节点时
    void addToHead(DoubleLinkedNode* node) {
        DoubleLinkedNode* head_next = dummy_head->next;
        dummy_head->next = node;
        node->prev = dummy_head;
        head_next->prev = node;
        node->next = head_next;
    }

    // 移除节点，不止链表尾，因为还有将中间节点移出链表再添加到链表头的情况
    void removeNode(DoubleLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        node->prev = nullptr;
        node->next = nullptr;
    }

    // 将链表中的节点移动到链表头，满足更新key值对应value，和访问key时的情况
    void moveToHead(DoubleLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

private:
    unordered_map<int, DoubleLinkedNode*> link_map;
    DoubleLinkedNode* dummy_head;
    DoubleLinkedNode* dummy_tail;
    int size;
    int capacity;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### [三数之和](https://leetcode.cn/problems/3sum/)

思路：

排序数组后，定义双指针，由于数组是有序的，因此双指针的移动也是有规律的，假设当前和小于0，那么就让左指针往右移(nums[left]<=nums[left+1])，否则就让右指针左移(nums[right]>=nums[right-1])

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for (int i = 0; i < n - 2; ++i) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 去重
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return res;
    }
};
```



### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

思路：

由于连在一起的陆地算一块岛屿，因此遍历二维数组时，碰到一块陆地就将其所在岛屿的所有陆地沉下去（dfs），防止重复计算

```cpp
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 越界或者陆地不连续就停止
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() ||
            grid[i][j] == '0')
            return;

        // 沉下去
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }

    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int n = grid.size(), m = grid[0].size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }

        return res;
    }
};
```



### [数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

思路：

维护小顶堆A和大顶堆B，各维护一半元素，小顶堆A维护值较大的那一半（），大顶堆B维护值较小的那一半

![image-20240321213513781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321213513781.png)

```cpp
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        int m=A.size();
        int n=B.size();

        // num需要和A、B中的元素都比较之后才知道应该放在哪
        // A、B元素个数相同，加入A
        if(m==n){
            // num有可能属于较小的那一半，因此先加入B，再将B的堆顶元素加入A
            B.push(num);
            A.push(B.top());
            B.pop();
        }else{// m=n+1
            // num有可能属于较大的那一半，因此先加入A，再将A的堆顶元素加入B
            A.push(num);
            B.push(A.top());
            A.pop();
        }
    }

    double findMedian() {
        int m=A.size();
        int n=B.size();

        if(m==n){
            return (A.top()+B.top())/2.0;
        }

        return A.top();
    }

private:
    // A维护较大的一半元素，且元素个数大于等于B
    priority_queue<int, vector<int>, greater<int>> A;
    // B维护较小的一半元素，且元素个数小于等于A
    priority_queue<int, vector<int>, less<int>> B;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



### [二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```cpp
方法一：层序遍历（空节点也算）

方法二：dfs
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, unsigned long long> depth_first;
    unsigned long long res;

    // 先序遍历保证第一次加入哈希表的都是每层的最左节点
    void dfs(TreeNode* node, unsigned long long i, int depth) {
        if (!node)
            return;
        if (depth_first.count(depth) == 0)
            depth_first[depth] = i;
        res = max(res, i - depth_first[depth] + 1);
        dfs(node->left, 2 * i, depth + 1);
        dfs(node->right, 2 * i + 1, depth + 1);
    }

    int widthOfBinaryTree(TreeNode* root) {
        res = 0;
        dfs(root, 1, 0);
        return res;
    }
};
```



### [ 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

思路：

树形递归（回溯）

```cpp
class Solution {
public:
    vector<string> res;
    vector<int> path;

    void dfs(string& s, int start, int ip_idx) {
        // s刚好分为4个值
        if (ip_idx == 4 && start == s.size()) {
            string ip=to_string(path[0]);
            for(int i=1;i<path.size();++i){
                ip+="."+to_string(path[i]);
            }
            res.emplace_back(ip);
        }

        for (int i = start, num = 0; i < s.size(); ++i) {
            num = num * 10 + s[i] - '0';
            if (num > 255) // 剪枝
                break;
            path.emplace_back(num);
            dfs(s, i + 1, ip_idx + 1);
            path.pop_back();
            if(num==0)break; // 从0起始只有一种情况有效，就是num=0，x.0.y，处理完这种情况后就可以break了
        }
    }

    vector<string> restoreIpAddresses(string s) {
        dfs(s, 0, 0);
        return res;
    }
};
```



### [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

思路：

KMP

next数组: next[i]存放的是匹配串的子串[0,i]的最长公共前后缀长度

```cpp
class Solution {
public:
    vector<int> next(string& needle) {
        int n = needle.size();
        if (n <= 1) {
            return {-1};
        }

        // next[i]: needle[0,i-1]子串的最长公共前后缀长度
        // 不需要知道needle[0,n-1]即整个字符串的最长公共前后缀长度，因为此时都匹配完了
        vector<int> next(n, 0);
        // 规则：
        next[0] = -1;
        next[1] = 0;
        int i = 2;
        int j = 0;
        while (i < n) {
            if (needle[i - 1] == needle[j]) {
                /*
                next[i]=j+1;
                ++i;
                j=next[i-1];
                */
                next[i++] = ++j;
            } else if (j > 0) {
                j = next[j];
            } else {
                next[i++] = 0;
            }
        }

        return next;
    }

    int strStr(string haystack, string needle) {
        int n = needle.size();
        vector<int> next_vec = next(needle);

        int i = 0;
        int j = 0;

        while (i < haystack.size()) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
                if (j == n)
                    break;
            } else if (j > 0) {
                j = next_vec[j];
            } else {
                ++i;
            }
        }

        return j == n ? i - n : -1;
    }
};
```



## C++

下面这段代码会在编译时，因为调用show函数时，会调用A的拷贝构造函数，而A的拷贝构造函数是私有的无法访问到，因此报错

```cpp
#include <iostream>
using namespace std;
class A
{
    A(const A &) {}

public:
    int num;
    A() { num = 5; }
};
void show(A a)
{
    cout << a.num << endl;
}

int main()
{
    A a;
    show(a);
    return 0;
}
```

### 底层const、顶层const

```cpp
// iter: T* const
vector<T>::iterator iter = vec.begin();
// cIter: const T*
vector<T>::const_iter cIter=vec.begin();
```



### 左值引用和右值引用

![image-20240320151340925](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151340925.png)

![image-20240320151612193](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151612193.png)

- **左值**: 可取地址的

- **右值**:不是左值就是右值，即不可取地址的

  - **纯右值**: 纯粹的临时值（即使指代的对象是持久存在的），不跟对象关联的字面量值

  - **将亡值**: 一般是指类型为右值引用类型的返还值，T&&类型的函数返回值、std::move返回值

    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

- **左值引用**: 对左值进行引用

- **右值引用**: 对右值进行引用

```cpp
int &a = 2; // 左值引用绑定到右值，编译失败
int b = 2; // b是非常量左值
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过
const int d = 2; // d是常量左值
const int &e = c; // 常量左值引用绑定到常量右值，编译通过
const int &b = 2; // 常量左值引用绑定到右值，编译通过

右值引用通常不能绑定到任何左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
```



### 内存对齐

```cpp
// 24
// A的内存分布，对齐double(8)：
// [a][b1][b2][b3][b4][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
struct A {
	char a;
	int b;
	double c;
	char d;
};

// 32
/*
A的内存分布，对齐double(8)：
[a][b1][b2][b3][b4][0][0][0] [e1][e2][e3][e4][0][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
*/
struct B {
	char a;
	int b;
    int e;
	double c;
	char d;
};
```



### 纯虚函数、虚函数、虚函数表

https://zhuanlan.zhihu.com/p/75172640

https://zhuanlan.zhihu.com/p/270614081





**纯虚函数**

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。



何时使用纯虚函数：

（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

（2）这个方法必须在派生类(derived class)中被实现；

  如果满足以上两点，可以考虑将该方法申明为pure virtual function.



**虚函数、虚函数表**

虚函数：被virtual修饰的类成员函数

每个包含了虚函数的类都包含了一张虚函数表

当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。



```cpp
// 类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318203825639.png" alt="image-20240318203825639" style="zoom:150%;" />



虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。



> 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205416612.png" alt="image-20240318205416612" style="zoom:150%;" />



**子类的虚表**

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图所示。

![image-20240318205547970](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205547970.png)

`对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数`



```cpp
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

![image-20240318210458446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318210458446.png)



> 什么时候会执行函数的动态绑定？需要符合以下三个条件
>
> 1. 通过指针来调用函数
> 2. 指针upcast向上转型（继承类向基类的转换称为upcast）
> 3. 调用的是虚函数





### extern

如果想在多个文件之间共享const变量，必须在变量的定义前加上extern关键字



### const限定符

![image-20240319210655314](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240319210655314.png)





### 无符号与有符号的比较

![image-20240320134747641](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320134747641.png)



### 字符串相加

![image-20240320135448633](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135448633.png)

![image-20240320135506201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135506201.png)



### 迭代器

vector的rbegin()方法会返回一个反向迭代器指向最后一个元素，该迭代器执行++操作会往前面移动一个元素

it->func() = (*it).func()



### 数组

![image-20240320144822974](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320144822974.png)



![image-20240320145742474](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320145742474.png)



![image-20240320150054220](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320150054220.png)





### 显示转换

- static_cast

  ![image-20240320152952804](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320152952804.png)

- const_cast

  ![image-20240320153131766](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153131766.png)

- reinterpret_cast

  ![image-20240320153225174](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153225174.png)

- dynamic_cast

  `dynamic_cast`是四个强制类型转换操作符中最特殊的一个，因为它支持`运行时`识别指针和引用。用于`类继承层次间的指针或引用转换`主要用于**安全的向下转型**，至于向上转型本身就是安全的，因此没必要使用dynamic_cast

```cpp
#include <iostream>
using namespace std;

class MyClass
{
public:
    void foo() { cout << "Non-const foo" << endl; }
    void foo() const { cout << "Const foo" << endl; }
};

int main()
{
    int i, j;

    // static_cast
    double slope = static_cast<double>(j) / i;
    void *p = nullptr;
    double *dp = static_cast<double *>(p);

    // const_cast
    const MyClass obj;
    obj.foo();                        // 调用const版本的foo
    const_cast<MyClass &>(obj).foo(); // 通过const_cast调用非const版本的foo

    // reinterpret_cast
    int *ip;
    char *pc = reinterpret_cast<char *>(ip);

    return 0;
}
```



### try语句块和异常处理

![image-20240320161334919](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320161334919.png)



![image-20240320181841608](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320181841608.png)



**寻找异常的处理代码过程**

![image-20240320182252095](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320182252095.png)





### 万能引用、引用折叠、完美转发

**万能引用**

```cpp
void foo(int &&i){}; // i为右值引用

template <typename T>
void bar(T &&t) {} // t为万能引用

constexpr int get_val() { return 5; }
int &&x = get_val(); // x为右值引用
auto &&y = get_val(); // y为万能引用
```

右值引用只能绑定一个右值，而万能引用既能绑定左值，也能绑定右值



**引用折叠**

所谓的完能引用实际上是发生了类型推导，在这个推导的过程中，如果初始化的源对象是一个左值，则目标对象会推导出一个左值引用，反之如果源对象是一右值，则会推导出一个左值引用



引用折叠：C++11添加的一套引用叠加推导规则

有一个左值引用，那么最终类型就是左值引用（遇左则左）

![image-20240322190230326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322190230326.png)





万能引用+引用折叠用于实现完美转发，完美转发避免了额外的拷贝

一般来说，传个引用就可以避免拷贝了，但是由于引用是左值引用，所以当传入右值时就不行了。因此完美转发就实现了可以同时处理左值和右值



**完美转发**

示例代码：

```cpp
template<typename T>
void print(T & t){
    std::cout << "Lvalue ref" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "Rvalue ref" << std::endl;
}

template<typename T>
void testForward(T && v){
    //虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！
    print(v); //永远调用左值版本的print
    
    print(std::forward<T>(v)); //底层实际上就是static_cast<T&&>(v)
    
    print(std::move(v)); //永远调用右值版本的print

    std::cout << "======================" << std::endl;
}

int main(int argc, char * argv[])
{
    int x = 1;
    testForward(x); //实参为左值
    testForward(std::move(x)); //实参为右值
}
```

运行结果：

> ```text
> Lvalue ref
> Lvalue ref
> Rvalue ref
> /======================
> Lvalue ref
> Rvalue ref
> Rvalue ref
> /======================
> ```



本质问题在于无论是左值、右值在当作函数参数传递时，函数的参数在被使用时都会被当作左值，因为该参数在内存中已经有了位置


在STL中随处可见这种问题，C++11引入的emplace_back，它接受左值也接受右值作为参数，接着，它转调用construct函数，而construct函数转调用placement new，placement new根据传入的参数是左值还是右值再决定调用拷贝构造函数还是移动构造函数



`std::forward`实现如下：

```cpp
template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}
```

`std::move`实现方式和`std::forward`类似，也是通过完美引用和强制类型转换





### emplace_back和push_back

```cpp
#include <iostream>
#include <vector>
using namespace std;

class A
{
public:
    A() = default;
    A(const A &rhs)
    {
        cout << "copy constructor" << endl;
    }
    A(A &&rhs)
    {
        cout << "move constructor" << endl;
    }
};

int main(int argc, char *argv[])
{
    vector<A> vec;
    vec.reserve(20);
    A temp;
	
    // 虽然temp2是右值引用，但它实际上是一个左值
    A &&temp2 = move(temp);
    cout << &temp2 << "\n"
         << &temp << endl;

    // 调用的构造函数，调用的vector的方法
    vec.push_back(temp);               // copy , push_back(const value_type& __x)
    vec.push_back(std::move(temp));    // move , push_back(value_type&& __x)
    vec.push_back(A());                // move , push_back(value_type&& __x)
    vec.emplace_back(temp);            // copy , emplace_back(_Args&&... __args);
    vec.emplace_back(std::move(temp)); // move , emplace_back(_Args&&... __args);
    vec.emplace_back(A());             // move , emplace_back(_Args&&... __args);
}
```

运行结果：

> ```text
> 0x61fddf
> 0x61fddf
> copy constructor
> move constructor
> move constructor
> copy constructor
> move constructor
> move constructor
> ```





### 封装、继承和多态

`封装`

**定义：**将数据和操作数据的方法结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互

**好处：**减少耦合、类内部的结构可以自由修改、更好控制类成员变量、隐藏属性和实现细节



`继承`

**定义：**可以使用已存在的类定义新类，新类可以定义新属性和新方法，但是不能选择性的继承父类的成员

**好处：**使用继承可以非常方便地复用之前的代码，大大提高开发效率

**多重继承：**一个派生类可以同时继承多个基类，由于可能会有成员命名冲突，因此对于同名成员，需要在前面加上类名和域解析符::

```cpp
#include <iostream>
using namespace std;

// 基类
class BaseA
{
public:
    BaseA(int a, int b);
    virtual ~BaseA(); // 把析构函数声明为虚函数，不然派生类的成员变量有指针时，无法释放，因为基类并不知道派生类中添加了哪些成员
    virtual void show();

protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b) : m_a(a), m_b(b)
{
    cout << "BaseA constructor" << endl;
}
BaseA::~BaseA()
{
    cout << "BaseA destructor" << endl;
}
void BaseA::show()
{
    cout << "m_a = " << m_a << endl;
    cout << "m_b = " << m_b << endl;
}

// 基类
class BaseB
{
public:
    BaseB(int c, int d);
    virtual ~BaseB();
    virtual void show();

protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d) : m_c(c), m_d(d)
{
    cout << "BaseB constructor" << endl;
}
BaseB::~BaseB()
{
    cout << "BaseB destructor" << endl;
}
void BaseB::show()
{
    cout << "m_c = " << m_c << endl;
    cout << "m_d = " << m_d << endl;
}

// 派生类
class Derived : public BaseA, public BaseB
{
public:
    Derived(int a, int b, int c, int d, int e);
    virtual void show();
    virtual ~Derived();

private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e) : BaseA(a, b), BaseB(c, d), m_e(e)
{
    cout << "Derived constructor" << endl;
}
Derived::~Derived()
{
    cout << "Derived destructor" << endl;
}
void Derived::show()
{
    BaseA::show(); // 调用BaseA类的show()函数
    BaseB::show(); // 调用BaseB类的show()函数
    cout << "m_e = " << m_e << endl;
}

int main()
{
    Derived obj(1, 2, 3, 4, 5);
    // 其实就是obj.BaseA::show();obj.BaseB::show();这里类名+域解析符::是表示可以从派生类调用到基类函数
    obj.show();
    return 0;
}
```

运行结果：

> BaseA constructor
> BaseB constructor
> Derived constructor
> m_a = 1
> m_b = 2
> m_c = 3
> m_d = 4
> m_e = 5
> Derived destructor
> BaseB destructor
> BaseA destructor



`Derived类内存分布`

一个对象所占内存是其所有成员属性所占内存的总和内存对齐后的大小，如果有虚函数的话还要在加上虚函数表指针

一个派生类所占内存包括它所有的基类大小加上它自己的成员属性的总和内存对齐后的大小，如果如果有虚函数的话还要再加上虚函数表指针



可以看到多重继承下，由于基类A和基类B都有虚函数，因此都有虚函数表，所以派生类有两张虚函数表，一张是继承A的，另一张是继承B的，再看最后虚函数表，发现BaseA和BaseB的虚函数表的内容其中对应被重写的虚函数都改成了Derived中的对应虚函数了

```
C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置

1>class Derived	size(40):
1>	+---
1> 0	| +--- (base class BaseA)
1> 0	| | {vfptr}
1> 8	| | m_a
1>12	| | m_b
1>	| +---
1>16	| +--- (base class BaseB)
1>16	| | {vfptr}
1>24	| | m_c
1>28	| | m_d
1>	| +---
1>32	| m_e
1>  	| <alignment member> (size=4)
1>	+---
1>Derived::$vftable@BaseA@:
1>	| &Derived_meta
1>	|  0
1> 0	| &Derived::{dtor}
1> 1	| &Derived::show
1>Derived::$vftable@BaseB@:
1>	| -16
1> 0	| &thunk: this-=16; goto Derived::{dtor}
1> 1	| &thunk: this-=16; goto Derived::show
```

`派生类是从基类继承的虚函数表，就像继承其它成员属性一样，而对于派生类重写的虚函数，会在虚函数表中对应位置修改虚函数指针`





`多态`

**定义：**函数调用可以有多种形态

- 静态多态：函数重载
- 动态多态：基类指针或引用调用重写虚函数

**多态的构成条件：**

1. 必须通过基类的指针或引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类重写了该虚函数

**好处：**

假设现在有一个基类，类型是人，在源代码中，会调用人的说话方法，这是一个虚函数，但人可以分为多个国家的人，每个国家的语言不一样，我们只需要继承基类人，然后重写对应的说话方法，就可以实现不用改动源代码，而是在运行时会根据基类指针或引用实际绑定的值来调用到对应的函数。这样大大降低了新添功能的复杂度

## 数据结构

### 红黑树

性质：

1. 节点为红色或黑色
2. NIL节点(叶子节点)为黑色
3. 红色节点的子节点为黑色
4. 从根节点到NIL节点的每条路径上的黑色节点数量相同



### 共享指针

#### 共享指针内部实现

**共享指针类型：**

1. shared_ptr: 允许多个指针指向同一对象

   强引用计数：用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)

   弱引用计数：用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)

2. unique_ptr: “独占”所指向的对象

3. weak_ptr: 弱引用，指向shared_ptr所管理的对象



**shared_ptr内部实现原理**

```cpp
class __declspec(novtable) _Ref_count_base
{	// common code for reference counting
private:
	_Atomic_counter_t _Uses;   //记录了引用资源的shared_ptr的个数
	_Atomic_counter_t _Weaks;  //记录了weak_ptr的个数
}

template<class _Ty>
class _Ptr_base
{
private:
    element_type * _Ptr{ nullptr };      //指向资源
    _Ref_count_base * _Rep{ nullptr };   //指向资源引用计数
}

template<class _Ty>
class shared_ptr : public _Ptr_base<_Ty>
```



**make_shared的优势和劣势：**

通过`new`的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过`make_shared`的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）

```cpp
// new: 分配两次内存(一次分配a的内存，一次分配共享信息内存)，并且会造成内存碎片化
A *a = new A;
shared_ptr<A> pa(a);

// make_shared: 只分配一次内存(内部对象内存、共享信息内存一起分配)，且内部对象和共享信息控制块内存连续
auto p = make_shared<A>(1);
```

![image-20240318174921402](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174921402.png)



![image-20240318174936806](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174936806.png)

```cpp
// shared_ptr

#include <iostream>
using namespace std;

class Count
{
public:
    Count() : count(1) {}

    void increase()
    {
        ++this->count;
    }

    void decrease()
    {
        --this->count;
    }

    int get_count() const
    {
        return this->count;
    }

private:
    // 初始化为0，预防空指针情况
    int count = 0;
};

template <typename T>
class SharedPtr
{
public:
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}
    explicit SharedPtr(T *ptr) : ptr_(ptr), count_(new Count()) {}
    SharedPtr(const SharedPtr<T> &other)
    {
        ptr_ = other.ptr_;
        count_ = other.ptr_;
        count_->increase();
    }

    ~SharedPtr()
    {
        if (this->count_ != nullptr)
        {
            this->count_->decrease();
            if (count_->get_count() == 0)
            {
                delete ptr_;
                delete count_;
                ptr_ = nullptr;
                count_ = nullptr;
            }
        }
    }

    SharedPtr<T> &operator=(const SharedPtr<T> &other)
    {
        if (ptr_ != other.ptr_)
        {
            this->count_->decrease();
            if (this->count_->get_count() == 0)
            {
                delete this->ptr_;
                delete this->count_;
                this->ptr_ = nullptr;
                this->count_ = nullptr;
            }
        }
        this->ptr_ = other.ptr_;
        this->count_ = other.count_;
        count_->increase();
    }

    T *get()
    {
        return ptr_;
    }

    T *operator->
    {
        return ptr_;
    }

    T &operator*
    {
        return *ptr_;
    }

    int get_count() const
    {
        if (count_ == nullptr)
            return 0;
        return count_->get_count();
    }

private:
    T *ptr_;
    Count *count_;
};

```



**循环引用问题**

![image-20240318175337344](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318175337344.png)

产生原因详解：

根据代码执行顺序，share_ptr指针指向new创建的一个Person对象，也就是图中栈空间的person指针指向了堆空间的Person对象，引用计数为1，同理，car指针也指向了堆空间的Car对象，引用计数亦为1。

接下来，Person对象里的成员m_car指向Car对象，Car对象的引用计数加1后为2，Car对象的m_person也指向Person对象，Person对象引用计数也加1为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1后为1，后释放person指针，Person对象的引用计数也减为1。由于Person对象和Car对象都是建立再堆空间上，两者相互依赖，都在等待对方释放。

可以看到，这个例子中，堆空间里的 Person对象 与 Car对象互相使用着，导致双方的 shared_ptr 强引用数量不会为0，所以不会自动释放内存，产生了内存泄漏。

```cpp
#include<iostream>
#include<memory>
using namespace std;

class Car;

class Person {
public:
	shared_ptr<Car>m_car = nullptr;
};

class Car {
public:
	shared_ptr<Person>m_person = nullptr;
};

int main() {
	shared_ptr<Person>person(new Person);
	shared_ptr<Car>car(new Car);
	person->m_car = car;
	car->m_person = person;
	person.~shared_ptr();
	car.~shared_ptr();

	cout << person.use_count() << endl; // 1
	cout << car.use_count() << endl;// 1
}
```



解决方案：weak_ptr

![image-20240318180105547](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180105547.png)

![image-20240318180113901](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180113901.png)

根据之前的分析可知，前三句代码执行完后，Person对象的引用计数为1，Car对象的引用计数为2。而第四条语句car->m_person = person执行的便是途中虚线弱引用的语句，不增加Person对象的引用计数。因此，Person对象的引用计数为1，Car对象的引用计数为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1为1，后释放person指针，Person对象的引用计数减1后为0，Person对象释放内存空间，因此m_car成员变量也得到释放，Car对象引用计数减1后为0，Car对象也得到释放。因此不会产生内存泄漏。

#### 共享指针线程安全

共享指针本身不负责多线程安全，而应该由程序员负责



**线程安全的定义**

多线程操作一个共享数据时，保证所有线程的行为是符合预期的则称为线程安全



**智能指针的线程安全隐患**

1. 引用计数的加减操作是否线程安全
2. 修改shared_ptr指向是否线程安全
3. shared_ptr\<T\>的T并发操作的安全性



> shared_ptr中除了有一个指向对象的指针，还有一个指向控制块的指针，里面存放了所有管理智能指针的数据（强引用计数、弱引用计数等），说明是在堆上的



**结论**

1）同一个shared_ptr被多个线程“读”是安全的；

2）同一个shared_ptr被多个线程“写”是不安全的；

3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的，因为采用原子操作保证该区域的引用计数值被互斥地访问



#### STL容器线程安全

STL（Standard Template Library）容器通常不是线程安全的。STL容器在设计上不考虑多线程并发访问的情况，因此在多线程环境下，对容器进行并发读写操作可能导致数据竞争和未定义行为。

如果需要在多线程环境下使用STL容器，需要采取额外的措施来确保线程安全，比如使用互斥锁（mutex）来保护容器的访问，或者使用线程安全的替代容器，如`std::shared_mutex`、`std::shared_timed_mutex`和`std::atomic`等。



### emplace_back无法取代push_back

![image-20240322140202982](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322140202982.png)

## 数据库

### COUNT函数

> - COUNT有几种用法？`COUNT(expr)、COUNT(常量)、COUNT(*)`
> - COUNT(字段名)和COUNT(\*)的查询结果有什么不同？`前者不统计NULL值，后者统计`
> - COUNT(1)和COUNT(\*)之间有什么不同？`COUNT(*)是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化`
> - COUNT(1)和COUNT(\*)之间的效率哪个更高？`起始是一样的，但由于COUNT(*)是标准语法，因此更推荐使用COUNT(*)`
> - 为什么《阿里巴巴Java开发手册》建议使用COUNT(\*)`理由同上`
> - MySQL的MyISAM引擎对COUNT(\*)做了哪些优化？`每张表都单独记录了行数`
> - MySQL的InnoDB引擎对COUNT(\*)做了哪些优化？`通过低成本的索引进行扫表，只关注表的记录数而不关注字段内容`
> - 上面提到的MySQL对COUNT(\*)做的优化，有一个关键的前提是什么？`优化的前提是查询语句中不包含where条件和group by条件`
> - SELECT COUNT(\*) 的时候，加不加where条件有差别吗？`加where条件COUNT(*)就没有优化了`
> - COUNT(\*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？`见下面第二条`

1. COUNT(expr): 返回SELECT语句检索的行中expr值不为NULL的数量，结果是一个BIGINT值

   如果查询结果没有命中任何记录，则返回0

   COUNT(*)的统计结果中，会包含NULL的行数

2. `COUNT(常量)` 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数。

   而`COUNT(列名)`表示的是查询符合条件的列的值不为NULL的行数。

   `COUNT(*)`是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化

3. COUNT(*)的优化：

   - MyISAM

     MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。

   - InnoDB

     InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。

     但是，InnoDB还是针对COUNT(*)语句做了些优化的。

     通过低成本的索引进行扫表，而不关注表的具体内容。

     InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

     **MySQL会优先选择最小的非聚簇索引来扫表。**

     优化的前提是查询语句中不包含where条件和group by条件。

4. COUNT(字段)

   进行全表扫描，判断指定字段的值是否为`NULL`，不为`NULL`则累加。

   性能比`count(1)`和`count(*)`慢。



### 聚簇索引和非聚簇索引

- 聚簇索引（Clustered Index），也叫主键索引，并不是一种单独的索引类型，而是一种`数据存储方式`。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。`无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引`。InnoDB的聚簇索引实际上是`将索引和数据保存中同一个B+Tree中`。InnoDB通过`主键`聚集数据，`如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替`。如果没有这样的索引，InnoDB会隐式定义一个主键（自增id）来作为聚簇索引。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080712264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

  

- 非聚簇索引（NoClustered  Index），又叫`二级索引`。`二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值`。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，`获得行的主键值，然后使用主键去聚簇索引中查找数据行`，这需要`两次`B+Tree查找。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080810940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)



### UNIQUE

UNIQUE创建的是`唯一索引`



## 操作系统

### 调度算法

#### 银行家算法

Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，`把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可`。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。



安全状态概念：

![](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125164249992-1856910147.png)

1. 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2. 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即`系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态`。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即`每当进程提出资源请求且系统的资源能够满足该请求`时：

系统将判断满足此次资源请求后系统状态是否安全？

- 安全：给该进程分配资源
- 不安全：不分配资源，申请资源的进程将阻塞



银行家算法的执行有个`前提条件`，即要求进程预先提出自己的`最大资源请求`，并`假设系统拥有固定的资源总量`。



### 内存管理

#### 进程虚拟内存空间分布

1. .text(代码段)：

   用于存放程序代码的区域， 编译时确定， 只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

2. .data(数据段):

   用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了`初值(不为0)的全局变量、常量和静态变量`都存放在这个域。

3. .bss：

   bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

   data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。

   data段包含经过初始化的全局变量以及它们的值。

   BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。

4. 堆：

   向高地址伸长

5. 栈：

   向低地址伸长





### 网络系统

#### 零拷贝

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8F%90%E7%BA%B2.png)



##### DMA（Direct Memory Access直接内存访问）

没有DMA技术前，I/O的过程如下：

1. CPU发出对应指令给磁盘控制器，然后返回
2. 磁盘接收到指令后，开始准备数据，然后把数据放到磁盘控制器的内部缓冲区，之后产生一个中断
3. CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的内部缓冲区一个一个字节读到自己的寄存器中，然后再把寄存器中的数据写入到内存，CPU在数据传输阶段是无法执行其它任务的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/I_O%20%E4%B8%AD%E6%96%AD.png)





**DMA技术**：在进行I/O设备和内存的数据传输时，全部由DMA控制器完成，而CPU不再参与任何跟数据搬运相关的事情，这样就可以解放CPU去处理别的事务了

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png)



内核缓冲区是内核利用一部分物理内存分配出来的



##### 传统文件传输

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)

4次上下文切换（用户态和内核态之间的切换）

4次拷贝：

1. 从磁盘控制器的内部缓冲区拷贝到内核缓冲区，由DMA完成
2. 内核缓冲区拷贝到用户缓冲区，由CPU完成
3. 用户缓冲区拷贝到内核socket缓冲区，由CPU完成
4. 从内核socket缓冲区拷贝到网卡缓冲区，由DMA完成



`提高文件传输效率，从两个方面优化，一是减少用户态与内核态的切换，二是减少内存拷贝次数`

##### 优化文件传输的性能

1. 减少用户态与内核态的切换：减少系统调用的次数
2. 由于从内核缓冲区拷贝到用户缓冲区的数据并不会再加工，所以数据可以不用拷贝到用户空间，因此用户缓冲区没有存在的必要



##### 实现零拷贝

1. **mmap+write**

   mmap系统调用会把内核缓冲区的数据直接映射到用户空间，因此内核与用户空间就不需要进行任何拷贝操作了

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)

   流程如下：

   1. 应用进程调用mmap后，DMA会把磁盘中的数据拷贝到内核缓冲区中，用户进程和内核共享这块内核缓冲区
   2. 应用进程再调用write，数据从内核缓冲区拷贝到内核socket缓冲区，由CPU完成
   3. 最后，把数据从socket缓冲区拷贝到网卡缓冲区，由DMA完成

   仍需要4次上下文切换和3次拷贝

   

2. **sendfile**

   系统调用函数：

   ```c
   #include <sys/socket.h>
   ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
   ```

   out_fd: 目的端文件描述符

   in_fd: 源端文件描述符

   offset: 源端偏移量

   count: 要复制的数据长度

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)

   减少了一次系统调用，因此少了两次上下文切换

   但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。

   你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

   ```shell
   $ ethtool -k eth0 | grep scatter-gather
   scatter-gather: on
   ```

   

   对于支持SG-DMA技术的网卡，sendfile系统调用过程如下：

   1. 将数据从磁盘拷贝到内核缓冲区，由DMA完成
   2. 缓冲区描述符和数据长度传到socket缓冲区，SG-DMA控制器可以直接将数据从内核缓冲区拷贝到网卡缓冲区，不需要将数据从内核缓冲区拷贝到socket缓冲区

   `这就是零拷贝技术，因为不存在内存层面上的数据拷贝，意味着全程没有通过CPU来拷贝数据，所有的数据都是通过DMA来传输。只需要2次上下文切换和2次拷贝`



##### PageCache

前面的第一步拷贝都是拷贝到内核缓冲区，这个内核缓冲区实际上是磁盘高速缓存（PageCache）

零拷贝如果使用PageCache技术，那么性能可以进一步提升



**PageCache提高性能的方式：**

1. 由于`局部性原理`，刚被访问的数据再次被访问的概率很高，于是用PageCache来缓存最近被访问的数据，当空间不足时淘汰掉最久未被访问的缓存

   因此，在读取磁盘数据时，优先去PageCache找，如果没有再到磁盘中读取，然后缓存PageCache

2. 预读功能：比如，假设 read 方法每次只会读 `32 KB` 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。



**但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能**



##### 大文件传输方式

读取文件时，进程会进入阻塞状态，我们可以采用异步I/O的方式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png)



读操作分为两部分：

- 前半部分：内核向磁盘发起读请求，但是可以不等待数据就位就返回，于是进程此时就可以处理后面的任务
- 后半部分：当内核将磁盘中的数据拷贝到进程缓冲区后，进程接收到内核的通知，再去处理数据



异步I/O要绕开PageCache

绕开PageCache的叫直接I/O，使用PageCache的是缓存I/O，对于磁盘，异步I/O只支持直接I/O



大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。



`在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术`。



**传输文件方式：**

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；





#### I/O多路复用：select/poll/epoll

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8F%90%E7%BA%B2.png)



##### socket编程

服务端：

1. 调用socket(int domain, int type, int protocol)函数，创建网络协议为IPv4，以及传输协议为TCP的Socket
2. 调用bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数，给这个Socket绑定一个IP地址和端口
   - 绑定端口的目的：通过端口号找到应用程序
   - 绑定IP的目的：找到对应网卡，因为每个网卡都有对应的IP地址
3. 调用 listen(int sockfd, int backlog)函数监听,backlog限制accept队列（全连接队列）的大小
4. 调用accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)函数连接客户端，如果此时没有客户端连接，则会阻塞等待下一个客户端的连接



客户端：

创建好socket之后，调用connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数发起连接



然后TCP三次握手就开始了，

在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：

- 一个是「还没完全建立」连接的队列，称为 **TCP 半连接队列**，这个队列都是没有完成三次握手的连接，此时服务端处于 `syn_rcvd` 的状态；
- 一个是「已经建立」连接的队列，称为 **TCP 全连接队列**，这个队列都是完成了三次握手的连接，此时服务端处于 `established` 状态；

当 TCP 全连接队列不为空后，服务端的 `accept()` 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。

注意，监听的 Socket 和真正用来传数据的 Socket 是两个：

- 一个叫作**监听 Socket**；
- 一个叫作**已连接 Socket**；

连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 `read()` 和 `write()` 函数来读写数据。





**线程池**的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理



##### IO多路复用

使用多进程/多线程来管理每个socket的开销比较大，因此使用I/O多路复用技术



概念：一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。



select/poll/epoll: `进程可以通过一个系统调用函数从内核中获取多个事件`



1. `select`

   - 函数：

     ```c
     int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
     ```

   - 实现方式：将已连接时Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核中，内核遍历文件描述符集合，如果有网络事件产生，那么就将Socket标记为可读可写，接着再把整个文件描述符集合拷贝回用户，用户进程遍历文件描述符集合，如果找到可读可写的Socket，代表着有网络事件，再对其进行读写

   - 弊端：select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

2. `poll`

   - 函数：

     ```c
     struct pollfd {
     　　 int fd;           /*文件描述符*/
     　　 short events;     /*监控的事件*/
     　　 short revents;    /*监控事件中满足条件返回的事件*/
     };
     int poll(struct pollfd *fds, unsigned long nfds, int timeout);   
     ```

   - 实现方式：poll和select的唯一区别在于，poll是通过动态数组来管理文件描述符的，以链表的方式组织。突破了select的文件描述符个数限制，但仍受到系统文件描述符限制，并且poll依旧是把文件描述符数组拷贝到内核中，然后内核遍历数组判断是否有网络事件发生，如果有就标记为可读可写，接着再拷回用户态，用户进程遍历文件描述符数组判断是否可读可写，再做相应的处理

3. `epoll`

   - 函数：

     ```c
     // 该函数生成一个 epoll 专用的文件描述符。
     int epoll_create(int size);
     
     // epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
     int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
     
     // 等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。返回需要处理的事件数目
     int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
     ```

   - 用法：

     ```c
     int s = socket(AF_INET, SOCK_STREAM, 0);
     bind(s, ...);
     listen(s, ...)
     
     int epfd = epoll_create(...);
     epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
     
     while(1) {
         int n = epoll_wait(...);
         for(接收到数据的socket){
             //处理
         }
     }
     ```

   - 从两个方面解决`select`和`poll`的问题:

     1. 传入参数：epoll在内核中使用红黑树来跟踪所有进程的待检测的文件描述符，由于内核有文件描述符集合的信息，因此用户进程只需要传入一个待检测的socket即可
     2. 检测有事件发生的socket：epoll使用事件驱动，内核里维护了一个链表来记录就绪事件，当某个socket有时间发生时，就回通过回调函数加入到该就绪时间链表当中，当用户调用epoll_wait()函数时，返回有事件发生的文件描述符个数，不需要像select和poll去遍历整个文件描述符集合

     内核会将就绪事件链表拷贝到用户空间中，即第二个参数events，这样就知道有哪些socket是有事件的

   - `边缘触发（edge-triggered，ET）`:

     使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；

     **如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作，直到系统调用（如 `read` 和 `write`）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。**

     **一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。**

   - `水平触发（level-triggered，LT）`:

     使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

     **如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。**

   - 一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

   - select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。



### 进程管理



## 离散数学

### 拓扑序列

拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点 u  到顶点 v 的每个有向边  uv， u 在序列中都在 v 之前。



拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。



不是所有的有向图都是有拓扑序的，只有**有向无环图**才有拓扑序，所以**有向无环图又被称为拓扑图**。



## 计算机概论

### 原码、反码和补码

|      | 原码（符号位：正0负1） | 反码（原码除符号位取反） | 补码（反码+1） |
| ---- | ---------------------- | ------------------------ | -------------- |
| 10   | 0000 1010              | 0111 0101                | 0111 0110      |
| -10  | 1000 1010              | 1111 0101                | 1111 0110      |



