## C++

### 算法

#### 并查集

- 解决连通性问题：

  1. 将两个元素添加到同一个集合中
  2. 判断两个元素是否在同一个集合中

- 关键方法：

  1. join(u,v): 将uv这条边加入并查集
  2. find(u): 寻找u的根节点
  3. init(): 初始化并查集，每个元素的根节点都是自己本身
  4. isSame(u,v): 判断是否有uv边，即u、v是否在同一个集合中

- 优化：

  路径压缩：不做优化的情况下，find可能需要递归好几层才能找到根节点，如果在递归的过程中重新设置每个元素的父节点，都将自己指向父结点的边改为指向原来的根节点，这样就可以把树的高度减为2，大大降低了递归深度

  由

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png" alt="img" style="zoom: 50%;" />

变成

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom: 67%;" />



代码：

```cpp
class UnionSet
{
public:
    UnionSet(int size)
    {
        size_ = size;
        father = vector<int>(size, 0);
        // 初始化，元素都指向自己本身
        for (int i = 0; i < size_; i++)
        {
            father[i] = i;
        }
    }

    // 查找u的根元素并且路径压缩
    int find(int u)
    {
        return u == father[u] ? u : father[u] = find(father[u]);
    }

    // 合并两个元素所在集合
    void join(int u, int v)
    {
        // 找到两个元素的根元素，然后合并两棵树，这样相当于在同一个集合里了
        u = find(u);
        v = find(v);
        // 已经在同一个集合就不需要再次合并了
        if (u == v)
            return;

        father[v] = u;
    }

    // 判断两个元素是否在同一个集合中
    bool isSame(int u, int v)
    {
        // 根元素相同就代表在同一个集合中
        return find(u) == find(v);
    }

private:
    int size_;
    vector<int> father;
};
```



#### 排序算法

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序：将大数像泡泡一样冒到最后（稳定）
void bubbleSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            if (vec[j] > vec[j + 1])
            {
                int tmp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = tmp;
            }
        }
    }
}

// 选择排序：选择一个基准值，将其后面最小的值与其交换（不稳定）
void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = vec[i];
        vec[i] = vec[minIndex];
        vec[minIndex] = tmp;
    }
}

// 插入排序：将值插入到前面某个合适的位置
void insertionSort(vector<int>& vec) {
    int n = vec.size();
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        // 后移腾位
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }
}


// 快速排序：选一个基准值，小于它的放左边，大于它的放右边
class QuickSort
{
public:
    QuickSort() {};

    // 快速划分函数
    int partion(vector<int>& vec, int left, int right)
    {
        int pivot = vec[right];
        int index = left;

        // 大于pivot放右边，小于pivot放左边
        for (int i = left; i < right; ++i)
        {
            if (vec[i] < pivot)
            {
                swap(vec[i], vec[index++]);
            }
        }

        // 放置基准值
        swap(vec[right], vec[index]);
        return index;
    }

    // 快速排序
    void quickSort(vector<int>& vec, int left, int right)
    {
        if (left < right)
        {
            int pi = partion(vec, left, right);

            quickSort(vec, left, pi - 1);
            quickSort(vec, pi + 1, right);
        }
    }
};

// 归并排序：合并两个有序子数组
class MergeSort {
public:
    MergeSort() {};

    void merge(vector<int>& vec, int left, int mid, int right) {
        int size1 = mid - left + 1;
        int size2 = right - mid;

        vector<int>left_vec(size1);
        vector<int>right_vec(size2);

        for (int i = 0; i < size1; ++i) {
            left_vec[i] = vec[left + i];
        }
        for (int j = 0; j < size2; ++j) {
            right_vec[j] = vec[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while (i < size1 && j < size2) {
            if (left_vec[i] < right_vec[j]) {
                vec[k++] = left_vec[i++];
            }
            else {
                vec[k++] = right_vec[j++];
            }
        }

        while (i < size1) {
            vec[k++] = left_vec[i++];
        }
        while (j < size2) {
            vec[k++] = right_vec[j++];
        }
    }

    void mergeSort(vector<int>& vec, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(vec, left, mid);
            mergeSort(vec, mid + 1, right);

            merge(vec, left, mid, right);
        }
    }
};




int main()
{
    vector<int> vec{ 2, 1, 5, 4, 7, 6, 0 ,3 };

    // bubbleSort(vec);
    // selectionSort(vec);
    // QuickSort q;
    // q.quickSort(vec, 0, vec.size() - 1);
    // insertionSort(vec);
    MergeSort m;
    m.mergeSort(vec, 0, vec.size() - 1);


    for (auto& num : vec)
    {
        cout << num << " ";
    }
}
```



#### 图

**迪杰斯特拉算法：**找某一起点到所有点的最短路径

时间复杂度：O(n^2)

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int INF = INT_MAX;

int main()
{
    int n; // 节点数
    int e; // 边数
    int s; // 起点
    cin >> n >> e >> s;

    // 起点到其它节点的最短路径长
    vector<int> dis(n, INF);
    dis[s] = 0;

    // 确保s到某个节点的路径已是最短
    vector<bool> check(n, false);

    // 图
    vector<vector<int>> graph(n, vector<int>(n, -1));
    for (int i = 0; i < e; i++)
    {
        int start, end, dis;
        cin >> start >> end >> dis;
        graph[start][end] = dis;
    }

    for (int i = 0; i < n; i++)
    {
        int min_dis = INF, min_idx = n;
        for (int j = 0; j < n; j++)
        {
            // 检查check可以避免重复在一个节点打转
            if (dis[j] < min_dis && !check[j])
            {
                min_dis = dis[j];
                min_idx = j;
            }
        }
        check[min_idx] = true;

        for (int k = 0; k < n; k++)
        {
            // 从min_idx节点到k节点距离更短，则更新，前提是min_idx节点和k节点是连通的
            if (graph[min_idx][k] > 0)
            {
                if (min_dis + graph[min_idx][k] < dis[k])
                {
                    dis[k] = min_dis + graph[min_idx][k];
                }
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        cout << dis[i] << " ";
    }
}
```

**最小生成树：**Kruscal算法和Prim算法（无向连通带权图）
prime算法复杂度由顶点数决定，更适合稠密图，而K算法由边数决定，故更适合稀疏图

- Prim算法：每次都选择到下一顶点权最小的边。

  - `Prim算法从一个初始顶点开始`，然后逐步扩展生成树，每次选择连接生成树和未加入生成树的顶点的权重最小的边。具体步骤如下：
    - 选择一个起始顶点作为生成树的根节点。
    - 将该节点标记为已访问，并将其与之相邻的所有边加入到优先队列中。
    - 从优先队列中选择权重最小的边，如果其连接的节点未被访问，则将该节点加入生成树，并将与该节点相邻的边加入优先队列中。
    - 重复以上步骤，直到所有节点都被访问过，生成树构建完成。
  - Prim算法的时间复杂度通常为 O(V^2) 或 O(E*logV)，其中V是顶点数，E是边数。

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  class Edge
  {
  public:
      Edge(int _to, int _weight) : to(_to), weight(_weight) {}
  
      int to;
      int weight;
  };
  
  int prim(const vector<vector<Edge>> &graph)
  {
      int minCost = 0;
      int n = graph.size();
      // 已访问节点为true
      vector<bool> visited(n, false);
      // 存放着所有已连接树 连接 未连接树的信息(权重，终点)
      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
  
      // 起始节点为0
      pq.push({0, 0});
  
      while (!pq.empty())
      {
          int w = pq.top().first;
          int u = pq.top().second;
          pq.pop();
  
          if (visited[u])
              continue;
  
          visited[u] = true;
          minCost += w;
  
          for (const Edge &edge : graph[u])
          {
              if (!visited[edge.to])
              {
                  pq.push({edge.weight, edge.to});
              }
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
      vector<vector<Edge>> graph(n);
  
      for (int i = 0; i < e; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          graph[u].emplace_back(Edge(v, w));
          graph[v].emplace_back(Edge(u, w));
      }
  
      cout << prim(graph);
  }
  ```

  

- Kruskal算法：每次都选择权最小的可以连通两个不同连通分支的边

  `边排序(权重从小到大) + 并查集`

  步骤：

  1. 边排序后，遍历边
  2. 如果边的两个顶点没加到并查集中，代表未连接，加入并查集、

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  
  struct Edge
  {
      int u;
      int v;
      int weight;
  };
  
  bool compare(Edge a, Edge b)
  {
      return a.weight < b.weight;
  }
  
  class Union
  {
  public:
      Union(int n)
      {
          parent.resize(n);
          rank.assign(n, 0);
          for (int i = 0; i < n; i++)
          {
              parent[i] = i;
          }
      }
  
      int find(int u)
      {
          if (u == parent[u])
              return u;
          parent[u] = find(parent[u]);
          return parent[u];
      }
  
      void join(int u, int v)
      {
          u = find(u);
          v = find(v);
          if (rank[u] < rank[v])
          {
              parent[u] = v;
          }
          else if (rank[u] > rank[v])
          {
              parent[v] = u;
          }
          else
          {
              parent[v] = u;
              rank[u]++; // 高度增加了
          }
      }
  
      bool is_connect(int u, int v)
      {
          return find(u) == find(v);
      }
  
      vector<int> parent;
      vector<int> rank; // 用于判断树的高度，将高度低的树加到高度高的树上可以减少整个树的高度
  };
  
  /// @brief 生成最小树
  /// @param edges 所有边
  /// @param n 节点数
  /// @return 最小权重
  int kruskal(vector<Edge> &edges, int n)
  {
      int minCost = 0;
      Union uf(n);
  
      sort(edges.begin(), edges.end(), compare);
  
      for (auto &e : edges)
      {
          if (!uf.is_connect(e.u, e.v))
          {
              uf.join(e.u, e.v);
              minCost += e.weight;
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
  
      vector<Edge> edges(e);
  
      for (int i = 0; i < e; i++)
      {
          cin >> edges[i].u >> edges[i].v >> edges[i].weight;
      }
  
      cout << kruskal(edges, n);
  }
  ```

  

### 语法

#### 底层const、顶层const

```cpp
// iter: T* const
vector<T>::iterator iter = vec.begin();
// cIter: const T*
vector<T>::const_iter cIter=vec.begin();
```



#### 左值引用和右值引用

![image-20240320151340925](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151340925.png)

![image-20240320151612193](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151612193.png)

- **左值**: 可取地址的

- **右值**:不是左值就是右值，即不可取地址的

  - **纯右值**: 临时变量值，不跟对象关联的字面量值

  - **将亡值**: 将要被移动的对象，T&&类型的函数返回值、std::move返回值

    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

- **左值引用**: 对左值进行引用

- **右值引用**: 对右值进行引用

```cpp
int &a = 2; // 左值引用绑定到右值，编译失败
int b = 2; // b是非常量左值
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过
const int d = 2; // d是常量左值
const int &e = c; // 常量左值引用绑定到常量右值，编译通过
const int &b = 2; // 常量左值引用绑定到右值，编译通过

右值引用通常不能绑定到任何左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
```



#### 内存对齐

```cpp
// 24
// A的内存分布，对齐double(8)：
// [a][b1][b2][b3][b4][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
struct A {
	char a;
	int b;
	double c;
	char d;
};

// 32
/*
A的内存分布，对齐double(8)：
[a][b1][b2][b3][b4][0][0][0] [e1][e2][e3][e4][0][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
*/
struct B {
	char a;
	int b;
    int e;
	double c;
	char d;
};
```



#### 纯虚函数、虚函数、虚函数表

https://zhuanlan.zhihu.com/p/75172640

https://zhuanlan.zhihu.com/p/270614081





**纯虚函数**

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。



何时使用纯虚函数：

（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

（2）这个方法必须在派生类(derived class)中被实现；

  如果满足以上两点，可以考虑将该方法申明为pure virtual function.



**虚函数、虚函数表**

每个包含了虚函数的类都包含了一张虚函数表

当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。



```cpp
// 类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318203825639.png" alt="image-20240318203825639" style="zoom:150%;" />



虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。



> 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205416612.png" alt="image-20240318205416612" style="zoom:150%;" />



**子类的虚表**

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图所示。

![image-20240318205547970](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205547970.png)

`对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数`



```cpp
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

![image-20240318210458446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318210458446.png)



> 什么时候会执行函数的动态绑定？需要符合以下三个条件
>
> 1. 通过指针来调用函数
> 2. 指针upcast向上转型（继承类向基类的转换称为upcast）
> 3. 调用的是虚函数





#### extern

如果想在多个文件之间共享const变量，必须在变量的定义前加上extern关键字



#### const限定符

![image-20240319210655314](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240319210655314.png)





#### 无符号与有符号的比较

![image-20240320134747641](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320134747641.png)



#### 字符串相加

![image-20240320135448633](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135448633.png)

![image-20240320135506201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135506201.png)



#### 迭代器

vector的rbegin()方法会返回一个反向迭代器指向最后一个元素，该迭代器执行++操作会往前面移动一个元素

it->func() = (*it).func()



#### 数组

![image-20240320144822974](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320144822974.png)



![image-20240320145742474](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320145742474.png)



![image-20240320150054220](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320150054220.png)





#### 显示转换

- static_cast

  ![image-20240320152952804](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320152952804.png)

- const_cast

  ![image-20240320153131766](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153131766.png)

- reinterpret_cast

  ![image-20240320153225174](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153225174.png)

- dynamic_cast

  是C++中的一个类型转换运算符，它用于在运行时进行安全的向下转型（downcasting）。它的主要用途是将基类指针或引用转换为派生类指针或引用，并且在转换时会进行类型检查，以确保转换是安全的。

```cpp
#include <iostream>
using namespace std;

class MyClass
{
public:
    void foo() { cout << "Non-const foo" << endl; }
    void foo() const { cout << "Const foo" << endl; }
};

int main()
{
    int i, j;

    // static_cast
    double slope = static_cast<double>(j) / i;
    void *p = nullptr;
    double *dp = static_cast<double *>(p);

    // const_cast
    const MyClass obj;
    obj.foo();                        // 调用const版本的foo
    const_cast<MyClass &>(obj).foo(); // 通过const_cast调用非const版本的foo

    // reinterpret_cast
    int *ip;
    char *pc = reinterpret_cast<char *>(ip);

    return 0;
}
```



#### try语句块和异常处理

![image-20240320161334919](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320161334919.png)



![image-20240320181841608](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320181841608.png)



**寻找异常的处理代码过程**

![image-20240320182252095](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320182252095.png)



## 数据结构	

### 红黑树

性质：

1. 节点为红色或黑色
2. NIL节点(叶子节点)为黑色
3. 红色节点的子节点为黑色
4. 从根节点到NIL节点的每条路径上的黑色节点数量相同



### 共享指针

**共享指针类型：**

1. shared_ptr: 允许多个指针指向同一对象

   强引用计数：用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)

   弱引用计数：用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)

2. unique_ptr: “独占”所指向的对象

3. weak_ptr: 弱引用，指向shared_ptr所管理的对象



**make_shared的优势和劣势：**

通过`new`的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过`make_shared`的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）

```cpp
// new: 分配两次内存(一次分配a的内存，一次分配共享信息内存)，并且会造成内存碎片化
A *a = new A;
shared_ptr<A> pa(a);

// make_shared: 只分配一次内存(内部对象内存、共享信息内存一起分配)，且内部对象和共享信息控制块内存连续
auto p = make_shared<A>(1);
```

![image-20240318174921402](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174921402.png)



![image-20240318174936806](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174936806.png)

```cpp
// shared_ptr

#include <iostream>
using namespace std;

class Count
{
public:
    Count() : count(1) {}

    void increase()
    {
        ++this->count;
    }

    void decrease()
    {
        --this->count;
    }

    int get_count() const
    {
        return this->count;
    }

private:
    // 初始化为0，预防空指针情况
    int count = 0;
};

template <typename T>
class SharedPtr
{
public:
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}
    explicit SharedPtr(T *ptr) : ptr_(ptr), count_(new Count()) {}
    SharedPtr(const SharedPtr<T> &other)
    {
        ptr_ = other.ptr_;
        count_ = other.ptr_;
        count_->increase();
    }

    ~SharedPtr()
    {
        if (this->count_ != nullptr)
        {
            this->count_->decrease();
            if (count_->get_count() == 0)
            {
                delete ptr_;
                delete count_;
                ptr_ = nullptr;
                count_ = nullptr;
            }
        }
    }

    SharedPtr<T> &operator=(const SharedPtr<T> &other)
    {
        if (ptr_ != other.ptr_)
        {
            this->count_->decrease();
            if (this->count_->get_count() == 0)
            {
                delete this->ptr_;
                delete this->count_;
                this->ptr_ = nullptr;
                this->count_ = nullptr;
            }
        }
        this->ptr_ = other.ptr_;
        this->count_ = other.count_;
        count_->increase();
    }

    T *get()
    {
        return ptr_;
    }

    T *operator->
    {
        return ptr_;
    }

    T &operator*
    {
        return *ptr_;
    }

    int get_count() const
    {
        if (count_ == nullptr)
            return 0;
        return count_->get_count();
    }

private:
    T *ptr_;
    Count *count_;
};

```



**循环引用问题**

![image-20240318175337344](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318175337344.png)

产生原因详解：

根据代码执行顺序，share_ptr指针指向new创建的一个Person对象，也就是图中栈空间的person指针指向了堆空间的Person对象，引用计数为1，同理，car指针也指向了堆空间的Car对象，引用计数亦为1。

接下来，Person对象里的成员m_car指向Car对象，Car对象的引用计数加1后为2，Car对象的m_person也指向Person对象，Person对象引用计数也加1为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1后为1，后释放person指针，Person对象的引用计数也减为1。由于Person对象和Car对象都是建立再堆空间上，两者相互依赖，都在等待对方释放。

可以看到，这个例子中，堆空间里的 Person对象 与 Car对象互相使用着，导致双方的 shared_ptr 强引用数量不会为0，所以不会自动释放内存，产生了内存泄漏。

```cpp
#include<iostream>
#include<memory>
using namespace std;

class Car;

class Person {
public:
	shared_ptr<Car>m_car = nullptr;
};

class Car {
public:
	shared_ptr<Person>m_person = nullptr;
};

int main() {
	shared_ptr<Person>person(new Person);
	shared_ptr<Car>car(new Car);
	person->m_car = car;
	car->m_person = person;
	person.~shared_ptr();
	car.~shared_ptr();

	cout << person.use_count() << endl; // 1
	cout << car.use_count() << endl;// 1
}
```



解决方案：weak_ptr

![image-20240318180105547](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180105547.png)

![image-20240318180113901](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180113901.png)

根据之前的分析可知，前三句代码执行完后，Person对象的引用计数为1，Car对象的引用计数为2。而第四条语句car->m_person = person执行的便是途中虚线弱引用的语句，不增加Person对象的引用计数。因此，Person对象的引用计数为1，Car对象的引用计数为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1为1，后释放person指针，Person对象的引用计数减1后为0，Person对象释放内存空间，因此m_car成员变量也得到释放，Car对象引用计数减1后为0，Car对象也得到释放。因此不会产生内存泄漏。

#### 共享指针线程安全

共享指针本身不负责多线程安全，而应该由程序员负责



**线程安全的定义**

多线程操作一个共享数据时，保证所有线程的行为是符合预期的则称为线程安全



**智能指针的线程安全隐患**

1. 引用计数的加减操作是否线程安全
2. 修改shared_ptr指向是否线程安全
3. shared_ptr\<T\>的T并发操作的安全性



> shared_ptr中除了有一个指向对象的指针，还有一个指向控制块的指针，里面存放了所有管理智能指针的数据（强引用计数、弱引用计数等），说明是在堆上的



**结论**

1）同一个shared_ptr被多个线程“读”是安全的；

2）同一个shared_ptr被多个线程“写”是不安全的；

3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的，因为采用原子操作保证该区域的引用计数值被互斥地访问



#### STL容器线程安全

STL（Standard Template Library）容器通常不是线程安全的。STL容器在设计上不考虑多线程并发访问的情况，因此在多线程环境下，对容器进行并发读写操作可能导致数据竞争和未定义行为。

如果需要在多线程环境下使用STL容器，需要采取额外的措施来确保线程安全，比如使用互斥锁（mutex）来保护容器的访问，或者使用线程安全的替代容器，如`std::shared_mutex`、`std::shared_timed_mutex`和`std::atomic`等。



## 操作系统

### 反向映射RMAP

**task_struct、mm_struct、vma关系图：**

![linux源码解析13- 反向映射RAMP详解](https://ctyun-collect-0531.gdoss.xstore.ctyun.cn/files/2023/02/26/acfc619bcd1a42d193f96982024a9e8f.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)





**vma、anon_vma(av)、anon_vma_chain(avc)**

- anon_vma: 连接page和vma的桥梁

  ![linux源码解析13- 反向映射RAMP详解](https://ctyun-collect-0531.gdoss.xstore.ctyun.cn/files/2023/02/26/a87a28673b8042bbbf30c2076bbd6213.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

  ```c
  struct anon_vma { //AV是per VMA的
      struct anon_vma *root; //指向祖宗(root)进程的anon_vma
      struct anon_vma *parent; //指向父进程的anon_vma
      struct rw_semaphore rwsem; /* W: modification, R: walking the list */
      atomic_t refcount; //引用计数
      unsigned degree; //Count of child anon_vmas and VMAs which points to this anon_vma.
      struct rb_root rb_root;	/* Interval tree of private "related" vmas */
  }
  ```
  
- anon_vma_chain: 连接vma和av的枢纽

  avc作用：

  1. 连接`本进程`的vma和av的枢纽
  2. 连接`本进程`的vma和`父进程`的av的枢纽

  ```c
  /* AVC有两种功能：
   * 1、连接本进程的VMA和AV，该种情况下AVC是per VMA的
   * 2、连接父(所有前辈进程)进程的AV与子(孙)进程的VMA，该种情况数量为进程的前辈进程数量
   */
  struct anon_vma_chain {
  	struct vm_area_struct *vma;  //指向VMA
  	struct anon_vma *anon_vma; //指向AV
  	struct list_head same_vma; //把自己挂在VMA->anon_vma_chain链表上
  	struct rb_node rb;			//把自己挂在anon_vma->rb_root红黑树上
  	unsigned long rb_subtree_last;
  };
  ```
  
- vm_area_struct：

  ```c
  struct vm_area_struct {
      struct list_head anon_vma_chain; //VMA和AVC是一对多，把AVC穿成链表
      struct anon_vma *anon_vma; //VMA和AV是一对一的关系
  }
  ```



原因：内存紧张时，需要回收页面，找到准备回收的物理页面（页面回收算法LRU），回收前需要取消VMA对其的映射

1. 如果没有anon_vma，那么页面回收时需要遍历所有进程的vma，浪费时间
2. 如果没有anon_vma_chain，那么在写时复制时，父进程地址空间所映射的物理页面的anon_vma没有及时更新，会保留子进程中的VMA(早已不映射到该物理页面了)，在页面回收时也会做不必要的扫描操作，浪费时间



父进程产生匿名页面时的状态：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c65158e408e14d4191f06aa62b9a878e.jpeg#pic_center)



父进程fork时RMAP机制的流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/9b79e200b11f45dcab2347579c735814.jpeg#pic_center)



### 进程虚拟内存空间分布

1. .text(代码段)：

   用于存放程序代码的区域， 编译时确定， 只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

2. .data(数据段):

   用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了`初值(不为0)的全局变量、常量和静态变量`都存放在这个域。

3. .bss：

   bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

   data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。

   data段包含经过初始化的全局变量以及它们的值。

   BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。

4. 堆：

   向高地址伸长

5. 栈：

   向低地址伸长



## 计算机概论

|      | 原码（符号位：正0负1） | 反码（原码除符号位取反） | 补码（反码+1） |
| ---- | ---------------------- | ------------------------ | -------------- |
| 10   | 0000 1010              | 0111 0101                | 0111 0110      |
| -10  | 1000 1010              | 1111 0101                | 1111 0110      |

