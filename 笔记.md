## C++

### 算法

#### 并查集

- 解决连通性问题：

  1. 将两个元素添加到同一个集合中
  2. 判断两个元素是否在同一个集合中

- 关键方法：

  1. join(u,v): 将uv这条边加入并查集
  2. find(u): 寻找u的根节点
  3. init(): 初始化并查集，每个元素的根节点都是自己本身
  4. isSame(u,v): 判断是否有uv边，即u、v是否在同一个集合中

- 优化：

  路径压缩：不做优化的情况下，find可能需要递归好几层才能找到根节点，如果在递归的过程中重新设置每个元素的父节点，都将自己指向父结点的边改为指向原来的根节点，这样就可以把树的高度减为2，大大降低了递归深度

  由

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png" alt="img" style="zoom: 50%;" />

变成

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom: 67%;" />



代码：

```cpp
class UnionSet
{
public:
    UnionSet(int size)
    {
        size_ = size;
        father = vector<int>(size, 0);
        // 初始化，元素都指向自己本身
        for (int i = 0; i < size_; i++)
        {
            father[i] = i;
        }
    }

    // 查找u的根元素并且路径压缩
    int find(int u)
    {
        return u == father[u] ? u : father[u] = find(father[u]);
    }

    // 合并两个元素所在集合
    void join(int u, int v)
    {
        // 找到两个元素的根元素，然后合并两棵树，这样相当于在同一个集合里了
        u = find(u);
        v = find(v);
        // 已经在同一个集合就不需要再次合并了
        if (u == v)
            return;

        father[v] = u;
    }

    // 判断两个元素是否在同一个集合中
    bool isSame(int u, int v)
    {
        // 根元素相同就代表在同一个集合中
        return find(u) == find(v);
    }

private:
    int size_;
    vector<int> father;
};
```



#### 排序算法

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序：将大数像泡泡一样冒到最后（稳定）
void bubbleSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            if (vec[j] > vec[j + 1])
            {
                int tmp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = tmp;
            }
        }
    }
}

// 选择排序：选择一个基准值，将其后面最小的值与其交换（不稳定）
void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = vec[i];
        vec[i] = vec[minIndex];
        vec[minIndex] = tmp;
    }
}

// 插入排序：将值插入到前面某个合适的位置
void insertionSort(vector<int>& vec) {
    int n = vec.size();
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        // 后移腾位
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }
}


// 快速排序：选一个基准值，小于它的放左边，大于它的放右边
class QuickSort
{
public:
    QuickSort() {};

    // 快速划分函数
    int partion(vector<int>& vec, int left, int right)
    {
        int pivot = vec[right];
        int index = left;

        // 大于pivot放右边，小于pivot放左边
        for (int i = left; i < right; ++i)
        {
            if (vec[i] < pivot)
            {
                swap(vec[i], vec[index++]);
            }
        }

        // 放置基准值
        swap(vec[right], vec[index]);
        return index;
    }

    // 快速排序
    void quickSort(vector<int>& vec, int left, int right)
    {
        if (left < right)
        {
            int pi = partion(vec, left, right);

            quickSort(vec, left, pi - 1);
            quickSort(vec, pi + 1, right);
        }
    }
};

// 归并排序：合并两个有序子数组
class MergeSort {
public:
    MergeSort() {};

    void merge(vector<int>& vec, int left, int mid, int right) {
        int size1 = mid - left + 1;
        int size2 = right - mid;

        vector<int>left_vec(size1);
        vector<int>right_vec(size2);

        for (int i = 0; i < size1; ++i) {
            left_vec[i] = vec[left + i];
        }
        for (int j = 0; j < size2; ++j) {
            right_vec[j] = vec[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while (i < size1 && j < size2) {
            if (left_vec[i] < right_vec[j]) {
                vec[k++] = left_vec[i++];
            }
            else {
                vec[k++] = right_vec[j++];
            }
        }

        while (i < size1) {
            vec[k++] = left_vec[i++];
        }
        while (j < size2) {
            vec[k++] = right_vec[j++];
        }
    }

    void mergeSort(vector<int>& vec, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(vec, left, mid);
            mergeSort(vec, mid + 1, right);

            merge(vec, left, mid, right);
        }
    }
};




int main()
{
    vector<int> vec{ 2, 1, 5, 4, 7, 6, 0 ,3 };

    // bubbleSort(vec);
    // selectionSort(vec);
    // QuickSort q;
    // q.quickSort(vec, 0, vec.size() - 1);
    // insertionSort(vec);
    MergeSort m;
    m.mergeSort(vec, 0, vec.size() - 1);


    for (auto& num : vec)
    {
        cout << num << " ";
    }
}
```



### 语法

#### 底层const、顶层const

```cpp
// iter: T* const
vector<T>::iterator iter = vec.begin();
// cIter: const T*
vector<T>::const_iter cIter=vec.begin();
```



#### 左值引用和右值引用

- **左值**: 可取地址的

- **右值**:不是左值就是右值，即不可取地址的

  - **纯右值**: 临时变量值，不跟对象关联的字面量值

  - **将亡值**: 将要被移动的对象，T&&类型的函数返回值、std::move返回值

    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

- **左值引用**: 对左值进行引用

- **右值引用**: 对右值进行引用

```cpp
int &a = 2; // 左值引用绑定到右值，编译失败
int b = 2; // b是非常量左值
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过
const int d = 2; // d是常量左值
const int &e = c; // 常量左值引用绑定到常量右值，编译通过
const int &b = 2; // 常量左值引用绑定到右值，编译通过

右值引用通常不能绑定到任何左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
```



#### 内存对齐

```cpp
// 24
// A的内存分布，对齐double(8)：
// [a][b1][b2][b3][b4][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
struct A {
	char a;
	int b;
	double c;
	char d;
};

// 32
/*
A的内存分布，对齐double(8)：
[a][b1][b2][b3][b4][0][0][0] [e1][e2][e3][e4][0][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
*/
struct B {
	char a;
	int b;
    int e;
	double c;
	char d;
};
```



#### 虚函数、虚函数表

https://zhuanlan.zhihu.com/p/75172640



每个包含了虚函数的类都包含了一张虚函数表

当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。



```cpp
// 类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318203825639.png" alt="image-20240318203825639" style="zoom:150%;" />



虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。



> 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205416612.png" alt="image-20240318205416612" style="zoom:150%;" />



**子类的虚表**

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图所示。

![image-20240318205547970](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205547970.png)

`对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数`



```cpp
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

![image-20240318210458446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318210458446.png)



> 什么时候会执行函数的动态绑定？需要符合以下三个条件
>
> 1. 通过指针来调用函数
> 2. 指针upcast向上转型（继承类向基类的转换称为upcast）
> 3. 调用的是虚函数

### 数据结构

#### 红黑树

性质：

1. 节点为红色或黑色
2. NIL节点(叶子节点)为黑色
3. 红色节点的子节点为黑色
4. 从根节点到NIL节点的每条路径上的黑色节点数量相同



#### 共享指针

**共享指针类型：**

1. shared_ptr: 允许多个指针指向同一对象

   强引用计数：用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)

   弱引用计数：用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)

2. unique_ptr: “独占”所指向的对象

3. weak_ptr: 弱引用，指向shared_ptr所管理的对象



**make_shared的优势和劣势：**

通过`new`的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过`make_shared`的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）

```cpp
// new: 分配两次内存(一次分配a的内存，一次分配共享信息内存)，并且会造成内存碎片化
A *a = new A;
shared_ptr<A> pa(a);

// make_shared: 只分配一次内存(内部对象内存、共享信息内存一起分配)，且内部对象和共享信息控制块内存连续
auto p = make_shared<A>(1);
```

![image-20240318174921402](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174921402.png)



![image-20240318174936806](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174936806.png)

```cpp
// shared_ptr

#include <iostream>
using namespace std;

class Count
{
public:
    Count() : count(1) {}

    void increase()
    {
        ++this->count;
    }

    void decrease()
    {
        --this->count;
    }

    int get_count() const
    {
        return this->count;
    }

private:
    // 初始化为0，预防空指针情况
    int count = 0;
};

template <typename T>
class SharedPtr
{
public:
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}
    explicit SharedPtr(T *ptr) : ptr_(ptr), count_(new Count()) {}
    SharedPtr(const SharedPtr<T> &other)
    {
        ptr_ = other.ptr_;
        count_ = other.ptr_;
        count_->increase();
    }

    ~SharedPtr()
    {
        if (this->count_ != nullptr)
        {
            this->count_->decrease();
            if (count_->get_count() == 0)
            {
                delete ptr_;
                delete count_;
                ptr_ = nullptr;
                count_ = nullptr;
            }
        }
    }

    SharedPtr<T> &operator=(const SharedPtr<T> &other)
    {
        if (ptr_ == other.ptr_)
        {
            return *this;
        }
        this->ptr_ = other.ptr_;
        this->count_ = other.count_;
        count_->increase();
    }

    T *get()
    {
        return ptr_;
    }

    T *operator->
    {
        return ptr_;
    }

    T &operator*
    {
        return *ptr_;
    }

    int get_count() const
    {
        if (count_ == nullptr)
            return 0;
        return count_->get_count();
    }

private:
    T *ptr_;
    Count *count_;
};

```



**循环引用问题**

![image-20240318175337344](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318175337344.png)

产生原因详解：

根据代码执行顺序，share_ptr指针指向new创建的一个Person对象，也就是图中栈空间的person指针指向了堆空间的Person对象，引用计数为1，同理，car指针也指向了堆空间的Car对象，引用计数亦为1。

接下来，Person对象里的成员m_car指向Car对象，Car对象的引用计数加1后为2，Car对象的m_person也指向Person对象，Person对象引用计数也加1为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1后为1，后释放person指针，Person对象的引用计数也减为1。由于Person对象和Car对象都是建立再堆空间上，两者相互依赖，都在等待对方释放。

可以看到，这个例子中，堆空间里的 Person对象 与 Car对象互相使用着，导致双方的 shared_ptr 强引用数量不会为0，所以不会自动释放内存，产生了内存泄漏。

```cpp
#include<iostream>
#include<memory>
using namespace std;

class Car;

class Person {
public:
	shared_ptr<Car>m_car = nullptr;
};

class Car {
public:
	shared_ptr<Person>m_person = nullptr;
};

int main() {
	shared_ptr<Person>person(new Person);
	shared_ptr<Car>car(new Car);
	person->m_car = car;
	car->m_person = person;
	person.~shared_ptr();
	car.~shared_ptr();

	cout << person.use_count() << endl; // 1
	cout << car.use_count() << endl;// 1
}
```



解决方案：weak_ptr

![image-20240318180105547](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180105547.png)

![image-20240318180113901](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180113901.png)

根据之前的分析可知，前三句代码执行完后，Person对象的引用计数为1，Car对象的引用计数为2。而第四条语句car->m_person = person执行的便是途中虚线弱引用的语句，不增加Person对象的引用计数。因此，Person对象的引用计数为1，Car对象的引用计数为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1为1，后释放person指针，Person对象的引用计数减1后为0，Person对象释放内存空间，因此m_car成员变量也得到释放，Car对象引用计数减1后为0，Car对象也得到释放。因此不会产生内存泄漏。

### 操作系统

#### 反向映射RMAP

**task_struct、mm_struct、vma关系图：**

![linux源码解析13- 反向映射RAMP详解](https://ctyun-collect-0531.gdoss.xstore.ctyun.cn/files/2023/02/26/acfc619bcd1a42d193f96982024a9e8f.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)





**vma、anon_vma(av)、anon_vma_chain(avc)**

- anon_vma: 连接page和vma的桥梁

  ![linux源码解析13- 反向映射RAMP详解](https://ctyun-collect-0531.gdoss.xstore.ctyun.cn/files/2023/02/26/a87a28673b8042bbbf30c2076bbd6213.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

  ```c
  struct anon_vma { //AV是per VMA的
      struct anon_vma *root; //指向祖宗(root)进程的anon_vma
      struct anon_vma *parent; //指向父进程的anon_vma
      struct rw_semaphore rwsem; /* W: modification, R: walking the list */
      atomic_t refcount; //引用计数
      unsigned degree; //Count of child anon_vmas and VMAs which points to this anon_vma.
      struct rb_root rb_root;	/* Interval tree of private "related" vmas */
  }
  ```
  
- anon_vma_chain: 连接vma和av的枢纽

  avc作用：

  1. 连接`本进程`的vma和av的枢纽
  2. 连接`本进程`的vma和`父进程`的av的枢纽

  ```c
  /* AVC有两种功能：
   * 1、连接本进程的VMA和AV，该种情况下AVC是per VMA的
   * 2、连接父(所有前辈进程)进程的AV与子(孙)进程的VMA，该种情况数量为进程的前辈进程数量
   */
  struct anon_vma_chain {
  	struct vm_area_struct *vma;  //指向VMA
  	struct anon_vma *anon_vma; //指向AV
  	struct list_head same_vma; //把自己挂在VMA->anon_vma_chain链表上
  	struct rb_node rb;			//把自己挂在anon_vma->rb_root红黑树上
  	unsigned long rb_subtree_last;
  };
  ```
  
- vm_area_struct：

  ```c
  struct vm_area_struct {
      struct list_head anon_vma_chain; //VMA和AVC是一对多，把AVC穿成链表
      struct anon_vma *anon_vma; //VMA和AV是一对一的关系
  }
  ```



原因：内存紧张时，需要回收页面，找到准备回收的物理页面（页面回收算法LRU），回收前需要取消VMA对其的映射

1. 如果没有anon_vma，那么页面回收时需要遍历所有进程的vma，浪费时间
2. 如果没有anon_vma_chain，那么在写时复制时，父进程地址空间所映射的物理页面的anon_vma没有及时更新，会保留子进程中的VMA(早已不映射到该物理页面了)，在页面回收时也会做不必要的扫描操作，浪费时间



父进程产生匿名页面时的状态：

![在这里插入图片描述](https://img-blog.csdnimg.cn/c65158e408e14d4191f06aa62b9a878e.jpeg#pic_center)



父进程fork时RMAP机制的流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/9b79e200b11f45dcab2347579c735814.jpeg#pic_center)



#### 程序虚拟内存空间

1. .text(代码段)：

   用于存放程序代码的区域， 编译时确定， 只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

2. .data(数据段):

   用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了`初值(不为0)的全局变量、常量和静态变量`都存放在这个域。

3. .bss：

   bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

   data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。

   data段包含经过初始化的全局变量以及它们的值。

   BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。

4. 堆：

   向高地址伸长

5. 栈：

   向低地址伸长
