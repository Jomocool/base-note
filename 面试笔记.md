## 算法

### 并查集

- 解决连通性问题：

  1. 将两个元素添加到同一个集合中
  2. 判断两个元素是否在同一个集合中

- 关键方法：

  1. join(u,v): 将uv这条边加入并查集
  2. find(u): 寻找u的根节点
  3. init(): 初始化并查集，每个元素的根节点都是自己本身
  4. isSame(u,v): 判断是否有uv边，即u、v是否在同一个集合中

- 优化：

  路径压缩：不做优化的情况下，find可能需要递归好几层才能找到根节点，如果在递归的过程中重新设置每个元素的父节点，都将自己指向父结点的边改为指向原来的根节点，这样就可以把树的高度减为2，大大降低了递归深度

  由

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png" alt="img" style="zoom: 50%;" />

变成

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom: 67%;" />



代码：

```cpp
class UnionSet
{
public:
    UnionSet(int size)
    {
        size_ = size;
        father = vector<int>(size, 0);
        // 初始化，元素都指向自己本身
        for (int i = 0; i < size_; i++)
        {
            father[i] = i;
        }
    }

    // 查找u的根元素并且路径压缩
    int find(int u)
    {
        return u == father[u] ? u : father[u] = find(father[u]);
    }

    // 合并两个元素所在集合
    void join(int u, int v)
    {
        // 找到两个元素的根元素，然后合并两棵树，这样相当于在同一个集合里了
        u = find(u);
        v = find(v);
        // 已经在同一个集合就不需要再次合并了
        if (u == v)
            return;

        father[v] = u;
    }

    // 判断两个元素是否在同一个集合中
    bool isSame(int u, int v)
    {
        // 根元素相同就代表在同一个集合中
        return find(u) == find(v);
    }

private:
    int size_;
    vector<int> father;
};
```







### 排序算法

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序：将大数像泡泡一样冒到最后（稳定）
void bubbleSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            if (vec[j] > vec[j + 1])
            {
                int tmp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = tmp;
            }
        }
    }
}

// 选择排序：选择一个基准值，将其后面最小的值与其交换（不稳定）
void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = vec[i];
        vec[i] = vec[minIndex];
        vec[minIndex] = tmp;
    }
}

// 插入排序：将值插入到前面某个合适的位置
void insertionSort(vector<int>& vec) {
    int n = vec.size();
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        // 后移腾位
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }
}


// 快速排序：选一个基准值，小于它的放左边，大于它的放右边
class QuickSort
{
public:
    QuickSort() {};

    // 快速划分函数
    int partion(vector<int>& vec, int left, int right)
    {
        int pivot = vec[right];
        int index = left;

        // 大于pivot放右边，小于pivot放左边
        for (int i = left; i < right; ++i)
        {
            if (vec[i] < pivot)
            {
                swap(vec[i], vec[index++]);
            }
        }

        // 放置基准值
        swap(vec[right], vec[index]);
        return index;
    }

    // 快速排序
    void quickSort(vector<int>& vec, int left, int right)
    {
        if (left < right)
        {
            int pi = partion(vec, left, right);

            quickSort(vec, left, pi - 1);
            quickSort(vec, pi + 1, right);
        }
    }
};

// 归并排序：合并两个有序子数组
class MergeSort {
public:
    MergeSort() {};

    void merge(vector<int>& vec, int left, int mid, int right) {
        int size1 = mid - left + 1;
        int size2 = right - mid;

        vector<int>left_vec(size1);
        vector<int>right_vec(size2);

        for (int i = 0; i < size1; ++i) {
            left_vec[i] = vec[left + i];
        }
        for (int j = 0; j < size2; ++j) {
            right_vec[j] = vec[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while (i < size1 && j < size2) {
            if (left_vec[i] < right_vec[j]) {
                vec[k++] = left_vec[i++];
            }
            else {
                vec[k++] = right_vec[j++];
            }
        }

        while (i < size1) {
            vec[k++] = left_vec[i++];
        }
        while (j < size2) {
            vec[k++] = right_vec[j++];
        }
    }

    void mergeSort(vector<int>& vec, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(vec, left, mid);
            mergeSort(vec, mid + 1, right);

            merge(vec, left, mid, right);
        }
    }
};




int main()
{
    vector<int> vec{ 2, 1, 5, 4, 7, 6, 0 ,3 };

    // bubbleSort(vec);
    // selectionSort(vec);
    // QuickSort q;
    // q.quickSort(vec, 0, vec.size() - 1);
    // insertionSort(vec);
    MergeSort m;
    m.mergeSort(vec, 0, vec.size() - 1);


    for (auto& num : vec)
    {
        cout << num << " ";
    }
}
```



### 图

**迪杰斯特拉算法：**找某一起点到所有点的最短路径

时间复杂度：O(n^2)

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int INF = INT_MAX;

int main()
{
    int n; // 节点数
    int e; // 边数
    int s; // 起点
    cin >> n >> e >> s;

    // 起点到其它节点的最短路径长
    vector<int> dis(n, INF);
    dis[s] = 0;

    // 确保s到某个节点的路径已是最短
    vector<bool> check(n, false);

    // 图
    vector<vector<int>> graph(n, vector<int>(n, -1));
    for (int i = 0; i < e; i++)
    {
        int start, end, dis;
        cin >> start >> end >> dis;
        graph[start][end] = dis;
    }

    for (int i = 0; i < n; i++)
    {
        int min_dis = INF, min_idx = n;
        for (int j = 0; j < n; j++)
        {
            // 检查check可以避免重复在一个节点打转
            if (dis[j] < min_dis && !check[j])
            {
                min_dis = dis[j];
                min_idx = j;
            }
        }
        check[min_idx] = true;

        for (int k = 0; k < n; k++)
        {
            // 从min_idx节点到k节点距离更短，则更新，前提是min_idx节点和k节点是连通的
            if (graph[min_idx][k] > 0)
            {
                if (min_dis + graph[min_idx][k] < dis[k])
                {
                    dis[k] = min_dis + graph[min_idx][k];
                }
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        cout << dis[i] << " ";
    }
}
```

**最小生成树：**Kruscal算法和Prim算法（无向连通带权图）
prime算法复杂度由顶点数决定，更适合稠密图，而K算法由边数决定，故更适合稀疏图

- Prim算法：每次都选择到下一顶点权最小的边。

  - `Prim算法从一个初始顶点开始`，然后逐步扩展生成树，每次选择连接生成树和未加入生成树的顶点的权重最小的边。具体步骤如下：
    - 选择一个起始顶点作为生成树的根节点。
    - 将该节点标记为已访问，并将其与之相邻的所有边加入到优先队列中。
    - 从优先队列中选择权重最小的边，如果其连接的节点未被访问，则将该节点加入生成树，并将与该节点相邻的边加入优先队列中。
    - 重复以上步骤，直到所有节点都被访问过，生成树构建完成。
  - Prim算法的时间复杂度通常为 O(V^2) 或 O(E*logV)，其中V是顶点数，E是边数。

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  class Edge
  {
  public:
      Edge(int _to, int _weight) : to(_to), weight(_weight) {}
  
      int to;
      int weight;
  };
  
  int prim(const vector<vector<Edge>> &graph)
  {
      int minCost = 0;
      int n = graph.size();
      // 已访问节点为true
      vector<bool> visited(n, false);
      // 存放着所有已连接树 连接 未连接树的信息(权重，终点)
      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
  
      // 起始节点为0
      pq.push({0, 0});
  
      while (!pq.empty())
      {
          int w = pq.top().first;
          int u = pq.top().second;
          pq.pop();
  
          if (visited[u])
              continue;
  
          visited[u] = true;
          minCost += w;
  
          for (const Edge &edge : graph[u])
          {
              if (!visited[edge.to])
              {
                  pq.push({edge.weight, edge.to});
              }
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
      vector<vector<Edge>> graph(n);
  
      for (int i = 0; i < e; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          graph[u].emplace_back(Edge(v, w));
          graph[v].emplace_back(Edge(u, w));
      }
  
      cout << prim(graph);
  }
  ```

  

- Kruskal算法：每次都选择权最小的可以连通两个不同连通分支的边

  `边排序(权重从小到大) + 并查集`

  步骤：

  1. 边排序后，遍历边
  2. 如果边的两个顶点没加到并查集中，代表未连接，加入并查集、

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  
  struct Edge
  {
      int u;
      int v;
      int weight;
  };
  
  bool compare(Edge a, Edge b)
  {
      return a.weight < b.weight;
  }
  
  class Union
  {
  public:
      Union(int n)
      {
          parent.resize(n);
          rank.assign(n, 0);
          for (int i = 0; i < n; i++)
          {
              parent[i] = i;
          }
      }
  
      int find(int u)
      {
          if (u == parent[u])
              return u;
          parent[u] = find(parent[u]);
          return parent[u];
      }
  
      void join(int u, int v)
      {
          u = find(u);
          v = find(v);
          if (rank[u] < rank[v])
          {
              parent[u] = v;
          }
          else if (rank[u] > rank[v])
          {
              parent[v] = u;
          }
          else
          {
              parent[v] = u;
              rank[u]++; // 高度增加了
          }
      }
  
      bool is_connect(int u, int v)
      {
          return find(u) == find(v);
      }
  
      vector<int> parent;
      vector<int> rank; // 用于判断树的高度，将高度低的树加到高度高的树上可以减少整个树的高度
  };
  
  /// @brief 生成最小树
  /// @param edges 所有边
  /// @param n 节点数
  /// @return 最小权重
  int kruskal(vector<Edge> &edges, int n)
  {
      int minCost = 0;
      Union uf(n);
  
      sort(edges.begin(), edges.end(), compare);
  
      for (auto &e : edges)
      {
          if (!uf.is_connect(e.u, e.v))
          {
              uf.join(e.u, e.v);
              minCost += e.weight;
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
  
      vector<Edge> edges(e);
  
      for (int i = 0; i < e; i++)
      {
          cin >> edges[i].u >> edges[i].v >> edges[i].weight;
      }
  
      cout << kruskal(edges, n);
  }
  ```




### [旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 1.转置
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = i + 1; j < matrix[i].size(); ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // 2.反转数组
        for (int i = 0; i < n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```



### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n=matrix.size();
        int m=matrix[0].size();

        pair<int,int>left_up(0,0);
        pair<int,int>right_down(n-1,m-1);

        while(left_up.first<=right_down.first&&left_up.second<=right_down.second){
            int up=left_up.first;
            int left=left_up.second;
            int down=right_down.first;
            int right=right_down.second;

            // 只剩一行
            if (up==down){
                for(int j=left;j<=right;j++){
                    res.emplace_back(matrix[up][j]);
                }
                break;
            }

            // 只剩一列
            if (left==right){
                for(int i=up;i<=down;i++){
                    res.emplace_back(matrix[i][left]);
                }
                break;
            }

            for(int j=left;j<right;j++){
                res.emplace_back(matrix[up][j]);
            }
            for(int i=up;i<down;i++){
                res.emplace_back(matrix[i][right]);
            }
            for(int j=right;j>left;j--){
                res.emplace_back(matrix[down][j]);
            }
            for(int i=down;i>up;i--){
                res.emplace_back(matrix[i][left]);
            }

            left_up.first+=1;
            left_up.second+=1;
            right_down.first-=1;
            right_down.second-=1;
        }

        return res;
    }
};
```



### [打乱数组](https://leetcode.cn/problems/shuffle-an-array/)

![image-20240321112356263](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321112356263.png)

```cpp
class Solution {
public:
    Solution(vector<int>& nums) { this->nums = nums; }

    vector<int> reset() { return this->nums; }

    vector<int> shuffle() {
        vector<int> res = nums;
        int n = nums.size();

        for (int i = 0; i < n; ++i) {
            swap(res[i], res[i + rand() % (n - i)]);
        }
        
        return res;
    }

private:
    vector<int> nums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```



### [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

思路：

- 双向链表：最近访问的元素放在链表头，最长时间没访问的元素在链表尾，由于查找、放置和删除节点时只会对头尾节点做操作，因此可以加一对虚拟头尾节点管理
- 整体维护一张哈希表，键值是key，value值是双向链表中的节点
- get(): 查找哈希表中有无对应键值，有则返回对应元素，并把该元素移到头节点，没有则返回-1
- put(): 查找有无对应键值，有则更新value值即可，并移到头节点。没有就需要添加，先判断LRU缓存是否已满，如果没满则添加到链表头，满了的话删掉尾节点然后再加到链表头

```cpp
struct DoubleLinkedNode {
    int key, value;
    DoubleLinkedNode* prev;
    DoubleLinkedNode* next;

    DoubleLinkedNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {}
    DoubleLinkedNode(int key, int val)
        : key(key), value(val), prev(nullptr), next(nullptr) {}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        dummy_head = new DoubleLinkedNode();
        dummy_tail = new DoubleLinkedNode();
        dummy_head->next = dummy_tail;
        dummy_tail->prev = dummy_head;
        size = 0;
        this->capacity = capacity;
    }

    int get(int key) {
        // 如果不存在，返回-1
        if (link_map.count(key) == 0)
            return -1;

        DoubleLinkedNode* key_node = link_map[key];
        // 更新访问时间
        moveToHead(key_node);
        return key_node->value;
    }

    void put(int key, int value) {
        // 如果存在，更新值，并更新时间
        if (link_map.count(key) != 0) {
            DoubleLinkedNode* key_node = link_map[key];
            key_node->value = value;
            moveToHead(key_node);
            // 及时返回，否则出了if还会继续执行，不符合逻辑
            return;
        }

        // 如果不存在
        // 先判断是否还有空间
        if (size == capacity) {
            // 空间已满
            // 删除链表尾(最久未被访问的元素)
            DoubleLinkedNode* tail_node = dummy_tail->prev;
            removeNode(tail_node);
            // 从link_map中删去key值
            link_map.erase(tail_node->key);
            // 更新元素个数
            --size;
        }

        // 空间充足
        // 初始化节点
        DoubleLinkedNode* new_node = new DoubleLinkedNode(key, value);
        // 加入到链表头
        addToHead(new_node);
        // 加入到link_map
        link_map[key] = new_node;
        // 更新元素个数
        ++size;
    }

    // 将节点加入链表头，用于put新添节点时
    void addToHead(DoubleLinkedNode* node) {
        DoubleLinkedNode* head_next = dummy_head->next;
        dummy_head->next = node;
        node->prev = dummy_head;
        head_next->prev = node;
        node->next = head_next;
    }

    // 移除节点，不止链表尾，因为还有将中间节点移出链表再添加到链表头的情况
    void removeNode(DoubleLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        node->prev = nullptr;
        node->next = nullptr;
    }

    // 将链表中的节点移动到链表头，满足更新key值对应value，和访问key时的情况
    void moveToHead(DoubleLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

private:
    unordered_map<int, DoubleLinkedNode*> link_map;
    DoubleLinkedNode* dummy_head;
    DoubleLinkedNode* dummy_tail;
    int size;
    int capacity;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### [三数之和](https://leetcode.cn/problems/3sum/)

思路：

排序数组后，定义双指针，由于数组是有序的，因此双指针的移动也是有规律的，假设当前和小于0，那么就让左指针往右移(nums[left]<=nums[left+1])，否则就让右指针左移(nums[right]>=nums[right-1])

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for (int i = 0; i < n - 2; ++i) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 去重
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return res;
    }
};
```



### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

思路：

由于连在一起的陆地算一块岛屿，因此遍历二维数组时，碰到一块陆地就将其所在岛屿的所有陆地沉下去（dfs），防止重复计算

```cpp
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 越界或者陆地不连续就停止
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() ||
            grid[i][j] == '0')
            return;

        // 沉下去
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }

    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int n = grid.size(), m = grid[0].size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }

        return res;
    }
};
```



### [数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

思路：

维护小顶堆A和大顶堆B，各维护一半元素，小顶堆A维护值较大的那一半（），大顶堆B维护值较小的那一半

![image-20240321213513781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321213513781.png)

```cpp
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        int m=A.size();
        int n=B.size();

        // num需要和A、B中的元素都比较之后才知道应该放在哪
        // A、B元素个数相同，加入A
        if(m==n){
            // num有可能属于较小的那一半，因此先加入B，再将B的堆顶元素加入A
            B.push(num);
            A.push(B.top());
            B.pop();
        }else{// m=n+1
            // num有可能属于较大的那一半，因此先加入A，再将A的堆顶元素加入B
            A.push(num);
            B.push(A.top());
            A.pop();
        }
    }

    double findMedian() {
        int m=A.size();
        int n=B.size();

        if(m==n){
            return (A.top()+B.top())/2.0;
        }

        return A.top();
    }

private:
    // A维护较大的一半元素，且元素个数大于等于B
    priority_queue<int, vector<int>, greater<int>> A;
    // B维护较小的一半元素，且元素个数小于等于A
    priority_queue<int, vector<int>, less<int>> B;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



### [二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```cpp
方法一：层序遍历（空节点也算）

方法二：dfs
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, unsigned long long> depth_first;
    unsigned long long res;

    // 先序遍历保证第一次加入哈希表的都是每层的最左节点
    void dfs(TreeNode* node, unsigned long long i, int depth) {
        if (!node)
            return;
        if (depth_first.count(depth) == 0)
            depth_first[depth] = i;
        res = max(res, i - depth_first[depth] + 1);
        dfs(node->left, 2 * i, depth + 1);
        dfs(node->right, 2 * i + 1, depth + 1);
    }

    int widthOfBinaryTree(TreeNode* root) {
        res = 0;
        dfs(root, 1, 0);
        return res;
    }
};
```



### [ 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

思路：

树形递归（回溯）

```cpp
class Solution {
public:
    vector<string> res;
    vector<int> path;

    void dfs(string& s, int start, int ip_idx) {
        // s刚好分为4个值
        if (ip_idx == 4 && start == s.size()) {
            string ip=to_string(path[0]);
            for(int i=1;i<path.size();++i){
                ip+="."+to_string(path[i]);
            }
            res.emplace_back(ip);
        }

        for (int i = start, num = 0; i < s.size(); ++i) {
            num = num * 10 + s[i] - '0';
            if (num > 255) // 剪枝
                break;
            path.emplace_back(num);
            dfs(s, i + 1, ip_idx + 1);
            path.pop_back();
            if(num==0)break; // 从0起始只有一种情况有效，就是num=0，x.0.y，处理完这种情况后就可以break了
        }
    }

    vector<string> restoreIpAddresses(string s) {
        dfs(s, 0, 0);
        return res;
    }
};
```



### [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

思路：

KMP

next数组: next[i]存放的是匹配串的子串[0,i]的最长公共前后缀长度

```cpp
class Solution {
public:
    vector<int> next(string& needle) {
        int n = needle.size();
        if (n <= 1) {
            return {-1};
        }

        // next[i]: needle[0,i-1]子串的最长公共前后缀长度
        // 不需要知道needle[0,n-1]即整个字符串的最长公共前后缀长度，因为此时都匹配完了
        vector<int> next(n, 0);
        // 规则：
        next[0] = -1;
        next[1] = 0;
        int i = 2;
        int j = 0;
        while (i < n) {
            if (needle[i - 1] == needle[j]) {
                /*
                next[i]=j+1;
                ++i;
                j=next[i-1];
                */
                next[i++] = ++j;
            } else if (j > 0) {
                j = next[j];
            } else {
                next[i++] = 0;
            }
        }

        return next;
    }

    int strStr(string haystack, string needle) {
        int n = needle.size();
        vector<int> next_vec = next(needle);

        int i = 0;
        int j = 0;

        while (i < haystack.size()) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
                if (j == n)
                    break;
            } else if (j > 0) {
                j = next_vec[j];
            } else {
                ++i;
            }
        }

        return j == n ? i - n : -1;
    }
};
```



### [反转链表](https://leetcode.cn/problems/UHnkqh/)

```cpp
方法一：迭代，哨兵节点（虚拟头、尾节点）

方法二：递归
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* node) {
        // 最后一个节点无需反转
        if (!node->next){
            return node;
        }
        
        ListNode* res=reverse(node->next);
        node->next->next=node;
        node->next=nullptr;

        // res一直是最后一个节点，即反转后的链表头
        return res;
    }

    ListNode* reverseList(ListNode* head) {
        if(!head)return head;
        return reverse(head);
    }
};
```

### [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```cpp
class MyQueue {
public:
    MyQueue() {}

    void push(int x) { push_stk.push(x); }

    int pop() {
        // 如果pop_stk是空，则把push_stk的数据加入pop_stk(刚好反转了顺序)
        // 如果pop_stk不为空，则不能把push_stk的数据加入pop_stk，这样会打乱了顺序
        if (pop_stk.empty()) {
            while (!push_stk.empty()) {
                pop_stk.push(push_stk.top());
                push_stk.pop();
            }
        }

        int res = pop_stk.top();
        pop_stk.pop();
        return res;
    }

    int peek() {
        if (pop_stk.empty()) {
            while (!push_stk.empty()) {
                pop_stk.push(push_stk.top());
                push_stk.pop();
            }
        }

        return pop_stk.top();
    }

    bool empty() { return push_stk.empty() && pop_stk.empty(); }

private:
    stack<int> push_stk;
    stack<int> pop_stk;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

思路：

一个队列存数据，另一个队列是空，此时如果是pop操作，就把除了队列为的数据存放到空队列中，然后再把队列尾pop出来即可。如果是push操作，那么直接加入到不为空的那个队列即可。peek相比于pop只是把队列尾移出队列变成把队列尾继续加入到另一个队列中

```cpp
class MyStack {
public:
    MyStack() {}

    void push(int x) { que1.empty() ? que2.push(x) : que1.push(x); }

    int pop() {
        int res = 0;
        if (!que1.empty()) {
            while (que1.size() > 1) {
                que2.push(que1.front());
                que1.pop();
            }
            res = que1.front();
            que1.pop();
        } else {
            while (que2.size() > 1) {
                que1.push(que2.front());
                que2.pop();
            }
            res = que2.front();
            que2.pop();
        }
        return res;
    }

    int top() {
        int res = 0;
        if (!que1.empty()) {
            while (que1.size() > 1) {
                que2.push(que1.front());
                que1.pop();
            }
            res = que1.front();
            que1.pop();
            que2.push(res);
        } else {
            while (que2.size() > 1) {
                que1.push(que2.front());
                que2.pop();
            }
            res = que2.front();
            que2.pop();
            que1.push(res);
        }
        return res;
    }

    bool empty() { return que1.empty() && que2.empty(); }

private:
    queue<int> que1;
    queue<int> que2;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### [堆内存申请](https://mp.weixin.qq.com/s/1LwA3HRO-8ygR_cHx1Ha1Q)

![image-20240323211134845](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240323211134845.png)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 100;

struct AllocatedInterval
{
    AllocatedInterval(int start_, int end_) : start(start_), end(end_) {}
    int start;
    int end;
};

// 想让自定义对象在vector中排序，尽可能将自定义对象用struct声明
static bool compare(const AllocatedInterval &a1, const AllocatedInterval &a2)
{
    if (a1.start < a2.start)
        return true;
    return a1.start == a2.start ? a1.end < a2.end : false;
}

int main()
{
    vector<AllocatedInterval> intervals;

    // 申请内存大小
    int size = 0;
    cin >> size;

    int start, offset;
    while (cin >> start)
    {
        cin >> offset;
        intervals.emplace_back(AllocatedInterval(start, start + offset - 1));
    }
    // 因为我们是要遍历空闲内存空间，所以增加两个哨兵区间[-1,-1]和[N,N]
    // 这样就可以遍历到第一块已被分配内存空间的前面的空闲空间，以及最后一块已被分配内存空间后面的空闲空间
    intervals.emplace_back(AllocatedInterval(-1, -1));
    intervals.emplace_back(AllocatedInterval(N, N));
    // 排序
    sort(intervals.begin(), intervals.end(), compare);

    // 查找有无重叠区域
    int n = intervals.size();
    for (int i = 0; i < n - 1; ++i)
    {
        if (intervals[i].end >= intervals[i + 1].start)
        {
            // 有重叠区域，无效
            cout << -1 << endl;
        }
    }

    // 查找最合适的区域
    int min_size = INT_MAX;
    int idx = -1;
    for (int i = 1; i < n; ++i)
    {
        // 空闲空间大小
        int free_size = intervals[i].start - intervals[i - 1].end - 1;
        if (free_size >= size && free_size < min_size)
        {
            min_size = free_size;
            idx = intervals[i - 1].end + 1;
        }
    }

    cout << idx << endl;
}
```

### [字典树(前缀树)](https://www.luogu.com.cn/problem/P8306)

**前缀树的3个基本性质：**

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// 前缀树节点
struct TrieNode
{
    TrieNode() : count(0), prefix(0) {}
    int count;  // 以当前字符结尾的单词数量
    int prefix; // 以当前节点之前的字符串为前缀的单词数量
    unordered_map<int, TrieNode *> next;
};

// 前缀树
class TrieTree
{
public:
    TrieTree() : root(new TrieNode()) {}

    void insert(string &word)
    {
        TrieNode *node = root;
        for (char &c : word)
        {
            if (!node->next[c - 'a'])
            {
                node->next[c - 'a'] = new TrieNode();
            }
            node = node->next[c - 'a'];
            node->prefix++;
        }

        node->count++;
    }

    // 查找字典树中有多少个单词是以word为前缀(可以等于word)
    int search(string &word)
    {
        TrieNode *node = root;

        for (char &c : word)
        {
            if (!node->next[c - 'a'])
                return 0;
            node = node->next[c - 'a'];
        }

        return node->prefix;
    }

private:
    TrieNode *root;
};

int main()
{
    int t, n, q;
    cin >> t >> n >> q;

    TrieTree trie_tree;
    string word;
    for (int k = 0; k < t; ++k)
    {
        for (int i = 0; i < n; ++i)
        {
            cin >> word;
            trie_tree.insert(word);
        }

        for (int i = 0; i < q; ++i)
        {
            cin >> word;
            cout << trie_tree.search(word) << endl;
        }
    }

    return 0;
}
```



### [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

思路：动态规划

由于负负得正，因此不仅得记录当前最大乘积，同时也得记录最小乘积

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // minDp[i]: 以nums[i]结尾的子数组最小乘积
        vector<int> minDp(n, 0);
        // maxDp[i]: 以nums[i]结尾的子数组最大乘积
        vector<int> maxDp(n, 0);

        minDp[0] = maxDp[0] = nums[0];
        for (int i = 1; i < n; ++i) {
            minDp[i] = min(nums[i],
                           min(nums[i] * minDp[i - 1], nums[i] * maxDp[i - 1]));
            maxDp[i] = max(nums[i],
                           max(nums[i] * maxDp[i - 1], nums[i] * minDp[i - 1]));
        }

        return *max_element(maxDp.begin(), maxDp.end());
    }
};
```

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

“下一个排列” 的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。



思路：

将低位的尽可能小的`大数`和前面的`小数`交换，然后使后面的数字升序。

`寻找小数：`从右往左扫描数组，找到第一个nums[i]<nums[i+1]的下标i，nums[i]就是`小数`，下标i+1及其后面的元素中满足大于nums[i]的元素中的最小值就是`大数`，然后再让nums[i+1,,n]升序

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        // 原数组是降序数列，已经是最大了，返回最小序列
        if (i < 0) {
            sort(nums.begin(), nums.end());
            return;
        }

        // 此时nums[i]就是小数
        // 找到尽可能小的大数
        int j = n - 1;
        // min_big_idx初始化要选择一个肯定大于nums[i]的值对应下标，不然会出现选了个nums[i+1,n-1]中的最小
        // 值，导致无法正确更新min_big_idx
        int min_big_idx = i + 1;
        while (j > i) {
            if (nums[j] > nums[i] && nums[j] < nums[min_big_idx]) {
                min_big_idx = j;
            }
            --j;
        }

        // 交换大小数
        swap(nums[i], nums[min_big_idx]);

        // 让nums[i+1,n-1]升序，使其最小
        sort(nums.begin() + i + 1, nums.end());
    }
};
```



### 小于n的最大值

**题目要求：**给定一个数组arr=[2,3,4,5],N=2345,求使用arr中的数字，组成一个不大于N的最大的数字。arr中的数字可以多次使用。

思路：回溯+贪心

从高位开始遍历，对每一位先尝试使用相同数字，除了最后一位。如果没有相同的数字时，尝试是否有比当前数字更小的，有的话选更小的数字里最大的，剩下的用最大数字。都没有就向前回溯看前一个有没有更小的。如果一直回溯到第一个数字都没有更小的数字，就用位数更少的全都是最大数字的数。





### 二叉树先、中、后序遍历（迭代）

**先序遍历：**

```cpp
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;

    if (!root)
        return res;

    stack<TreeNode*> stk;
    stk.push(root);

    // 遍历顺序：中左右
    while (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        res.emplace_back(node->val);
        // 先加入右节点，再加入左节点，这样出栈的顺序才是先左后右
        if(node->right)stk.emplace(node->right);
        if(node->left)stk.emplace(node->left);
    }

    return res;
}
```



**中序遍历**

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    if (!root)
        return res;

    stack<TreeNode*> stk;
    TreeNode* cur = root;

    // 遍历顺序：左中右
    // 先遍历到最左节点，然后开始处理节点
    while (cur || !stk.empty()) {
        if (cur) {
            stk.push(cur);
            cur = cur->left;
        }else{
            cur=stk.top();
            stk.pop();
            res.emplace_back(cur->val);
            cur=cur->right;
        }
    }

    return res;
}
```



**后序遍历**

![image-20240324201601573](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240324201601573.png)

```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    if (!root)
        return res;

    stack<TreeNode*> stk;
    stk.push(root);

    // 后序遍历顺序：左右中
    // 先序遍历顺序是：中左右
    // 切换左右子节点入栈顺序后 -> 中右左
    // 反转数组 -> 左右中，就变成后序顺序了
    while(!stk.empty()){
        TreeNode*node=stk.top();
        stk.pop();
        res.emplace_back(node->val);
        if(node->left)stk.emplace(node->left);
        if(node->right)stk.emplace(node->right);
    }

    reverse(res.begin(),res.end());
    return res;
}
```



**总结：**

先序遍历是最简单的，因为处理节点的顺序和遍历节点的顺序一致。

中序遍历需要先遍历到最左节点，然后将值加入结果数组，再去查看其右子树。

后序遍历和先序遍历的顺序部分一致，因此可以通过修改先序遍历中左右子节点的入栈顺序使得结果数组的顺序是中右左，再将其反转后就变成了左右中，也就是后序遍历顺序了

`先序最简单、中序独有处理逻辑、后序靠先序`





### [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

思路：BFS（队列）

**所谓广度优先搜索，就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，最后广度优先搜索找到的路径就是从起点开始的最短合法路径**。



`上下左右相邻的新鲜橘子就是该腐烂橘子尝试访问的同一层的节点，路径长度就是新鲜橘子被腐烂的时间`

```cpp
class Solution {
public:
    int cnt;                 // 当前新鲜橘子数量
    vector<vector<int>> dis; // 当前橘子被污染的时间
    vector<int> dir_x{0, 0, -1, 1};
    vector<int> dir_y{-1, 1, 0, 0};

    int orangesRotting(vector<vector<int>>& grid) {
        dis.resize(10, vector<int>(10, -1));
        queue<pair<int, int>> que;
        int n = grid.size(), m = grid[0].size();
        int ans = 0;

        // 把初始腐烂的橘子(第一层)加到队列中并初始化腐烂时间和记录新鲜橘子数量
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 2) {
                    dis[i][j] = 0;
                    que.push({i, j});
                } else if (grid[i][j] == 1) {
                    cnt++;
                }
            }
        }

        // 一层一层遍历，相当于将队列中的腐烂橘子向外扩
        while (!que.empty()) {
            auto rotted = que.front();
            que.pop();
            int x = rotted.second;
            int y = rotted.first;
            for (int i = 0; i < 4; i++) {
                int tx = x + dir_x[i];
                int ty = y + dir_y[i];
                // 判断是否越界、空格单元、已腐烂
                if (tx < 0 || tx >= m || ty < 0 || ty >= n ||
                    grid[ty][tx] == 0 || dis[ty][tx] != -1)
                    continue;

                // 腐烂橘子然后加入到队列中
                cnt--;
                dis[ty][tx] = dis[y][x] + 1;
                ans = dis[ty][tx];
                que.push({ty, tx});
            }
        }

        return cnt ? -1 : ans;
    }
};
```



### [课程表](https://leetcode.cn/problems/course-schedule/)

思路：拓扑序列BFS（队列）

判断是否为有向无环图，有环就不可能完成所有课程
将入度为0的节点加入队列中，消除它们的出边，消除后如果终点入度变为0，就继续加入队列，最后判断所有加入过队列的节点总和是否等于课程数

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // edges[i][j]: i的前置课是j，i是终点，j是起点
        vector<vector<int>> edges(numCourses, vector<int>());
        // indeg[i]: i课的入度
        vector<int> indeg(numCourses, 0);

        for (int i = 0; i < prerequisites.size(); i++) {
            edges[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
            ++indeg[prerequisites[i][0]];
        }

        queue<int> que;
        int visited = 0;
        for (int i = 0; i < indeg.size(); i++) {
            if (indeg[i] == 0) {
                que.push(i);
                visited++;
            }
        }

        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            for (int i = 0; i < edges[cur].size(); i++) {
                if (--indeg[edges[cur][i]] == 0) {
                    que.push(edges[cur][i]);
                    visited++;
                }
            }
        }

        return visited == numCourses;
    }
};
```



## C++

下面这段代码会在编译时，因为调用show函数时，会调用A的拷贝构造函数，而A的拷贝构造函数是私有的无法访问到，因此报错

```cpp
#include <iostream>
using namespace std;
class A
{
    A(const A &) {}

public:
    int num;
    A() { num = 5; }
};
void show(A a)
{
    cout << a.num << endl;
}

int main()
{
    A a;
    show(a);
    return 0;
}
```

### 底层const、顶层const

```cpp
// iter: T* const
vector<T>::iterator iter = vec.begin();
// cIter: const T*
vector<T>::const_iter cIter=vec.begin();
```



### 左值引用和右值引用

![image-20240320151340925](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151340925.png)

![image-20240320151612193](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151612193.png)

- **左值**: 可取地址的

- **右值**:不是左值就是右值，即不可取地址的

  - **纯右值**: 纯粹的临时值（即使指代的对象是持久存在的），不跟对象关联的字面量值

  - **将亡值**: 一般是指类型为右值引用类型的返还值，T&&类型的函数返回值、std::move返回值

    `std::move`实现方式和`std::forward`类似，也是通过完美引用和强制类型转换
    
    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

- **左值引用**: 对左值进行引用

- **右值引用**: 对右值进行引用

```cpp
int &a = 2; // 左值引用绑定到右值，编译失败
int b = 2; // b是非常量左值
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过
const int d = 2; // d是常量左值
const int &e = c; // 常量左值引用绑定到常量右值，编译通过
const int &b = 2; // 常量左值引用绑定到右值，编译通过

右值引用通常不能绑定到任何左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
```



### 内存对齐

`内存对齐规则：类成员变量的起始地址偏移量必须是其大小的整数倍`

```cpp
// 24
// A的内存分布，对齐double(8)：
// [a][b1][b2][b3][b4][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
struct A {
	char a;
	int b;
	double c;
	char d;
};

// 32
/*
A的内存分布，对齐double(8)：
[a][b1][b2][b3][b4][0][0][0] [e1][e2][e3][e4][0][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
*/
struct B {
	char a;
	int b;
    int e;
	double c;
	char d;
};
```

> 为什么需要内存对齐？

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

  假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。
  现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。





### 纯虚函数、虚函数、虚函数表

https://zhuanlan.zhihu.com/p/75172640

https://zhuanlan.zhihu.com/p/270614081





**纯虚函数**

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，继承该类的派生类必须实现该函数



何时使用纯虚函数：

（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

（2）这个方法必须在派生类(derived class)中被实现；

  如果满足以上两点，可以考虑将该方法申明为纯虚函数.

`一个类如果有纯虚函数，那么它就是抽象类，不能被实例化`



**虚函数、虚函数表**

虚函数：被virtual修饰的类成员函数

每个包含了虚函数的类都包含了一张虚函数表

当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。



```cpp
// 类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318203825639.png" alt="image-20240318203825639" style="zoom:150%;" />



虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。



> 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205416612.png" alt="image-20240318205416612" style="zoom:150%;" />



**子类的虚表**

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图所示。

![image-20240318205547970](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205547970.png)

`对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数`



```cpp
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

![image-20240318210458446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318210458446.png)





示例代码：

```cpp
#include<iostream>
using namespace std;

class Base {
public:
	Base(){}
	virtual ~Base(){}
	virtual void func() {
		cout << "base func" << endl;
	}
};

class Derived :public Base {
public:
	Derived(){}
	virtual ~Derived(){}
	virtual void func() {
		cout << "derived func" << endl;
	}
	virtual void func2() {};
};

int main() {}
```



`Derived类内存分布`

一个对象所占内存是其所有成员属性所占内存的总和内存对齐后的大小，如果有虚函数的话还要在加上虚函数表指针

一个派生类所占内存包括它所有的基类大小加上它自己的成员属性的总和内存对齐后的大小，如果如果有虚函数的话还要再加上虚函数表指针

```
1>class Base	size(8):
1>	+---
1> 0	| {vfptr}
1>	+---
1>Base::$vftable@:
1>	| &Base_meta
1>	|  0
1> 0	| &Base::{dtor}
1> 1	| &Base::func

===================================================================================================================

1>class Derived	size(8):
1>	+---
1> 0	| +--- (base class Base)
1> 0	| | {vfptr}
1>	| +---
1>	+---
1>Derived::$vftable@:
1>	| &Derived_meta
1>	|  0
1> 0	| &Derived::{dtor}
1> 1	| &Derived::func
1> 2	| &Derived::func2
```

`派生类是从基类继承的虚函数表，就像继承其它成员属性一样，派生类不会再自己生成一张虚函数表，而对于派生类的虚函数，会在虚函数表中对应位置修改或添加虚函数指针，但虚函数是派生类独有(基类没有)时，会添加到该虚函数表中`

### extern

如果想在多个文件之间共享const变量，必须在变量的定义前加上extern关键字



### const限定符

![image-20240319210655314](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240319210655314.png)





### 无符号与有符号的比较

![image-20240320134747641](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320134747641.png)



### 字符串相加

![image-20240320135448633](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135448633.png)

![image-20240320135506201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135506201.png)



### 迭代器

vector的rbegin()方法会返回一个反向迭代器指向最后一个元素，该迭代器执行++操作会往前面移动一个元素

it->func() = (*it).func()



### 数组

![image-20240320144822974](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320144822974.png)



![image-20240320145742474](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320145742474.png)



![image-20240320150054220](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320150054220.png)





### 显示转换

- static_cast

  ![image-20240320152952804](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320152952804.png)

- const_cast

  ![image-20240320153131766](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153131766.png)

- reinterpret_cast

  ![image-20240320153225174](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153225174.png)

- dynamic_cast

  `dynamic_cast`是四个强制类型转换操作符中最特殊的一个，因为它支持`运行时`识别指针和引用。用于`类继承层次间的指针或引用转换`主要用于**安全的向下转型**，至于向上转型本身就是安全的，因此没必要使用dynamic_cast

```cpp
#include <iostream>
using namespace std;

class MyClass
{
public:
    void foo() { cout << "Non-const foo" << endl; }
    void foo() const { cout << "Const foo" << endl; }
};

int main()
{
    int i, j;

    // static_cast
    double slope = static_cast<double>(j) / i;
    void *p = nullptr;
    double *dp = static_cast<double *>(p);

    // const_cast
    const MyClass obj;
    obj.foo();                        // 调用const版本的foo
    const_cast<MyClass &>(obj).foo(); // 通过const_cast调用非const版本的foo

    // reinterpret_cast
    int *ip;
    char *pc = reinterpret_cast<char *>(ip);

    return 0;
}
```



### try语句块和异常处理

![image-20240320161334919](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320161334919.png)



![image-20240320181841608](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320181841608.png)



**寻找异常的处理代码过程**

![image-20240320182252095](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320182252095.png)





### 万能引用、引用折叠、完美转发

**万能引用**

```cpp
void foo(int &&i){}; // i为右值引用

template <typename T>
void bar(T &&t) {} // t为万能引用

constexpr int get_val() { return 5; }
int &&x = get_val(); // x为右值引用
auto &&y = get_val(); // y为万能引用
```

右值引用只能绑定一个右值，而万能引用既能绑定左值，也能绑定右值



**引用折叠**

所谓的完能引用实际上是发生了类型推导，在这个推导的过程中，如果初始化的源对象是一个左值，则目标对象会推导出一个左值引用，反之如果源对象是一右值，则会推导出一个左值引用



引用折叠：C++11添加的一套引用叠加推导规则

有一个左值引用，那么最终类型就是左值引用（遇左则左）

![image-20240322190230326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322190230326.png)





万能引用+引用折叠用于实现完美转发，完美转发避免了额外的拷贝

一般来说，传个引用就可以避免拷贝了，但是由于引用是左值引用，所以当传入右值时就不行了。因此完美转发就实现了可以同时处理左值和右值



**完美转发**

示例代码：

```cpp
template<typename T>
void print(T & t){
    std::cout << "Lvalue ref" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "Rvalue ref" << std::endl;
}

template<typename T>
void testForward(T && v){
    //虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！
    print(v); //永远调用左值版本的print
    
    print(std::forward<T>(v)); //底层实际上就是static_cast<T&&>(v)
    
    print(std::move(v)); //永远调用右值版本的print

    std::cout << "======================" << std::endl;
}

int main(int argc, char * argv[])
{
    int x = 1;
    testForward(x); //实参为左值
    testForward(std::move(x)); //实参为右值
}
```

运行结果：

> ```text
> Lvalue ref
> Lvalue ref
> Rvalue ref
> /======================
> Lvalue ref
> Rvalue ref
> Rvalue ref
> /======================
> ```



本质问题在于无论是左值、右值在当作函数参数传递时，函数的参数在被使用时都会被当作左值，因为该参数在内存中已经有了位置


在STL中随处可见这种问题，C++11引入的emplace_back，它接受左值也接受右值作为参数，接着，它转调用construct函数，而construct函数转调用placement new，placement new根据传入的参数是左值还是右值再决定调用拷贝构造函数还是移动构造函数



`std::forward`实现如下：

```cpp
template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}
```





### emplace_back和push_back

```cpp
#include <iostream>
#include <vector>
using namespace std;

class A
{
public:
    A() = default;
    A(const A &rhs)
    {
        cout << "copy constructor" << endl;
    }
    A(A &&rhs)
    {
        cout << "move constructor" << endl;
    }
};

int main(int argc, char *argv[])
{
    vector<A> vec;
    vec.reserve(20);
    A temp;
	
    // 虽然temp2是右值引用，但它实际上是一个左值
    A &&temp2 = move(temp);
    cout << &temp2 << "\n"
         << &temp << endl;

    // 调用的构造函数，调用的vector的方法
    vec.push_back(temp);               // copy , push_back(const value_type& __x)
    vec.push_back(std::move(temp));    // move , push_back(value_type&& __x)
    vec.push_back(A());                // move , push_back(value_type&& __x)
    vec.emplace_back(temp);            // copy , emplace_back(_Args&&... __args);
    vec.emplace_back(std::move(temp)); // move , emplace_back(_Args&&... __args);
    vec.emplace_back(A());             // move , emplace_back(_Args&&... __args);
}
```

运行结果：

> ```text
> 0x61fddf
> 0x61fddf
> copy constructor
> move constructor
> move constructor
> copy constructor
> move constructor
> move constructor
> ```





### 封装、继承和多态

`封装`

**定义：**将数据和操作数据的方法结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互

**好处：**减少耦合、类内部的结构可以自由修改、更好控制类成员变量、隐藏属性和实现细节



`继承`

**定义：**可以使用已存在的类定义新类，新类可以定义新属性和新方法，但是不能选择性的继承父类的成员

**好处：**使用继承可以非常方便地复用之前的代码，大大提高开发效率

**多重继承：**一个派生类可以同时继承多个基类，由于可能会有成员命名冲突，因此对于同名成员，需要在前面加上类名和域解析符::



`多态`

**定义：**函数调用可以有多种形态

- 静态多态：函数重载
- 动态多态：基类指针或引用调用重写虚函数

**多态的构成条件：**

1. 必须通过基类的指针或引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类重写了该虚函数

**好处：**

假设现在有一个基类，类型是人，在源代码中，会调用人的说话方法，这是一个虚函数，但人可以分为多个国家的人，每个国家的语言不一样，我们只需要继承基类人，然后重写对应的说话方法，就可以实现不用改动源代码，而是在运行时会根据基类指针或引用实际绑定的值来调用到对应的函数。这样大大降低了新添功能的复杂度



### STL容器释放

STL容器释放时，会调用元素的析构函数。**但是如果元素类型是指针时，并不会释放指针，需要我们先遍历容器一个个释放后，才能释放容器**，可以存放智能指针，而不是普通指针



### struct和class的区别

唯一区别就是默认访问权限，class默认访问权限是private，而struct是public



### 可变数据成员

const对象可以改变一个可变成员的值

![image-20240323234802597](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240323234802597.png)



### 类的声明和定义

`在声明之后，定义之前，类为不完整类型，只能用于指向该类型的指针或引用或者用于声明（不是定义）使用该类型做为形参类型或者返回类型的函数。`





### 菱形继承与虚继承

`菱形继承的带来的问题`

类A和类B继承于同一个基类R，现在有一个类C同时继承类A和类B，此时类C的对象中会有两个同样的R，一份来自于A，另一份来自于B，这样会造成内存浪费。并且还会带来二义性

**示例代码**

```cpp
#include <iostream>
using namespace std;

class GrandParent
{
public:
    GrandParent()
    {
        cout << "GrandParent constructor" << endl;
    }
    GrandParent(int m_gp) : gp(m_gp) {}
    int gp;
};

class Father : public GrandParent
{
public:
    Father()
    {
        cout << "Father constructor" << endl;
    }
    Father(int m_father, int m_gp) : father(m_father) {}
    int father;
};

class Mother : public GrandParent
{
public:
    Mother()
    {
        cout << "Mother constructor" << endl;
    }
    Mother(int m_mother) : mother(m_mother) {}
    int mother;
};

class Son : public Father, public Mother
{
public:
    Son(int m_son)
    {
        son = m_son;
        cout << "Son constructor" << endl;
    }
    int son;
};

int main()
{
    // 生成一个son对象，由于是菱形继承，Father类和Mother类会各构造一次，而GrandParent会构造两次
    Son son(0);
    // 并且son使用GrandParent中的gp，还需要加上域解析符，不然会有二义性
    son.Father::gp;
    son.Mother::gp;
}
```

**输出结果**

> GrandParent constructor
> Father constructor 
> GrandParent constructor
> Mother constructor 
> Son constructor 



**Son内存分布**

```
1>class Son	size(20):
1>	+---
1> 0	| +--- (base class Father)
1> 0	| | +--- (base class GrandParent)
1> 0	| | | gp
1>	| | +---
1> 4	| | father
1>	| +---
1> 8	| +--- (base class Mother)
1> 8	| | +--- (base class GrandParent)
1> 8	| | | gp
1>	| | +---
1>12	| | mother
1>	| +---
1>16	| son
1>	+---
```



为了解决上述问题，引入了`虚基类`和`虚继承`

**虚基类：**在间接继承共同基类时只保留一份基类成员。虚基类不是在声明基类时声明的，是在声明派生类指定继承方式时，通过在继承方式前加`virtual`关键字

`对于具有共同基类的派生类最好采用虚继承的方式，避免多份基类成员的拷贝`

**虚继承：**在指定派生类继承方式前面加上`virtual`关键字



`C++编译系统只会执行最后的派生类对基类的初始化，而忽略其它派生类对虚基类的构造函数调用，从而避免对虚基类的同一成员多次初始化。因此虚基类只会构造一次，就是最后的派生类，在这里就是Son类，会执行GrandParent的构造函数，因为对于Son来说，GrandParent并不是虚基类`



**示例代码**

```cpp
#include <iostream>
using namespace std;

class GrandParent
{
public:
    GrandParent()
    {
        cout << "GrandParent constructor" << endl;
    }
    GrandParent(int m_gp) : gp(m_gp) {}
    int gp;
};

// Father是GrandParent的公用派生类，GrandParent是Father的虚基类
class Father : virtual public GrandParent
{
public:
    Father()
    {
        cout << "Father constructor" << endl;
    }
    Father(int m_father, int m_gp) : father(m_father) {}
    int father;
};

// Mother是GrandParent的公用派生类，GrandParent是Mother的虚基类
class Mother : virtual public GrandParent
{
public:
    Mother()
    {
        cout << "Mother constructor" << endl;
    }
    Mother(int m_mother) : mother(m_mother) {}
    int mother;
};

class Son : public Father, public Mother
{
public:
    Son(int m_son)
    {
        son = m_son;
        cout << "Son constructor" << endl;
    }
    int son;
};

int main()
{
    // 生成一个son对象，虽然间接继承了共同基类，但是只会有一份GrandParent成员
    Son son(0);
    // 直接访问gp，不具有二义性
    son.gp;
}
```

**输出结果**

> GrandParent constructor
> Father constructor
> Mother constructor
> Son constructor

**Son内存分布**

```
1>class Son	size(48):
1>	+---
1> 0	| +--- (base class Father)
1> 0	| | {vbptr}
1> 8	| | father
1>  	| | <alignment member> (size=4)
1>  	| | <alignment member> (size=4)
1>	| +---
1>16	| +--- (base class Mother)
1>16	| | {vbptr}
1>24	| | mother
1>  	| | <alignment member> (size=4)
1>  	| | <alignment member> (size=4)
1>	| +---
1>32	| son
1>  	| <alignment member> (size=4)
1>  	| <alignment member> (size=4)
1>	+---
1>	+--- (virtual base GrandParent)
1>40	| gp
1>	+---
```



### final和override

- `override`: 显示声明派生类要**重写虚函数**
- `final`: 
  - 修饰虚函数：显示声明该虚函数**不可被派生类重写**
  - 修饰类：显示声明该类**不可被继承**



## 数据结构

### 红黑树

性质：

1. 节点为红色或黑色
2. NIL节点(叶子节点)为黑色
3. 红色节点的子节点为黑色
4. 从根节点到NIL节点的每条路径上的黑色节点数量相同



### 智能指针

`智能指针的目的：`帮助我们自动释放指针

#### 共享指针内部实现

**智能指针类型：**

1. shared_ptr: 允许多个指针指向同一对象

   强引用计数：用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)

   弱引用计数：用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)

2. unique_ptr: “独占”所指向的对象

3. weak_ptr: 弱引用，指向shared_ptr所管理的对象



**shared_ptr内部实现原理**

```cpp
class __declspec(novtable) _Ref_count_base
{	// common code for reference counting
private:
	_Atomic_counter_t _Uses;   //记录了引用资源的shared_ptr的个数
	_Atomic_counter_t _Weaks;  //记录了weak_ptr的个数
}

template<class _Ty>
class _Ptr_base
{
private:
    element_type * _Ptr{ nullptr };      //指向资源
    _Ref_count_base * _Rep{ nullptr };   //指向资源引用计数
}

template<class _Ty>
class shared_ptr : public _Ptr_base<_Ty>
```



**make_shared的优势和劣势：**

通过`new`的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过`make_shared`的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）

```cpp
// new: 分配两次内存(一次分配a的内存，一次分配共享信息内存)，并且会造成内存碎片化
A *a = new A;
shared_ptr<A> pa(a);

// make_shared: 只分配一次内存(内部对象内存、共享信息内存一起分配)，且内部对象和共享信息控制块内存连续
auto p = make_shared<A>(1);
```

![image-20240318174921402](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174921402.png)



![image-20240318174936806](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174936806.png)

```cpp
// shared_ptr

#include <iostream>
using namespace std;

class Count
{
public:
    Count() : count(1) {}

    void increase()
    {
        ++this->count;
    }

    void decrease()
    {
        --this->count;
    }

    int get_count() const
    {
        return this->count;
    }

private:
    // 初始化为0，预防空指针情况
    int count = 0;
};

template <typename T>
class SharedPtr
{
public:
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}
    explicit SharedPtr(T *ptr) : ptr_(ptr), count_(new Count()) {}
    SharedPtr(const SharedPtr<T> &other)
    {
        ptr_ = other.ptr_;
        count_ = other.ptr_;
        count_->increase();
    }

    ~SharedPtr()
    {
        if (this->count_ != nullptr)
        {
            this->count_->decrease();
            if (count_->get_count() == 0)
            {
                delete ptr_;
                delete count_;
                ptr_ = nullptr;
                count_ = nullptr;
            }
        }
    }

    SharedPtr<T> &operator=(const SharedPtr<T> &other)
    {
        if (ptr_ != other.ptr_)
        {
            this->count_->decrease();
            if (this->count_->get_count() == 0)
            {
                delete this->ptr_;
                delete this->count_;
                this->ptr_ = nullptr;
                this->count_ = nullptr;
            }
        }
        this->ptr_ = other.ptr_;
        this->count_ = other.count_;
        count_->increase();
    }

    T *get()
    {
        return ptr_;
    }

    T *operator->
    {
        return ptr_;
    }

    T &operator*
    {
        return *ptr_;
    }

    int get_count() const
    {
        if (count_ == nullptr)
            return 0;
        return count_->get_count();
    }

private:
    T *ptr_;
    Count *count_;
};

```



#### 循环引用问题

![image-20240318175337344](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318175337344.png)

产生原因详解：

根据代码执行顺序，share_ptr指针指向new创建的一个Person对象，也就是图中栈空间的person指针指向了堆空间的Person对象，引用计数为1，同理，car指针也指向了堆空间的Car对象，引用计数亦为1。

接下来，Person对象里的成员m_car指向Car对象，Car对象的引用计数加1后为2，Car对象的m_person也指向Person对象，Person对象引用计数也加1为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1后为1，后释放person指针，Person对象的引用计数也减为1。由于Person对象和Car对象都是建立再堆空间上，两者相互依赖，都在等待对方释放。

可以看到，这个例子中，堆空间里的 Person对象 与 Car对象互相使用着，导致双方的 shared_ptr 强引用数量不会为0，所以不会自动释放内存，产生了内存泄漏。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;
class A
{
public:
    shared_ptr<B> inner_b;
};

class B
{
public:
    shared_ptr<A> inner_a;
};

int main()
{
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a.get()->inner_b = b; // b的引用计数是2
    b.get()->inner_a = a; // a的引用计数是2
    // 释放a和b，此时a和b的引用计数仍是1，所以其内部对象无法正确释放
    a.~shared_ptr();
    b.~shared_ptr();
    cout << a.use_count() << endl; // 1
    cout << b.use_count() << endl; // 1
}
```



解决方案：weak_ptr

![image-20240318180105547](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180105547.png)

![image-20240318180113901](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180113901.png)

根据之前的分析可知，前三句代码执行完后，Person对象的引用计数为1，Car对象的引用计数为2。而第四条语句car->m_person = person执行的便是途中虚线弱引用的语句，不增加Person对象的引用计数。因此，Person对象的引用计数为1，Car对象的引用计数为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1为1，后释放person指针，Person对象的引用计数减1后为0，Person对象释放内存空间，因此m_car成员变量也得到释放，Car对象引用计数减1后为0，Car对象也得到释放。因此不会产生内存泄漏。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;
class A
{
public:
    weak_ptr<B> inner_b;
};

class B
{
public:
    shared_ptr<A> inner_a;
};

int main()
{
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a.get()->inner_b = b; // b的引用计数是1，因为weak_ptr不增加强引用计数
    b.get()->inner_a = a; // a的引用计数是2
    // 释放a，a的引用计数减1，此时a和b的引用计数都是1
    a.~shared_ptr(); 
    // 释放b，b的引用计数减1变成0，因此可以释放b的内部对象，调用b的内部对象的析构函数
    // 然后会调用到inner_a的析构函数，a的引用计数也减1，a的内部对象也可以释放
    b.~shared_ptr(); 
    // a、b的内部对象都正常释放了
}
```



#### 共享指针线程安全

共享指针本身不负责多线程安全，而应该由程序员负责



**线程安全的定义**

多线程操作一个共享数据时，保证所有线程的行为是符合预期的则称为线程安全



**智能指针的线程安全隐患**

1. 引用计数的加减操作是否线程安全
2. 修改shared_ptr指向是否线程安全
3. shared_ptr\<T\>的T并发操作的安全性



> shared_ptr中除了有一个指向对象的指针，还有一个指向控制块的指针，里面存放了所有管理智能指针的数据（强引用计数、弱引用计数等），说明是在堆上的



**结论**

1）同一个shared_ptr被多个线程“读”是安全的；

2）同一个shared_ptr被多个线程“写”是不安全的；

3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的，因为采用原子操作保证该区域的引用计数值被互斥地访问



#### STL容器线程安全

STL（Standard Template Library）容器通常不是线程安全的。STL容器在设计上不考虑多线程并发访问的情况，因此在多线程环境下，对容器进行并发读写操作可能导致数据竞争和未定义行为。

如果需要在多线程环境下使用STL容器，需要采取额外的措施来确保线程安全，比如使用互斥锁（mutex）来保护容器的访问，或者使用线程安全的替代容器，如`std::shared_mutex`、`std::shared_timed_mutex`和`std::atomic`等。



### emplace_back无法取代push_back

![image-20240322140202982](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322140202982.png)

## 数据库

### 基础篇

#### COUNT函数

> - COUNT有几种用法？`COUNT(expr)、COUNT(常量)、COUNT(*)`
> - COUNT(字段名)和COUNT(\*)的查询结果有什么不同？`前者不统计NULL值，后者统计`
> - COUNT(1)和COUNT(\*)之间有什么不同？`COUNT(*)是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化`
> - COUNT(1)和COUNT(\*)之间的效率哪个更高？`起始是一样的，但由于COUNT(*)是标准语法，因此更推荐使用COUNT(*)`
> - 为什么《阿里巴巴Java开发手册》建议使用COUNT(\*)`理由同上`
> - MySQL的MyISAM引擎对COUNT(\*)做了哪些优化？`每张表都单独记录了行数`
> - MySQL的InnoDB引擎对COUNT(\*)做了哪些优化？`通过低成本的索引进行扫表，只关注表的记录数而不关注字段内容`
> - 上面提到的MySQL对COUNT(\*)做的优化，有一个关键的前提是什么？`优化的前提是查询语句中不包含where条件和group by条件`
> - SELECT COUNT(\*) 的时候，加不加where条件有差别吗？`加where条件COUNT(*)就没有优化了`
> - COUNT(\*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？`见下面第二条`

1. COUNT(expr): 返回SELECT语句检索的行中expr值不为NULL的数量，结果是一个BIGINT值

   如果查询结果没有命中任何记录，则返回0

   COUNT(*)的统计结果中，会包含NULL的行数

2. `COUNT(常量)` 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数。

   而`COUNT(列名)`表示的是查询符合条件的列的值不为NULL的行数。

   `COUNT(*)`是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化

3. COUNT(*)的优化：

   - MyISAM

     MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。

   - InnoDB

     InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。

     但是，InnoDB还是针对COUNT(*)语句做了些优化的。

     通过低成本的索引进行扫表，而不关注表的具体内容。

     InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

     **MySQL会优先选择最小的非聚簇索引来扫表。**

     优化的前提是查询语句中不包含where条件和group by条件。

4. COUNT(字段)

   进行全表扫描，判断指定字段的值是否为`NULL`，不为`NULL`则累加。

   性能比`count(1)`和`count(*)`慢。



### 索引篇

#### 聚簇索引和非聚簇索引

- 聚簇索引（Clustered Index），也叫主键索引，并不是一种单独的索引类型，而是一种`数据存储方式`。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。`无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引`。InnoDB的聚簇索引实际上是`将索引和数据保存中同一个B+Tree中`。InnoDB通过`主键`聚集数据，`如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替`。如果没有这样的索引，InnoDB会隐式定义一个主键（自增id）来作为聚簇索引。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080712264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

  

- 非聚簇索引（NoClustered  Index），又叫`二级索引`。`二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值`。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，`获得行的主键值，然后使用主键去聚簇索引中查找数据行`，这需要`两次`B+Tree查找。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080810940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

#### UNIQUE

UNIQUE创建的是`唯一索引`





#### 索引下推ICP

- 没有使用ICP的情况下：
  1. 存储引擎读取索引记录
  2. 根据索引中的主键值，定位并读取完整的行记录
  3. 存储引擎把记录交给Server层去检测该记录是否满足where条件
- 使用ICP的情况下：
  1. 存储引擎读取索引记录（不是完整的行记录）
  2. 判断where条件部分能否用索引中的列（比如联合索引中的后面的字段）来做检查，条件不满足，则处理下一行索引记录
  3. 条件满足，使用索引中的主键值去主键索引B+树定位并读取完整的行记录（这就是回表）
  4. 索引把记录交给Server层，让Server层去判断是否满足where条件中的其余部分







### 日志篇

#### undolog、redolog、binlog有什么用，是如何保证事务的四大特性的

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E6%8F%90%E7%BA%B2.png)



##### 为什么需要undolog？

`undolog(回滚日志)：`保证了事务的原子性

`undolog`是一种用于撤销回退的日志。在事务没提交之前，`undolog`会记录更新前的数据到`undolog`日志文件中，当事务回滚时，可以利用`undolog`回滚

![回滚事务](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



每当InnoDB引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到undolog

- 在`插入`一条记录时，要把这条记录的`主键值`记录下来，回滚时只需要将把这个主键对应的记录`删掉`即可
- 在`删除`一条记录时，要把这条记录中的内容都记下来，回滚时再把由这些内容组成的记录`插入`到表中就好了
- 在`更新`一条记录时，要把被更新的列的旧值记录下来，回滚时再把这些记录的对应列更新为旧值即可



一条记录的每一次更新操作产生的`undolog`格式都有一个`trx_id`事物id和`roll_pointer`指针

- 通过trx_id可以知道该记录是被哪个事务修改的
- 通过roll_pointer指针可以将这些undolog串成一个链表，这个链表就被成为`版本链`

版本链如下图：

![版本链](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



**undolog还有一个作用，通过ReadView + undolog 实现MVCC（多版本并发控制）**

![image-20240324223318346](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240324223318346.png)



对于`读提交`和`可重复读`隔离级别的事物来说，它们的快照读（普通select语句）是通过Read View+undolog来实现的，区别在于创建Read View时机不同：

- `读提交`隔离级别是在每个select都会生成一个新的Read View，这就意味着事务期间多次读取同一个数据，前后两次读取到的数据可能不一致，这是因为在这期间可能会有其它事务提交，然后修改了这个数据
- `可重复读`隔离级别是启动事务时生成一个ReadView，然后整个事务期间都在用这个Read View，这样就保证了事务期间读到的数据都是事务启动前的数据

这两个隔离级别的实现是通过`事务的ReadView里的字段`和`记录中两个隐藏列(trix_id和roll_pointer)`的比对，如果不满足可见性，就会顺着undolog版本链找到满足其可见性的记录，从而控制并发事务访问同一个记录的行为，这就是`MVCC(多版本并发控制)`



**undolog两大作用：**

1. `实现事务回滚，保证了事务的原子性`
2. `实现MVCC(多版本控制链的关键因素之一)。`MVCC是通过ReadView+undolog实现的。undolog为每条记录保存多份历史数据，MySQL在执行普通select语句时，会根据事务的ReadView的信息，顺着undolog版本链找到满足其可见性的记录



> undolog是如何持久化到磁盘的？

undolog和数据页持久化到磁盘的策略是一样的，都是需要通过redolog来保证持久化



##### 为什么需要redolog？

内存是不可靠的，万一断点重启，还没来得及落盘的脏页数据就会丢失



为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以redolog的形式记录下来，这时候这个更新才算完成了



`WAL(Write-Ahead Logging)技术是MySQL的写操作并不是立刻写到磁盘上，而是先写日志，然后再在合适的时间写到磁盘上`



> 什么是redolog？

`redolog是物理日志，记录了某个数据页做了什么修改，比如对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新`，每当执行一个事务时就会产生一条或多条物理日志



在事务提交时，只需要先将redolog持久化到磁盘，就可以保证当系统崩溃重启后，虽然内存中的脏页数据还没有同步到磁盘中，但是可以根据redolog的内容，将所有数据恢复到最新状态



`在内存修改了undolog，需要记录对应的redolog`



**undolog和redolog的区别：**

- `redolog`记录的是此次事务**完成后**的数据状态，记录的是更新后的值
- `undolog`记录的是此次事务**开始前**的数据状态，记录的是更新前的值

![事务恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



**redolog保证了事务四大特性中的持久性**





> redolog要写到磁盘，数据也要写到磁盘，为什么不直接把数据写入磁盘呢？

**写入redolog的方式使用了追加操作，所以磁盘操作是**`顺序写`**而写入数据的磁盘操作是**`随机写`，顺序写比随机写高效很多



**为什么需要redolog**

- 保证了事物的持久性
- 将写操作从随机写变成了顺序写





`产生的redolog并不是直接写入磁盘的`，redolog也有自己的缓存——redolog buffer，每当产生一条redolog时，会先写入到redolog buffer，后续在合适的时间才持久化到磁盘

![事务恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/redologbuf.webp)



> 缓存在redolog buffer中的redolog什么时候持久化到磁盘？

- MySQL正常关闭时
- 当redolog buffer中记录的写入量大于redolog buffer内存空间的一半时，会触发落盘
- `InnoDB的后台线程每隔一秒，将redolog buffer持久化到磁盘`
- 每次事务提交时，都会将存在redolog buffer中的redolog持久化到磁盘



> redolog文件写满了怎么办？

InnoDB存储引擎有一个redolog文件组，由两个redolog文件组成。

redolog文件组是通过`循环写`的方式工作的，从头开始写，写到末尾又回到开头，相当于一个环形。

因此InnoDB会先写第一个redolog文件，写满了就写第二个，如果第二个也满了，就回到第一个文件继续写

![重做日志文件组写入过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png)

redolog是为了防止Buffer pool中的脏页丢失设计的，如果脏页刷新到了磁盘中，redolog对应的记录也就没用了，这时候就可以擦除这些旧记录，以腾出空间记录新的更新操作



redolog是循环写的方式，InnoDB用write pos标识redolog当前记录写到的位置，用checkpoint表示当前要擦除的位置

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/checkpoint.png)

- write pos 和 checkpoint 的移动都是顺时针方向；
- write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；
- check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；



`当write pos追上checkpoint时，就代表redolog文件满了，此时MySQL会被阻塞，会停下来将Buffer Pool中的脏页刷新到磁盘中，然后标记redolog哪些记录可以被擦除，接着对旧的redolog记录进行擦除，擦除完记录也就腾出了空间，就可以继续记录了，MySQL恢复运行`





##### 为什么需要binlog？

`undolog`和`redolog`都是存储引擎生成的

MySQL在完成一条更新操作后，Server层还会生成一条`binlog`，等事务提交时，会将该事物执行过程中产生的所有binlog统一写入binlog文件



**binlog文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作**



> redolog和binlog有什么区别？

1. **适用对象不同**
   - binlog是MySQL的Server层实现的日志，所有存储引擎都可以使用
   - redolog是InnoDB存储引擎实现的日志
2. **文件格式不同**
   - binlog有3种格式类型，分别是`STATEMENT（默认格式）`，`ROW`、`MIXED`，区别如下：
     - `STATEMENT`：每一条修改数据的SQL语句都会被记录到binlog中（相当于记录了逻辑操作，所以针对这种格式，binlog可以成为逻辑日志），主从复制中slave端再根据SQL语句重现，但STATEMENT有动态函数的问题，比如uuid或者now这些函数，在不同库的执行结果并不相同
     - `ROW`：记录行数据最终被修改成什么样了（这种格式的日志，并不能成为逻辑日志），不会出现STATEMENT格式下动态函数的问题。但ROW的缺点是每行数据的变化结果都会被记录，使得binlog文件过大，而在STATEMENT格式下只会记录一个UPDATE语句而已
     - `MXED`：包含了STATEMENT和ROW格式，根据不同的情况自动使用STATEMENT和ROW模式
   - redolog是物理日志，记录的是**某个表空间**中的**某个数据页**做了**什么修改**
3. **写入方式不同**
   - binlog是追加写，写满了一个文件就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志
   - redolog是循环写，日志空间大小是固定的，全部写满就从头开始写，会覆盖以前的日志，保存的是未被刷盘的脏页记录
4. **用途不同**
   - binlog用于备份恢复、主从复制
   - redolog用于故障恢复



> 如果不小心整个数据库的数据被删除了，能使用redolog文件恢复数据吗？

不可以使用redolog文件恢复，只能使用binlog文件恢复



**因为redolog文件只是保存了未被刷盘的脏页数据，而binlog文件保存的全量日志，也就是保存了所有数据变更的情况**





> 主从复制是如何实现的



MySQL主从复制依赖于binlog，也就是记录MySQL上的所有变化并以二进制的形式保存在磁盘中，复制的过程就是将binlog中的数据从主库传输到从库上

这个过程是**异步**的，也就是主库上执行事务操作的线程不会等待复制binlog的线程同步完成

![MySQL 主从复制过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

MySQL集群的主从复制过程主要有3个阶段：

1. `写入binlog`：主库写binlog，提交事务，并更新本地存储数据
2. `同步binlog`：把binlog复制到所有从库上，每个从库把binlog写到暂存日志(`relaylog`)中
3. `回放binlog`：回放binlog，并更新存储引擎中的数据

具体详细过程如下：

1. MySQL主库在收到客户端提交事务的请求之后，会先写入binlog，然后再提交事务，更细存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应
2. 从库会创建一个专门的I/O线程连接主库的log dump线程，来接收主库的binlog日志，再把binlog日志信息写入relaylog中，再返回给主库"复制成功"的响应
3. 从库会创建一个用于回放binlog的线程，去读relaylog中继日志，然后回放binlog，把数据更新到存储引擎中，最终实现主从的数据一致性



**在完成主从复制之后，可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行**

![MySQL 主从架构](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)





> 从库是不是越多越好？

不是的，从库数量越多，也就会有越多的I/O线程连接到主库，而主库也要创建同样多的log dump线程来处理从库复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽





> MySQL主从复制还有哪些模型？

1. `同步复制`：MySQL主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。
   - 性能差
   - 可用性差：主库和任一从库出问题都会影响业务
2. `异步复制(默认模型)`：MySQL主库提交事务的线程并不会等到binlog同步到从库。
   - 一旦主库宕机，数据就会丢失
3. `半同步复制`：MySQL提交事务的线程不需要等待所有从库复制成功的响应，只需要等待一部分从库复制成功的响应即可返回给客户端结果。这样即使主库宕机，也有一部分从库的数据完成了更新，不存在数据丢失的风险





> binlog什么时候刷盘？

**事务执行过程中，先把日志写到binlog cache（server层的cache），等到事务提交时，再把binlog cache写到binlog文件，并清空binlog cache**

一个事物的binlog是不能被拆开的，因为这样会破坏事务的原子性

`一个线程只能由一个事物在执行，MySQL给每个线程分配了一块内存用于缓冲binlog，也就是binlog cache`

![binlog cach](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/binlogcache.drawio.png)





##### 为什么需要两阶段提交？

事务提交后，redolog和binlog都需要持久化到磁盘，但这两个是独立的逻辑，因此可能出现半成功的状态，这样就造成了两份日志之间的逻辑不一致



半成功情况：

- redolog持久化成功，binlog持久化失败：主库是新值，从库是旧值
- binlog持久化成功，redolog持久化失败：主库是旧值，从库是新值

所以半成功情况下会出现主从数据不一致





`两阶段`：分为prepare阶段和commit阶段

![两阶段提交](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



![时刻 A 与时刻 B](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

![image-20240325114437188](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240325114437188.png)





> 事务还没提交时，redolog会被持久化到磁盘吗？

会的。

事务执行过程中，redolog是直接写在redolog buffer中的，而MySQL后台线程每隔一秒会把redolog buffer中的日志持久化到磁盘中



`事务还没提交时，MySQL崩溃了，但是redolog已经持久化到磁盘，MySQL重启后，数据不一致怎么办？`

这种情况下，MySQL会进行回滚操作，因为事务还没提交时，binlog是还没持久化到磁盘的。

**因此，redolog可以在事务提交前持久化到磁盘，而binlog必须在事务提交后才可以持久化到磁盘**





> 两阶段提交有什么问题？

- **磁盘I/O次数高**：每个事务提交都会进行两次fsync（刷盘），一次是redolog刷盘，一次是binlog刷盘
- **锁竞争激烈**：多事务情况下并不能保证两者的提交顺序一致，因此需要多加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致



`MySQL引入了binlog组提交机制，当有多个事务提交的时候，会将多个binlog刷盘操作合成一个，从而减少了磁盘I/O的次数`

- **flush 阶段**：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；
- **sync 阶段**：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；
- **commit 阶段**：各个事务按顺序做 InnoDB commit 操作；

上面的**每个阶段都有一个队列**，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。

![每个阶段都有一个队列](http://keithlan.github.io/image/mysql_innodb_arch/commit_4.png)

对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，**锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率**。



##### 优化MySQL磁盘I/O

1. 组提交
2. 设置binlog在足量的事物提交后再统一刷盘



##### 如何保证事务的四大特性？

**事务的四大特性(ACID)：**

- `原子性`：一个事务的操作要么全部成功，要么全部失败回滚

  实现：undolog

- `一致性`：事务执行前后，数据都要处于一种合法的状态，即不能违反约束

  实现：约束、事务隔离级别、锁定机制、原子性操作

- `隔离性`：多个事务并发执行时，事务内部的操作与其它事务是隔离的，并发执行的各个事务之间互不影响

  实现：隔离级别

  - 读未提交：脏读、幻读、不可重复读
  - 读已提交：每做一次普通查询都会更新ReadView，会出现幻读、不可重复读
  - 可重复读：事务执行过程中都只有事务开始前的ReadView，会出现幻读，但是可通过MVCC机制（ReadView+undolog）避免部分幻读
  - 串行化：事务是串行执行的，不存在并发问题

- `持久性`：事务一旦提交后，它对数据库的改变就应该是永久性的，接下来的其它操作或故障不应该对其有任何影响

  实现：redolog



## 操作系统

### 用户态与内核态

`用户态：`运行用户程序的状态，权限受到限制。只能在操作系统划分的特定空间内运行。用户态下运行的程序不能直接访问硬件设备或执行特权指令，所有对硬件的访问都必须通过操作系统进行。在用户态下，应用程序通过系统调用来请求操作系统提供的服务，例如，文件操作、网络通信等都需要通过系统调用来实现。当应用程序发出系统调用后，会触发上下文切换，将CPU的控制权交给系统内核，进入内核态



`内核态：`内核态是运行操作系统程序、操作硬件的状态，拥有最高权限。处于内核态下的CPU可以执行任何指令，访问所有内存地址



这两种状态是操作系统为了安全和管理设计的





> `为什么要区分用户态和内核态？`

1. **安全性：**将操作系统和用户程序的运行环境隔离开有助于防止用户程序给内核带来不可修复的破坏。用户程序无法更改操作系统的关键资源
2. **稳定性：**用户程序崩溃不会影响到内核的运行，内核仍然可以正常工作
3. **性能：**内核态拥有最高权限，可以执行一些权限级别较高的工作，比如直接访问硬件。不需要为每个用户程序都提供这样的权限



`系统调用：`操作系统内核提供给用户的接口，用于请求操作系统的服务，比如读写文件、网络通信等都需要通过系统调用实现



### 调度算法

#### 银行家算法

Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，`把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可`。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。



安全状态概念：

![](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125164249992-1856910147.png)

1. 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2. 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即`系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态`。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即`每当进程提出资源请求且系统的资源能够满足该请求`时：

系统将判断满足此次资源请求后系统状态是否安全？

- 安全：给该进程分配资源
- 不安全：不分配资源，申请资源的进程将阻塞



银行家算法的执行有个`前提条件`，即要求进程预先提出自己的`最大资源请求`，并`假设系统拥有固定的资源总量`。



### 内存管理

#### 为什么要有虚拟内存？

**大纲**

![img](https://cdn.xiaolincoding.com//mysql/other/970ec527d1c1417eab0d3246e77405f9.png)

##### 虚拟内存

`虚拟内存地址：`程序所使用的内存地址叫做虚拟内存地址

`物理内存地址：`实际存在硬件里面的空间地址叫做物理内存地址



进程持有的虚拟内存地址会通过CPU‘芯片的内存管理单元（MMU）的映射关系，转变成物理内存地址，再通过物理内存地址访问

![img](https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png)



**操作系统主要通过两种方式来管理虚拟内存地址和物理内存地址的映射关系的，分别是内存分段和内存分页**

##### 内存分段

程序是由若干个逻辑段组成的，比如可以分层代码段、数据段、堆、栈。**不同的段有不同的属性，所以就用分段的形式把这些段分离出来**



分段机制下的虚拟地址由两部分组成，`段选择因子`和`段内偏移量`

![img](https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png)

`段选择因子`里面最重要的是段号，用作段表的索引。`段表`里面保存的是这个`段的基地址`、`段的界限`、`特权等级`等

虚拟地址中的`段内偏移量`加上`段基地址`就能得到物理内存地址



**分段机制会把虚拟地址分成4个段，每个段在段表中有一个项，这个项包括段基地址、段界限和特权等级等**

![img](https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png)



分段的方式解决了程序不需要关心具体的物理地址的问题，但是也有两个问题：

1. 内存碎片
2. 内存交换效率低



`出现内存碎片的原因：`内存碎片分为内部内存碎片和外部内存碎片，由于分段机制是进程申请多少就给多少，因此不会出现内部内存碎片，外部内存碎片出现的原因是每个段的长度不固定，所以未必能恰好使用所有的内存空间，会产生多个不连续的小物理内存，导致新的程序无法被装载（即使空闲内存空间总和足够），但由于不连续，所以无法分配。解决的方法是将某些程序先写到磁盘上，再重新加载回内存，但是重新加载回来后的内存地址变了，应该紧紧跟着前面已被使用的内存空间。

这个内存交换空间，在Linux里，就是Swap空间



`内存交换效率低的原因：`由于是通过内存交换的方式来解决外部内存碎片问题，因此要访问磁盘，而磁盘的访问速度比内存慢太多了。如果此时要换出的段大小比较大，那么所消耗的时间就会比较久



**为了解决内存分段的 外部内存碎片和内存交换效率低的问题，就出现了内存分页**



##### 内存分页

`分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小`，这样一个连续并且尺寸固定的内存空间，叫**页**，在Linux下，每一页是`4KB`大小



虚拟内存地址和物理内存地址通过页表来管理映射关系：

![img](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png)



`解决外部内存碎片问题：`内存分页由于内存空间都是预先划分好的，也就不会像分段机制一样，段与段之间有间隙非常小的内存空间。但是由于内存分页机制分配内存的最小单位是一页，即使程序大小不足一页，也会分配一页，所以会有内部内存碎片



`解决内存交换效率低问题：`如果内存空间不够，操作系统会把**最近未被使用**的内存页面释放掉，也就是暂时写在硬盘上。所以一次性写入磁盘的也只有一个页或几个页，不会花太多时间，内存交换效率就比较高



更进一步，分页机制使得我们在加载程序时，不需要一次性把程序都加载到物理内存中，**可以先建立虚拟内存地址和物理内存地址的映射关系后，等程序需要用到对应的虚拟内存地址的指令和数据后，再加载到物理内存里面**



**分页机制的映射管理**

![img](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)

1. 虚拟地址分为页号和页内偏移量
2. 通过页号在页表中找到对应的物理页号
3. 找到对应物理页加上页内偏移量就是对应的物理地址了



`简单分页的缺陷`

在32位的环境下，虚拟内存空间是4GB，一个页是4KB大小，所以大概有100万(2^20)个页，每个页表项需要4个字节大小来存储，所以整个4GB空间的映射就需要有4MB的内存来存储页表

假设有100个进程，那么就需要400MB大小来存储这些页表



**为了解决这个问题，需要采用多级页表**



**多级页表**



`在32位环境下，如果使用了二级页表，一级有1024个页表项，这些页表项指向对应二级页表，而由于进程一般很少会使用到全部的虚拟内存空间，因此一级页表中的有些页表项是空的，也就意味着根本不用创建对应的二级页表，假设有20%的虚拟内存空间被使用了，那么页表所占空间就是一级页表加创建的二级页表大小，即4KB+20%×4MB=0.804MB`





虽然多级页表解决了空间上的问题，但是虚拟地址转到物理地址就多了几道转换的工序，显然就降低了转换效率

程序是有局部性的，程序访问到的数据在短时间内很大概率会再次访问到，因此可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是就加入了一个专门存放程序最常访问的页表项的缓存，就是`TLB(Translation Lookaside Buffer)`，通常成为`页表缓存`、`转址旁路缓存`、`快表`

![img](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)



有了TLB后，CPU在寻址时，会先查TLB，如果没找到，才会继续查常规的页表



##### 段页式内存管理

内存分段和内存分页合在一起就是段页式



- 将程序划分为多个有逻辑意义的段
- 再把每个段分为多个页

这样，地址结构就由段号、段内页号和页内偏移三部分组成

![img](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)





##### 总结

`为什么要有虚拟地址？`

1. 虚拟内存可以使程序的运行内存超过物理内存，由于程序运行符合局部性原理，CPU访问内存会有很明显的重复性，对于没有经常被使用的内存，可以把它交换到物理内存之外，比如swap区域
2. 每个进程都有自己的页表，所以每个进程的页表是独有的，一个进程不可以访问到其它进程的页表，这样就把每个进程的地址空间隔离开来，解决了多进程地址冲突的问题
3. 页表项除了有物理地址外，还有一些标志性的比特位，比如可以控制一个页的读写权限，以及标志一个页是否存在或者是否为脏页，为操作系统提供了更好的安全性





#### 进程虚拟内存空间分布

![虚拟内存空间划分](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)



1. .text(代码段)：

   用于存放程序代码的区域， 编译时确定， 只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

2. .data(数据段):

   用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了`初值(不为0)的全局变量、常量和静态变量`都存放在这个域。

3. .bss：

   bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

   data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。

   data段包含经过初始化的全局变量以及它们的值。

   BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。

4. 堆：

   向高地址伸长

5. 栈：

   向低地址伸长





### 网络系统

#### 零拷贝

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8F%90%E7%BA%B2.png)



##### DMA（Direct Memory Access直接内存访问）

没有DMA技术前，I/O的过程如下：

1. CPU发出对应指令给磁盘控制器，然后返回
2. 磁盘接收到指令后，开始准备数据，然后把数据放到磁盘控制器的内部缓冲区，之后产生一个中断
3. CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的内部缓冲区一个一个字节读到自己的寄存器中，然后再把寄存器中的数据写入到内存，CPU在数据传输阶段是无法执行其它任务的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/I_O%20%E4%B8%AD%E6%96%AD.png)





**DMA技术**：在进行I/O设备和内存的数据传输时，全部由DMA控制器完成，而CPU不再参与任何跟数据搬运相关的事情，这样就可以解放CPU去处理别的事务了

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png)



内核缓冲区是内核利用一部分物理内存分配出来的



##### 传统文件传输

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)

4次上下文切换（用户态和内核态之间的切换）

4次拷贝：

1. 从磁盘控制器的内部缓冲区拷贝到内核缓冲区，由DMA完成
2. 内核缓冲区拷贝到用户缓冲区，由CPU完成
3. 用户缓冲区拷贝到内核socket缓冲区，由CPU完成
4. 从内核socket缓冲区拷贝到网卡缓冲区，由DMA完成



`提高文件传输效率，从两个方面优化，一是减少用户态与内核态的切换，二是减少内存拷贝次数`

##### 优化文件传输的性能

1. 减少用户态与内核态的切换：减少系统调用的次数
2. 由于从内核缓冲区拷贝到用户缓冲区的数据并不会再加工，所以数据可以不用拷贝到用户空间，因此用户缓冲区没有存在的必要



##### 实现零拷贝

1. **mmap+write**

   mmap系统调用会把内核缓冲区的数据直接映射到用户空间，因此内核与用户空间就不需要进行任何拷贝操作了

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)

   流程如下：

   1. 应用进程调用mmap后，DMA会把磁盘中的数据拷贝到内核缓冲区中，用户进程和内核共享这块内核缓冲区
   2. 应用进程再调用write，数据从内核缓冲区拷贝到内核socket缓冲区，由CPU完成
   3. 最后，把数据从socket缓冲区拷贝到网卡缓冲区，由DMA完成

   仍需要4次上下文切换和3次拷贝

   

2. **sendfile**

   系统调用函数：

   ```c
   #include <sys/socket.h>
   ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
   ```

   out_fd: 目的端文件描述符

   in_fd: 源端文件描述符

   offset: 源端偏移量

   count: 要复制的数据长度

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)

   减少了一次系统调用，因此少了两次上下文切换

   但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。

   你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

   ```shell
   $ ethtool -k eth0 | grep scatter-gather
   scatter-gather: on
   ```

   

   对于支持SG-DMA技术的网卡，sendfile系统调用过程如下：

   1. 将数据从磁盘拷贝到内核缓冲区，由DMA完成
   2. 缓冲区描述符和数据长度传到socket缓冲区，SG-DMA控制器可以直接将数据从内核缓冲区拷贝到网卡缓冲区，不需要将数据从内核缓冲区拷贝到socket缓冲区

   `这就是零拷贝技术，因为不存在内存层面上的数据拷贝，意味着全程没有通过CPU来拷贝数据，所有的数据都是通过DMA来传输。只需要2次上下文切换和2次拷贝`



##### PageCache

前面的第一步拷贝都是拷贝到内核缓冲区，这个内核缓冲区实际上是磁盘高速缓存（PageCache）

零拷贝如果使用PageCache技术，那么性能可以进一步提升



**PageCache提高性能的方式：**

1. 由于`局部性原理`，刚被访问的数据再次被访问的概率很高，于是用PageCache来缓存最近被访问的数据，当空间不足时淘汰掉最久未被访问的缓存

   因此，在读取磁盘数据时，优先去PageCache找，如果没有再到磁盘中读取，然后缓存PageCache

2. 预读功能：比如，假设 read 方法每次只会读 `32 KB` 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。



**但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能**



##### 大文件传输方式

读取文件时，进程会进入阻塞状态，我们可以采用异步I/O的方式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png)



读操作分为两部分：

- 前半部分：内核向磁盘发起读请求，但是可以不等待数据就位就返回，于是进程此时就可以处理后面的任务
- 后半部分：当内核将磁盘中的数据拷贝到进程缓冲区后，进程接收到内核的通知，再去处理数据



异步I/O要绕开PageCache

绕开PageCache的叫直接I/O，使用PageCache的是缓存I/O，对于磁盘，异步I/O只支持直接I/O



大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。



`在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术`。



**传输文件方式：**

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；





#### I/O多路复用：select/poll/epoll

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8F%90%E7%BA%B2.png)



##### socket编程

服务端：

1. 调用socket(int domain, int type, int protocol)函数，创建网络协议为IPv4，以及传输协议为TCP的Socket
2. 调用bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数，给这个Socket绑定一个IP地址和端口
   - 绑定端口的目的：通过端口号找到应用程序
   - 绑定IP的目的：找到对应网卡，因为每个网卡都有对应的IP地址
3. 调用 listen(int sockfd, int backlog)函数监听,backlog限制accept队列（全连接队列）的大小
4. 调用accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)函数连接客户端，如果此时没有客户端连接，则会阻塞等待下一个客户端的连接



客户端：

创建好socket之后，调用connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数发起连接



然后TCP三次握手就开始了，

在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：

- 一个是「还没完全建立」连接的队列，称为 **TCP 半连接队列**，这个队列都是没有完成三次握手的连接，此时服务端处于 `syn_rcvd` 的状态；
- 一个是「已经建立」连接的队列，称为 **TCP 全连接队列**，这个队列都是完成了三次握手的连接，此时服务端处于 `established` 状态；

当 TCP 全连接队列不为空后，服务端的 `accept()` 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。

注意，监听的 Socket 和真正用来传数据的 Socket 是两个：

- 一个叫作**监听 Socket**；
- 一个叫作**已连接 Socket**；

连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 `read()` 和 `write()` 函数来读写数据。





**线程池**的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理



##### IO多路复用

使用多进程/多线程来管理每个socket的开销比较大，因此使用I/O多路复用技术



概念：一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。



select/poll/epoll: `进程可以通过一个系统调用函数从内核中获取多个事件`



1. `select`

   - 函数：

     ```c
     int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
     ```

   - 实现方式：将已连接时Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核中，内核遍历文件描述符集合，如果有网络事件产生，那么就将Socket标记为可读可写，接着再把整个文件描述符集合拷贝回用户，用户进程遍历文件描述符集合，如果找到可读可写的Socket，代表着有网络事件，再对其进行读写

   - 弊端：select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

2. `poll`

   - 函数：

     ```c
     struct pollfd {
     　　 int fd;           /*文件描述符*/
     　　 short events;     /*监控的事件*/
     　　 short revents;    /*监控事件中满足条件返回的事件*/
     };
     int poll(struct pollfd *fds, unsigned long nfds, int timeout);   
     ```

   - 实现方式：poll和select的唯一区别在于，poll是通过动态数组来管理文件描述符的，以链表的方式组织。突破了select的文件描述符个数限制，但仍受到系统文件描述符限制，并且poll依旧是把文件描述符数组拷贝到内核中，然后内核遍历数组判断是否有网络事件发生，如果有就标记为可读可写，接着再拷回用户态，用户进程遍历文件描述符数组判断是否可读可写，再做相应的处理

3. `epoll`

   - 函数：

     ```c
     // 该函数生成一个 epoll 专用的文件描述符。
     int epoll_create(int size);
     
     // epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
     int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
     
     // 等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。返回需要处理的事件数目
     int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
     ```

   - 用法：

     ```c
     int s = socket(AF_INET, SOCK_STREAM, 0);
     bind(s, ...);
     listen(s, ...)
     
     int epfd = epoll_create(...);
     epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
     
     while(1) {
         int n = epoll_wait(...);
         for(接收到数据的socket){
             //处理
         }
     }
     ```

   - 从两个方面解决`select`和`poll`的问题:

     1. 传入参数：epoll在内核中使用红黑树来跟踪所有进程的待检测的文件描述符，由于内核有文件描述符集合的信息，因此用户进程只需要传入一个待检测的socket即可
     2. 检测有事件发生的socket：epoll使用事件驱动，内核里维护了一个链表来记录就绪事件，当某个socket有时间发生时，就回通过回调函数加入到该就绪时间链表当中，当用户调用epoll_wait()函数时，返回有事件发生的文件描述符个数，不需要像select和poll去遍历整个文件描述符集合

     内核会将就绪事件链表拷贝到用户空间中，即第二个参数events，这样就知道有哪些socket是有事件的

   - `边缘触发（edge-triggered，ET）`:

     使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；

     **如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作，直到系统调用（如 `read` 和 `write`）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。**

     **一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。**

   - `水平触发（level-triggered，LT）`:

     使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

     **如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。**

   - 一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

   - select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。



### 进程管理

#### 进程和线程

**大纲**



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/3-%E6%8F%90%E7%BA%B2.jpg)

##### 进程

进程：运行中的程序就被称为进程，是**资源分配的基本单位**



> 并发和并行的区别

![并发与并行](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

并行：同一时间CPU可以执行多个任务

并发：假设1秒内，CPU可以快速切换不同进程执行，宏观看来，CPU就像在同一时间执行多个任务一样



##### 进程的状态

CPU从一个进程切换到另一个进程前，需要保留当前进程的状态，以便后续恢复

![七种状态变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

- 创建状态：进程正在被创建时的状态
- 就绪状态：可运行，由于其它进程处于运行状态而停止运行
- 运行状态：该时刻占用CPU
- 阻塞状态：该进程正在等待某一时间发生(如等待I/O)而暂时停止运行，这时，即使给它CPU控制权，它也无法运行
- 结束状态：进程正在从系统中消息的状态
- 挂起状态：进程并不占用实际物理内存空间的情况
  - 就绪挂起状态：进程在外存（磁盘），只要进入内存立马能执行
  - 阻塞挂起状态：进程在外存（磁盘）并等待某个事件的完成



导致进程挂起的原因不只是进程所使用的内存空间不在物理内存，还包括如下情况：

- 通过sleep让进程间歇性挂起，其原理是设置一个计时器，到期后叫醒进程
- 用户希望挂起一个程序的执行，比如在Linux中使用的ctrl+z挂起进程



##### 进程的控制结构

在操作系统中，使用进程控制块（PCB），来描述进程的



`PCB`是进程存在的唯一标识，意味着一个进程的存在，必然会有一个PCB，如果进程消失了，那么对应的PCB也会消失



> `PCB`具体包含的信息

- **进程描述信息：**

  - **进程标识符：**标识各个进程，每个进程都有一个并且唯一的标识符
  - **用户标识符：**进程所属的用户，用户标识符主要为共享和保护服务

- **进程控制和管理信息：**

  - **进程当前的状态：**如new、ready、running、waiting或blocking等
  - **进程优先级：**进程抢占CPU的优先级

- **资源分配清单：**

  有关内存地址空间或虚拟地址空间的信息，所打开的文件列表和使用的I/O设备的信息

- **CPU相关信息：**

  CPU中各个寄存器的值，当进程被切换时，CPU各寄存器的值都保存到相应的PCB中，以便进程重新执行时能从断点处继续执行



> 每个`PCB`是如何组织的

通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列：

- 把所有处于就绪状态的进程链在一起，就是就绪队列
- 把所有因等待事件完成而处于阻塞状态的进程链在一起，就是阻塞队列

![就绪队列和阻塞队列](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg)

除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除



##### 进程的上下文切换

`进程的上下文切换`: 一个进程切换到另一个进程运行

`CPU上下文`：CPU寄存器和程序计数器



**进程是由内核管理和调度的，因此进程的上下文切换只能发生在内核态**



进程的上下文切换不仅包含了虚拟内存空间、栈和全局变量等用户空间资源，还包含了内核堆栈、寄存器等内核空间资源



> 发生进程上下文切换的常见场景

- 时间片耗尽
- 系统资源不足
- 进程调用sleep主动挂起
- 被高优先级的进程抢占CPU
- 硬件中断



##### 线程

`线程是CPU调度运行的基本单位`



同一进程内的多个线程可以共享代码段、数据段、打开的文件列表等，但每个线程又都有独立的寄存器和栈



线程的优点：

- 一个进程中可以同时存在多个线程
- 各个线程之间可以并发执行
- 同一进程的各个线程之间共享地址空间和文件等资源

线程的缺点：

- 当一个线程崩溃时，会导致同一进程下的所有线程都崩溃了



##### 线程的上下文切换

- 同一进程的线程上下文切换：由于虚拟内存是共享的，只需切换线程的栈、寄存器等不共享的数据即可
- 不同进程的线程上下文切换：和进程上下文切换一样，需要切换虚拟内存空间、全局变量和栈表等用户空间资源，还需要切换内核堆栈、寄存器等内核空间资源



##### 线程的实现

- **用户线程：**在用户空间实现的线程，不由内核管理，是由用户态的线程库来完成管理
- **内核线程：**在内核中实现的线程，由内核管理
- **轻量级线程：**在内核中来支持用户线程



**用户线程和内核线程的对应关系**

1. 多对一

   ![多对一](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

2. 一对一

   ![一对一](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/18-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)

3. 多对多

   ![多对多](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/19-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)





> ​	用户线程的优势和缺陷

**多对一**

![用户级线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)



用户线程的整个管理和调度都是由线程库函数来完成的，操作系统不直接参与



用户线程的优点：

- TCB由线程库函数来维护，可以用于不支持线程的操作系统
- 用户线程的切换不进入用户态，速度更快

用户线程的缺点：

- 由于操作系统不参与线程的调度，一个线程发起系统调用而导致阻塞，同一进程下的所有用户线程都不能执行了
- 当一个线程开始运行后，除非它主动交出CPU使用权，否则它所在进程的其它线程是无法运行的，因为用户态线程没有办法打断当前运行中的线程，它没有这个特权，只有操作系统有，但是用户线程并非操作系统管理的
- 由于时间片是分给进程的，与其它进程相比，多线程情况下，每个线程分配到的时间片较少，执行慢





> 内核线程的优势和缺陷

**一对一**

![内核线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)



内核线程是由操作系统管理的，所以对应TCB是保留在内核中的，因此线程的创建、终止和管理都是由操作系统完成的



内核线程的优点：

- 在一个进程当中，当一个线程发起系统调用而阻塞并不会影响其它线程的运行
- 多线程的进程会被分配到更多时间片

内核线程的缺点：

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息
- 线程的创建、终止和切换都是通过系统调用的方式来进行，每次都要进入内核态，开销更大



> 轻量级线程的优点和缺陷

**轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度**。



在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：

- `1 : 1`，即一个 LWP 对应 一个用户线程；
- `N : 1`，即一个 LWP 对应多个用户线程；
- `M : N`，即多个 LWP 对应多个用户线程；

![LWP 模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/22-LWP.jpg)



**1 : 1 模式**

一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。

- 优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；
- 缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。

**N : 1 模式**

多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。

- 优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；
- 缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。

**M : N 模式**

根据前面的两个模型混搭一起，就形成 `M:N` 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。

- 优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。

**组合模式**

如上图的进程 5，此进程结合 `1:1` 模型和 `M:N` 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。



##### 调度

另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：

- **非抢占式调度算法**挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。



`五大调度原则`

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。



**调度算法**

- 先来先服务
- 最短作业优先
- 高响应比优先
- 时间片轮转调度
- 最高优先级调度
- 多级反馈队列



#### 进程和线程的比较

1. 进程是资源分配（包括内存、打开的文件等）的基本单位，线程是CPU调度的基本单位

2. 进程拥有一个完整的资源平台，而线程只独享必不可缺的资源，比如寄存器和栈

3. 线程同样具有就绪、运行、阻塞三种基本状态，也同样具有状态之间的转换

4. 线程能减少并发执行的时间和空间开销

   具体体现在如下几点：

   - 线程的创建时间更快，因为进程创建时，还需要资源管理信息，比如内存管理信息和文件管理信息，而线程的创建过程中，不会涉及这些资源管理信息，而是共享它们
   - 线程的终止时间更快，因为线程需要释放的资源更少
   - 线程切换的效率更高，因为线程的切换只需要切换寄存器和栈，对于虚拟内存空间，由于同一进程下的线程是共享的，因此不需要切换。而进程切换时需要切换页表，页表的切换十分耗时。进程和线程的切换都要进入内核态
   - 线程间的数据传递效率更高，因为线程是共享内存和文件资源的，因此不需要经过内核就可以完成数据的传递





## 离散数学

### 拓扑序列

拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点 u  到顶点 v 的每个有向边  uv， u 在序列中都在 v 之前。



拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。



不是所有的有向图都是有拓扑序的，只有**有向无环图**才有拓扑序，所以**有向无环图又被称为拓扑图**。



## 计算机概论

### 原码、反码和补码

|      | 原码（符号位：正0负1） | 反码（原码除符号位取反） | 补码（反码+1） |
| ---- | ---------------------- | ------------------------ | -------------- |
| 10   | 0000 1010              | 0111 0101                | 0111 0110      |
| -10  | 1000 1010              | 1111 0101                | 1111 0110      |



