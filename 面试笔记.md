## 项目

### 项目介绍

#### DragonOS

DragonOS主要是一个使用Rust编写的操作系统，然后我主要负责的是完善内核的一些机制，比如说内存重映射和共享内存模块

#### DADK

DADK是DragonOS的用户程序构建工具包，主要工作是扫描用户程序目录下的dadk文件，这是一个json格式的文件，里面有一些比较重要的字段，比如该应用程序的依赖项和构建命令这些，还有就是安装目录，方便了用户在DragonOS下安装用户程序



### 项目难点

我认为最难的地方在于架构的设计，因为不仅要满足当前的功能，还需要考虑到后续的拓展，不然一不小心就很容易写死了。比如在写共享内存时，由于之前没有共享内存，因此一个物理页最多只会映射到一个VMA，所以在释放时可以直接被回收，但是实现共享内存后，不能这么做了，需要额外判断这个物理页的映射情况，但当时我的处理是在管理共享内存的表中去查看当前物理页是否属于共享内存，如果是的话就不能直接回收，但是这样就把共享机制和页面回收机制耦合在了一起，因此为了解耦，我就先实现了页面反向映射，通过判断这个物理页的信息来决定是否可以回收，共享内存只需要修改自己的物理页信息为共享页并且还有映射计数



## 算法

### 并查集

- 解决连通性问题：

  1. 将两个元素添加到同一个集合中
  2. 判断两个元素是否在同一个集合中

- 关键方法：

  1. join(u,v): 将uv这条边加入并查集
  2. find(u): 寻找u的根节点
  3. init(): 初始化并查集，每个元素的根节点都是自己本身
  4. isSame(u,v): 判断是否有uv边，即u、v是否在同一个集合中

- 优化：

  路径压缩：不做优化的情况下，find可能需要递归好几层才能找到根节点，如果在递归的过程中重新设置每个元素的父节点，都将自己指向父结点的边改为指向原来的根节点，这样就可以把树的高度减为2，大大降低了递归深度

  由

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png" alt="img" style="zoom: 50%;" />

变成

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom: 67%;" />



代码：

```cpp
class UnionSet
{
public:
    UnionSet(int size)
    {
        size_ = size;
        father = vector<int>(size, 0);
        // 初始化，元素都指向自己本身
        for (int i = 0; i < size_; i++)
        {
            father[i] = i;
        }
    }

    // 查找u的根元素并且路径压缩
    int find(int u)
    {
        return u == father[u] ? u : father[u] = find(father[u]);
    }

    // 合并两个元素所在集合
    void join(int u, int v)
    {
        // 找到两个元素的根元素，然后合并两棵树，这样相当于在同一个集合里了
        u = find(u);
        v = find(v);
        // 已经在同一个集合就不需要再次合并了
        if (u == v)
            return;

        father[v] = u;
    }

    // 判断两个元素是否在同一个集合中
    bool isSame(int u, int v)
    {
        // 根元素相同就代表在同一个集合中
        return find(u) == find(v);
    }

private:
    int size_;
    vector<int> father;
};
```







### 排序算法

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序：将大数像泡泡一样冒到最后（稳定）
void bubbleSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 0; j < n - i - 1; ++j)
        {
            if (vec[j] > vec[j + 1])
            {
                int tmp = vec[j];
                vec[j] = vec[j + 1];
                vec[j + 1] = tmp;
            }
        }
    }
}

// 选择排序：选择一个基准值，将其后面最小的值与其交换（不稳定）
void selectionSort(vector<int>& vec)
{
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
        {
            if (vec[j] < vec[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = vec[i];
        vec[i] = vec[minIndex];
        vec[minIndex] = tmp;
    }
}

// 插入排序：将值插入到前面某个合适的位置
void insertionSort(vector<int>& vec) {
    int n = vec.size();
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        // 后移腾位
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }
}


// 快速排序：选一个基准值，小于它的放左边，大于它的放右边
class QuickSort
{
public:
    QuickSort() {};

    // 快速划分函数
    int partion(vector<int>& vec, int left, int right)
    {
        int pivot = vec[right];
        int index = left;

        // 大于pivot放右边，小于pivot放左边
        for (int i = left; i < right; ++i)
        {
            if (vec[i] < pivot)
            {
                swap(vec[i], vec[index++]);
            }
        }

        // 放置基准值
        swap(vec[right], vec[index]);
        return index;
    }

    // 快速排序
    void quickSort(vector<int>& vec, int left, int right)
    {
        if (left < right)
        {
            int pi = partion(vec, left, right);

            quickSort(vec, left, pi - 1);
            quickSort(vec, pi + 1, right);
        }
    }
};

// 归并排序：合并两个有序子数组
class MergeSort {
public:
    MergeSort() {};

    void merge(vector<int>& vec, int left, int mid, int right) {
        int size1 = mid - left + 1;
        int size2 = right - mid;

        vector<int>left_vec(size1);
        vector<int>right_vec(size2);

        for (int i = 0; i < size1; ++i) {
            left_vec[i] = vec[left + i];
        }
        for (int j = 0; j < size2; ++j) {
            right_vec[j] = vec[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while (i < size1 && j < size2) {
            if (left_vec[i] < right_vec[j]) {
                vec[k++] = left_vec[i++];
            }
            else {
                vec[k++] = right_vec[j++];
            }
        }

        while (i < size1) {
            vec[k++] = left_vec[i++];
        }
        while (j < size2) {
            vec[k++] = right_vec[j++];
        }
    }

    void mergeSort(vector<int>& vec, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(vec, left, mid);
            mergeSort(vec, mid + 1, right);

            merge(vec, left, mid, right);
        }
    }
};




int main()
{
    vector<int> vec{ 2, 1, 5, 4, 7, 6, 0 ,3 };

    // bubbleSort(vec);
    // selectionSort(vec);
    // QuickSort q;
    // q.quickSort(vec, 0, vec.size() - 1);
    // insertionSort(vec);
    MergeSort m;
    m.mergeSort(vec, 0, vec.size() - 1);


    for (auto& num : vec)
    {
        cout << num << " ";
    }
}
```



### 图

**迪杰斯特拉算法：**找某一起点到所有点的最短路径

时间复杂度：O(n^2)

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int INF = INT_MAX;

int main()
{
    int n; // 节点数
    int e; // 边数
    int s; // 起点
    cin >> n >> e >> s;

    // 起点到其它节点的最短路径长
    vector<int> dis(n, INF);
    dis[s] = 0;

    // 确保s到某个节点的路径已是最短
    vector<bool> check(n, false);

    // 图
    vector<vector<int>> graph(n, vector<int>(n, -1));
    for (int i = 0; i < e; i++)
    {
        int start, end, dis;
        cin >> start >> end >> dis;
        graph[start][end] = dis;
    }

    for (int i = 0; i < n; i++)
    {
        int min_dis = INF, min_idx = n;
        for (int j = 0; j < n; j++)
        {
            // 检查check可以避免重复在一个节点打转
            if (dis[j] < min_dis && !check[j])
            {
                min_dis = dis[j];
                min_idx = j;
            }
        }
        check[min_idx] = true;

        for (int k = 0; k < n; k++)
        {
            // 从min_idx节点到k节点距离更短，则更新，前提是min_idx节点和k节点是连通的
            if (graph[min_idx][k] > 0)
            {
                if (min_dis + graph[min_idx][k] < dis[k])
                {
                    dis[k] = min_dis + graph[min_idx][k];
                }
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        cout << dis[i] << " ";
    }
}
```

**最小生成树：**Kruscal算法和Prim算法（无向连通带权图）
prime算法复杂度由顶点数决定，更适合稠密图，而K算法由边数决定，故更适合稀疏图

- Prim算法：每次都选择到下一顶点权最小的边。

  - `Prim算法从一个初始顶点开始`，然后逐步扩展生成树，每次选择连接生成树和未加入生成树的顶点的权重最小的边。具体步骤如下：
    - 选择一个起始顶点作为生成树的根节点。
    - 将该节点标记为已访问，并将其与之相邻的所有边加入到优先队列中。
    - 从优先队列中选择权重最小的边，如果其连接的节点未被访问，则将该节点加入生成树，并将与该节点相邻的边加入优先队列中。
    - 重复以上步骤，直到所有节点都被访问过，生成树构建完成。
  - Prim算法的时间复杂度通常为 O(V^2) 或 O(E*logV)，其中V是顶点数，E是边数。

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  class Edge
  {
  public:
      Edge(int _to, int _weight) : to(_to), weight(_weight) {}
  
      int to;
      int weight;
  };
  
  int prim(const vector<vector<Edge>> &graph)
  {
      int minCost = 0;
      int n = graph.size();
      // 已访问节点为true
      vector<bool> visited(n, false);
      // 存放着所有已连接树 连接 未连接树的信息(权重，终点)
      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
  
      // 起始节点为0
      pq.push({0, 0});
  
      while (!pq.empty())
      {
          int w = pq.top().first;
          int u = pq.top().second;
          pq.pop();
  
          if (visited[u])
              continue;
  
          visited[u] = true;
          minCost += w;
  
          for (const Edge &edge : graph[u])
          {
              if (!visited[edge.to])
              {
                  pq.push({edge.weight, edge.to});
              }
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
      vector<vector<Edge>> graph(n);
  
      for (int i = 0; i < e; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          graph[u].emplace_back(Edge(v, w));
          graph[v].emplace_back(Edge(u, w));
      }
  
      cout << prim(graph);
  }
  ```

  

- Kruskal算法：每次都选择权最小的可以连通两个不同连通分支的边

  `边排序(权重从小到大) + 并查集`

  步骤：

  1. 边排序后，遍历边
  2. 如果边的两个顶点没加到并查集中，代表未连接，加入并查集、

  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  
  struct Edge
  {
      int u;
      int v;
      int weight;
  };
  
  bool compare(Edge a, Edge b)
  {
      return a.weight < b.weight;
  }
  
  class Union
  {
  public:
      Union(int n)
      {
          parent.resize(n);
          rank.assign(n, 0);
          for (int i = 0; i < n; i++)
          {
              parent[i] = i;
          }
      }
  
      int find(int u)
      {
          if (u == parent[u])
              return u;
          parent[u] = find(parent[u]);
          return parent[u];
      }
  
      void join(int u, int v)
      {
          u = find(u);
          v = find(v);
          if (rank[u] < rank[v])
          {
              parent[u] = v;
          }
          else if (rank[u] > rank[v])
          {
              parent[v] = u;
          }
          else
          {
              parent[v] = u;
              rank[u]++; // 高度增加了
          }
      }
  
      bool is_connect(int u, int v)
      {
          return find(u) == find(v);
      }
  
      vector<int> parent;
      vector<int> rank; // 用于判断树的高度，将高度低的树加到高度高的树上可以减少整个树的高度
  };
  
  /// @brief 生成最小树
  /// @param edges 所有边
  /// @param n 节点数
  /// @return 最小权重
  int kruskal(vector<Edge> &edges, int n)
  {
      int minCost = 0;
      Union uf(n);
  
      sort(edges.begin(), edges.end(), compare);
  
      for (auto &e : edges)
      {
          if (!uf.is_connect(e.u, e.v))
          {
              uf.join(e.u, e.v);
              minCost += e.weight;
          }
      }
  
      return minCost;
  }
  
  int main()
  {
      int n, e;
      cin >> n >> e;
  
      vector<Edge> edges(e);
  
      for (int i = 0; i < e; i++)
      {
          cin >> edges[i].u >> edges[i].v >> edges[i].weight;
      }
  
      cout << kruskal(edges, n);
  }
  ```




### [旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 1.转置
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = i + 1; j < matrix[i].size(); ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // 2.反转数组
        for (int i = 0; i < n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```



### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n=matrix.size();
        int m=matrix[0].size();

        pair<int,int>left_up(0,0);
        pair<int,int>right_down(n-1,m-1);

        while(left_up.first<=right_down.first&&left_up.second<=right_down.second){
            int up=left_up.first;
            int left=left_up.second;
            int down=right_down.first;
            int right=right_down.second;

            // 只剩一行
            if (up==down){
                for(int j=left;j<=right;j++){
                    res.emplace_back(matrix[up][j]);
                }
                break;
            }

            // 只剩一列
            if (left==right){
                for(int i=up;i<=down;i++){
                    res.emplace_back(matrix[i][left]);
                }
                break;
            }

            for(int j=left;j<right;j++){
                res.emplace_back(matrix[up][j]);
            }
            for(int i=up;i<down;i++){
                res.emplace_back(matrix[i][right]);
            }
            for(int j=right;j>left;j--){
                res.emplace_back(matrix[down][j]);
            }
            for(int i=down;i>up;i--){
                res.emplace_back(matrix[i][left]);
            }

            left_up.first+=1;
            left_up.second+=1;
            right_down.first-=1;
            right_down.second-=1;
        }

        return res;
    }
};
```



### [打乱数组](https://leetcode.cn/problems/shuffle-an-array/)

![image-20240321112356263](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321112356263.png)

```cpp
class Solution {
public:
    Solution(vector<int>& nums) { this->nums = nums; }

    vector<int> reset() { return this->nums; }

    vector<int> shuffle() {
        vector<int> res = nums;
        int n = nums.size();

        for (int i = 0; i < n; ++i) {
            swap(res[i], res[i + rand() % (n - i)]);
        }
        
        return res;
    }

private:
    vector<int> nums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```



### [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

思路：

- 双向链表：最近访问的元素放在链表头，最长时间没访问的元素在链表尾，由于查找、放置和删除节点时只会对头尾节点做操作，因此可以加一对虚拟头尾节点管理
- 整体维护一张哈希表，键值是key，value值是双向链表中的节点
- get(): 查找哈希表中有无对应键值，有则返回对应元素，并把该元素移到头节点，没有则返回-1
- put(): 查找有无对应键值，有则更新value值即可，并移到头节点。没有就需要添加，先判断LRU缓存是否已满，如果没满则添加到链表头，满了的话删掉尾节点然后再加到链表头

```cpp
struct DoubleLinkedNode {
    int key, value;
    DoubleLinkedNode* prev;
    DoubleLinkedNode* next;

    DoubleLinkedNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {}
    DoubleLinkedNode(int key, int val)
        : key(key), value(val), prev(nullptr), next(nullptr) {}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        dummy_head = new DoubleLinkedNode();
        dummy_tail = new DoubleLinkedNode();
        dummy_head->next = dummy_tail;
        dummy_tail->prev = dummy_head;
        size = 0;
        this->capacity = capacity;
    }

    int get(int key) {
        // 如果不存在，返回-1
        if (link_map.count(key) == 0)
            return -1;

        DoubleLinkedNode* key_node = link_map[key];
        // 更新访问时间
        moveToHead(key_node);
        return key_node->value;
    }

    void put(int key, int value) {
        // 如果存在，更新值，并更新时间
        if (link_map.count(key) != 0) {
            DoubleLinkedNode* key_node = link_map[key];
            key_node->value = value;
            moveToHead(key_node);
            // 及时返回，否则出了if还会继续执行，不符合逻辑
            return;
        }

        // 如果不存在
        // 先判断是否还有空间
        if (size == capacity) {
            // 空间已满
            // 删除链表尾(最久未被访问的元素)
            DoubleLinkedNode* tail_node = dummy_tail->prev;
            removeNode(tail_node);
            // 从link_map中删去key值
            link_map.erase(tail_node->key);
            // 更新元素个数
            --size;
        }

        // 空间充足
        // 初始化节点
        DoubleLinkedNode* new_node = new DoubleLinkedNode(key, value);
        // 加入到链表头
        addToHead(new_node);
        // 加入到link_map
        link_map[key] = new_node;
        // 更新元素个数
        ++size;
    }

    // 将节点加入链表头，用于put新添节点时
    void addToHead(DoubleLinkedNode* node) {
        DoubleLinkedNode* head_next = dummy_head->next;
        dummy_head->next = node;
        node->prev = dummy_head;
        head_next->prev = node;
        node->next = head_next;
    }

    // 移除节点，不止链表尾，因为还有将中间节点移出链表再添加到链表头的情况
    void removeNode(DoubleLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        node->prev = nullptr;
        node->next = nullptr;
    }

    // 将链表中的节点移动到链表头，满足更新key值对应value，和访问key时的情况
    void moveToHead(DoubleLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

private:
    unordered_map<int, DoubleLinkedNode*> link_map;
    DoubleLinkedNode* dummy_head;
    DoubleLinkedNode* dummy_tail;
    int size;
    int capacity;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### [三数之和](https://leetcode.cn/problems/3sum/)

思路：

排序数组后，定义双指针，由于数组是有序的，因此双指针的移动也是有规律的，假设当前和小于0，那么就让左指针往右移(nums[left]<=nums[left+1])，否则就让右指针左移(nums[right]>=nums[right-1])

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for (int i = 0; i < n - 2; ++i) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 去重
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return res;
    }
};
```



### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

思路：

由于连在一起的陆地算一块岛屿，因此遍历二维数组时，碰到一块陆地就将其所在岛屿的所有陆地沉下去（dfs），防止重复计算

```cpp
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 越界或者陆地不连续就停止
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() ||
            grid[i][j] == '0')
            return;

        // 沉下去
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }

    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int n = grid.size(), m = grid[0].size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }

        return res;
    }
};
```



### [数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

思路：

维护小顶堆A和大顶堆B，各维护一半元素，小顶堆A维护值较大的那一半（），大顶堆B维护值较小的那一半

![image-20240321213513781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321213513781.png)

```cpp
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        int m=A.size();
        int n=B.size();

        // num需要和A、B中的元素都比较之后才知道应该放在哪
        // A、B元素个数相同，加入A
        if(m==n){
            // num有可能属于较小的那一半，因此先加入B，再将B的堆顶元素加入A
            B.push(num);
            A.push(B.top());
            B.pop();
        }else{// m=n+1
            // num有可能属于较大的那一半，因此先加入A，再将A的堆顶元素加入B
            A.push(num);
            B.push(A.top());
            A.pop();
        }
    }

    double findMedian() {
        int m=A.size();
        int n=B.size();

        if(m==n){
            return (A.top()+B.top())/2.0;
        }

        return A.top();
    }

private:
    // A维护较大的一半元素，且元素个数大于等于B
    priority_queue<int, vector<int>, greater<int>> A;
    // B维护较小的一半元素，且元素个数小于等于A
    priority_queue<int, vector<int>, less<int>> B;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



### [二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```cpp
方法一：层序遍历（空节点也算）

方法二：dfs
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, unsigned long long> depth_first;
    unsigned long long res;

    // 先序遍历保证第一次加入哈希表的都是每层的最左节点
    void dfs(TreeNode* node, unsigned long long i, int depth) {
        if (!node)
            return;
        if (depth_first.count(depth) == 0)
            depth_first[depth] = i;
        res = max(res, i - depth_first[depth] + 1);
        dfs(node->left, 2 * i, depth + 1);
        dfs(node->right, 2 * i + 1, depth + 1);
    }

    int widthOfBinaryTree(TreeNode* root) {
        res = 0;
        dfs(root, 1, 0);
        return res;
    }
};
```



### [ 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

思路：

树形递归（回溯）

```cpp
class Solution {
public:
    vector<string> res;
    vector<int> path;

    void dfs(string& s, int start, int ip_idx) {
        // s刚好分为4个值
        if (ip_idx == 4 && start == s.size()) {
            string ip=to_string(path[0]);
            for(int i=1;i<path.size();++i){
                ip+="."+to_string(path[i]);
            }
            res.emplace_back(ip);
        }

        for (int i = start, num = 0; i < s.size(); ++i) {
            num = num * 10 + s[i] - '0';
            if (num > 255) // 剪枝
                break;
            path.emplace_back(num);
            dfs(s, i + 1, ip_idx + 1);
            path.pop_back();
            if(num==0)break; // 从0起始只有一种情况有效，就是num=0，x.0.y，处理完这种情况后就可以break了
        }
    }

    vector<string> restoreIpAddresses(string s) {
        dfs(s, 0, 0);
        return res;
    }
};
```



### [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

思路：

KMP

next数组: next[i]存放的是匹配串的子串[0,i]的最长公共前后缀长度

```cpp
class Solution {
public:
    vector<int> next(string& needle) {
        int n = needle.size();
        if (n <= 1) {
            return {-1};
        }

        // next[i]: needle[0,i-1]子串的最长公共前后缀长度
        // 不需要知道needle[0,n-1]即整个字符串的最长公共前后缀长度，因为此时都匹配完了
        vector<int> next(n, 0);
        // 规则：
        next[0] = -1;
        next[1] = 0;
        int i = 2;
        int j = 0;
        while (i < n) {
            if (needle[i - 1] == needle[j]) {
                /*
                next[i]=j+1;
                ++i;
                j=next[i-1];
                */
                next[i++] = ++j;
            } else if (j > 0) {
                j = next[j];
            } else {
                next[i++] = 0;
            }
        }

        return next;
    }

    int strStr(string haystack, string needle) {
        int n = needle.size();
        vector<int> next_vec = next(needle);

        int i = 0;
        int j = 0;

        while (i < haystack.size()) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
                if (j == n)
                    break;
            } else if (j > 0) {
                j = next_vec[j];
            } else {
                ++i;
            }
        }

        return j == n ? i - n : -1;
    }
};
```



### [反转链表](https://leetcode.cn/problems/UHnkqh/)

```cpp
方法一：迭代，哨兵节点（虚拟头、尾节点）

方法二：递归
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* node) {
        // 最后一个节点无需反转
        if (!node->next){
            return node;
        }
        
        ListNode* res=reverse(node->next);
        node->next->next=node;
        node->next=nullptr;

        // res一直是最后一个节点，即反转后的链表头
        return res;
    }

    ListNode* reverseList(ListNode* head) {
        if(!head)return head;
        return reverse(head);
    }
};
```

### [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```cpp
class MyQueue {
public:
    MyQueue() {}

    void push(int x) { push_stk.push(x); }

    int pop() {
        // 如果pop_stk是空，则把push_stk的数据加入pop_stk(刚好反转了顺序)
        // 如果pop_stk不为空，则不能把push_stk的数据加入pop_stk，这样会打乱了顺序
        if (pop_stk.empty()) {
            while (!push_stk.empty()) {
                pop_stk.push(push_stk.top());
                push_stk.pop();
            }
        }

        int res = pop_stk.top();
        pop_stk.pop();
        return res;
    }

    int peek() {
        if (pop_stk.empty()) {
            while (!push_stk.empty()) {
                pop_stk.push(push_stk.top());
                push_stk.pop();
            }
        }

        return pop_stk.top();
    }

    bool empty() { return push_stk.empty() && pop_stk.empty(); }

private:
    stack<int> push_stk;
    stack<int> pop_stk;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

思路：

一个队列存数据，另一个队列是空，此时如果是pop操作，就把除了队列为的数据存放到空队列中，然后再把队列尾pop出来即可。如果是push操作，那么直接加入到不为空的那个队列即可。peek相比于pop只是把队列尾移出队列变成把队列尾继续加入到另一个队列中

```cpp
class MyStack {
public:
    MyStack() {}

    void push(int x) { que1.empty() ? que2.push(x) : que1.push(x); }

    int pop() {
        int res = 0;
        if (!que1.empty()) {
            while (que1.size() > 1) {
                que2.push(que1.front());
                que1.pop();
            }
            res = que1.front();
            que1.pop();
        } else {
            while (que2.size() > 1) {
                que1.push(que2.front());
                que2.pop();
            }
            res = que2.front();
            que2.pop();
        }
        return res;
    }

    int top() {
        int res = 0;
        if (!que1.empty()) {
            while (que1.size() > 1) {
                que2.push(que1.front());
                que1.pop();
            }
            res = que1.front();
            que1.pop();
            que2.push(res);
        } else {
            while (que2.size() > 1) {
                que1.push(que2.front());
                que2.pop();
            }
            res = que2.front();
            que2.pop();
            que1.push(res);
        }
        return res;
    }

    bool empty() { return que1.empty() && que2.empty(); }

private:
    queue<int> que1;
    queue<int> que2;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### [堆内存申请](https://mp.weixin.qq.com/s/1LwA3HRO-8ygR_cHx1Ha1Q)

![image-20240323211134845](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240323211134845.png)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 100;

struct AllocatedInterval
{
    AllocatedInterval(int start_, int end_) : start(start_), end(end_) {}
    int start;
    int end;
};

// 想让自定义对象在vector中排序，尽可能将自定义对象用struct声明
static bool compare(const AllocatedInterval &a1, const AllocatedInterval &a2)
{
    if (a1.start < a2.start)
        return true;
    return a1.start == a2.start ? a1.end < a2.end : false;
}

int main()
{
    vector<AllocatedInterval> intervals;

    // 申请内存大小
    int size = 0;
    cin >> size;

    int start, offset;
    while (cin >> start)
    {
        cin >> offset;
        intervals.emplace_back(AllocatedInterval(start, start + offset - 1));
    }
    // 因为我们是要遍历空闲内存空间，所以增加两个哨兵区间[-1,-1]和[N,N]
    // 这样就可以遍历到第一块已被分配内存空间的前面的空闲空间，以及最后一块已被分配内存空间后面的空闲空间
    intervals.emplace_back(AllocatedInterval(-1, -1));
    intervals.emplace_back(AllocatedInterval(N, N));
    // 排序
    sort(intervals.begin(), intervals.end(), compare);

    // 查找有无重叠区域
    int n = intervals.size();
    for (int i = 0; i < n - 1; ++i)
    {
        if (intervals[i].end >= intervals[i + 1].start)
        {
            // 有重叠区域，无效
            cout << -1 << endl;
        }
    }

    // 查找最合适的区域
    int min_size = INT_MAX;
    int idx = -1;
    for (int i = 1; i < n; ++i)
    {
        // 空闲空间大小
        int free_size = intervals[i].start - intervals[i - 1].end - 1;
        if (free_size >= size && free_size < min_size)
        {
            min_size = free_size;
            idx = intervals[i - 1].end + 1;
        }
    }

    cout << idx << endl;
}
```

### [字典树(前缀树)](https://www.luogu.com.cn/problem/P8306)

**前缀树的3个基本性质：**

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// 前缀树节点
struct TrieNode
{
    TrieNode() : count(0), prefix(0) {}
    int count;  // 以当前字符结尾的单词数量
    int prefix; // 以当前节点之前的字符串为前缀的单词数量
    unordered_map<int, TrieNode *> next;
};

// 前缀树
class TrieTree
{
public:
    TrieTree() : root(new TrieNode()) {}

    void insert(string &word)
    {
        TrieNode *node = root;
        for (char &c : word)
        {
            if (!node->next[c - 'a'])
            {
                node->next[c - 'a'] = new TrieNode();
            }
            node = node->next[c - 'a'];
            node->prefix++;
        }

        node->count++;
    }

    // 查找字典树中有多少个单词是以word为前缀(可以等于word)
    int search(string &word)
    {
        TrieNode *node = root;

        for (char &c : word)
        {
            if (!node->next[c - 'a'])
                return 0;
            node = node->next[c - 'a'];
        }

        return node->prefix;
    }

private:
    TrieNode *root;
};

int main()
{
    int t, n, q;
    cin >> t >> n >> q;

    TrieTree trie_tree;
    string word;
    for (int k = 0; k < t; ++k)
    {
        for (int i = 0; i < n; ++i)
        {
            cin >> word;
            trie_tree.insert(word);
        }

        for (int i = 0; i < q; ++i)
        {
            cin >> word;
            cout << trie_tree.search(word) << endl;
        }
    }

    return 0;
}
```



### [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

思路：动态规划

由于负负得正，因此不仅得记录当前最大乘积，同时也得记录最小乘积

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // minDp[i]: 以nums[i]结尾的子数组最小乘积
        vector<int> minDp(n, 0);
        // maxDp[i]: 以nums[i]结尾的子数组最大乘积
        vector<int> maxDp(n, 0);

        minDp[0] = maxDp[0] = nums[0];
        for (int i = 1; i < n; ++i) {
            minDp[i] = min(nums[i],
                           min(nums[i] * minDp[i - 1], nums[i] * maxDp[i - 1]));
            maxDp[i] = max(nums[i],
                           max(nums[i] * maxDp[i - 1], nums[i] * minDp[i - 1]));
        }

        return *max_element(maxDp.begin(), maxDp.end());
    }
};
```

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

“下一个排列” 的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。



思路：

将低位的尽可能小的`大数`和前面的`小数`交换，然后使后面的数字升序。

`寻找小数：`从右往左扫描数组，找到第一个nums[i]<nums[i+1]的下标i，nums[i]就是`小数`，下标i+1及其后面的元素中满足大于nums[i]的元素中的最小值就是`大数`，然后再让nums[i+1,,n]升序

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        // 原数组是降序数列，已经是最大了，返回最小序列
        if (i < 0) {
            sort(nums.begin(), nums.end());
            return;
        }

        // 此时nums[i]就是小数
        // 找到尽可能小的大数
        int j = n - 1;
        // min_big_idx初始化要选择一个肯定大于nums[i]的值对应下标，不然会出现选了个nums[i+1,n-1]中的最小
        // 值，导致无法正确更新min_big_idx
        int min_big_idx = i + 1;
        while (j > i) {
            if (nums[j] > nums[i] && nums[j] < nums[min_big_idx]) {
                min_big_idx = j;
            }
            --j;
        }

        // 交换大小数
        swap(nums[i], nums[min_big_idx]);

        // 让nums[i+1,n-1]升序，使其最小
        sort(nums.begin() + i + 1, nums.end());
    }
};
```



### 小于n的最大值

**题目要求：**给定一个数组arr=[2,3,4,5],N=2345,求使用arr中的数字，组成一个不大于N的最大的数字。arr中的数字可以多次使用。

思路：回溯+贪心

从高位开始遍历，对每一位先尝试使用相同数字，除了最后一位。如果没有相同的数字时，尝试是否有比当前数字更小的，有的话选更小的数字里最大的，剩下的用最大数字。都没有就向前回溯看前一个有没有更小的。如果一直回溯到第一个数字都没有更小的数字，就用位数更少的全都是最大数字的数。





### 二叉树先、中、后序遍历（迭代）

**先序遍历：**

```cpp
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;

    if (!root)
        return res;

    stack<TreeNode*> stk;
    stk.push(root);

    // 遍历顺序：中左右
    while (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        res.emplace_back(node->val);
        // 先加入右节点，再加入左节点，这样出栈的顺序才是先左后右
        if(node->right)stk.emplace(node->right);
        if(node->left)stk.emplace(node->left);
    }

    return res;
}
```



**中序遍历**

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    if (!root)
        return res;

    stack<TreeNode*> stk;
    TreeNode* cur = root;

    // 遍历顺序：左中右
    // 先遍历到最左节点，然后开始处理节点
    while (cur || !stk.empty()) {
        if (cur) {
            stk.push(cur);
            cur = cur->left;
        }else{
            cur=stk.top();
            stk.pop();
            res.emplace_back(cur->val);
            cur=cur->right;
        }
    }

    return res;
}
```



**后序遍历**

![image-20240324201601573](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240324201601573.png)

```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    if (!root)
        return res;

    stack<TreeNode*> stk;
    stk.push(root);

    // 后序遍历顺序：左右中
    // 先序遍历顺序是：中左右
    // 切换左右子节点入栈顺序后 -> 中右左
    // 反转数组 -> 左右中，就变成后序顺序了
    while(!stk.empty()){
        TreeNode*node=stk.top();
        stk.pop();
        res.emplace_back(node->val);
        if(node->left)stk.emplace(node->left);
        if(node->right)stk.emplace(node->right);
    }

    reverse(res.begin(),res.end());
    return res;
}
```



**总结：**

先序遍历是最简单的，因为处理节点的顺序和遍历节点的顺序一致。

中序遍历需要先遍历到最左节点，然后将值加入结果数组，再去查看其右子树。

后序遍历和先序遍历的顺序部分一致，因此可以通过修改先序遍历中左右子节点的入栈顺序使得结果数组的顺序是中右左，再将其反转后就变成了左右中，也就是后序遍历顺序了

`先序最简单、中序独有处理逻辑、后序靠先序`





### [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

思路：BFS（队列）

**所谓广度优先搜索，就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，最后广度优先搜索找到的路径就是从起点开始的最短合法路径**。



`上下左右相邻的新鲜橘子就是该腐烂橘子尝试访问的同一层的节点，路径长度就是新鲜橘子被腐烂的时间`

```cpp
class Solution {
public:
    int cnt;                 // 当前新鲜橘子数量
    vector<vector<int>> dis; // 当前橘子被污染的时间
    vector<int> dir_x{0, 0, -1, 1};
    vector<int> dir_y{-1, 1, 0, 0};

    int orangesRotting(vector<vector<int>>& grid) {
        dis.resize(10, vector<int>(10, -1));
        queue<pair<int, int>> que;
        int n = grid.size(), m = grid[0].size();
        int ans = 0;

        // 把初始腐烂的橘子(第一层)加到队列中并初始化腐烂时间和记录新鲜橘子数量
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 2) {
                    dis[i][j] = 0;
                    que.push({i, j});
                } else if (grid[i][j] == 1) {
                    cnt++;
                }
            }
        }

        // 一层一层遍历，相当于将队列中的腐烂橘子向外扩
        while (!que.empty()) {
            auto rotted = que.front();
            que.pop();
            int x = rotted.second;
            int y = rotted.first;
            for (int i = 0; i < 4; i++) {
                int tx = x + dir_x[i];
                int ty = y + dir_y[i];
                // 判断是否越界、空格单元、已腐烂
                if (tx < 0 || tx >= m || ty < 0 || ty >= n ||
                    grid[ty][tx] == 0 || dis[ty][tx] != -1)
                    continue;

                // 腐烂橘子然后加入到队列中
                cnt--;
                dis[ty][tx] = dis[y][x] + 1;
                ans = dis[ty][tx];
                que.push({ty, tx});
            }
        }

        return cnt ? -1 : ans;
    }
};
```



### [课程表](https://leetcode.cn/problems/course-schedule/)

思路：拓扑序列BFS（队列）

判断是否为有向无环图，有环就不可能完成所有课程
将入度为0的节点加入队列中，消除它们的出边，消除后如果终点入度变为0，就继续加入队列，最后判断所有加入过队列的节点总和是否等于课程数

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // edges[i][j]: i的前置课是j，i是终点，j是起点
        vector<vector<int>> edges(numCourses, vector<int>());
        // indeg[i]: i课的入度
        vector<int> indeg(numCourses, 0);

        for (int i = 0; i < prerequisites.size(); i++) {
            edges[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
            ++indeg[prerequisites[i][0]];
        }

        queue<int> que;
        int visited = 0;
        for (int i = 0; i < indeg.size(); i++) {
            if (indeg[i] == 0) {
                que.push(i);
                visited++;
            }
        }

        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            for (int i = 0; i < edges[cur].size(); i++) {
                if (--indeg[edges[cur][i]] == 0) {
                    que.push(edges[cur][i]);
                    visited++;
                }
            }
        }

        return visited == numCourses;
    }
};
```

### [比特位计数](https://leetcode.cn/problems/counting-bits/)

思路：x二进制1的个数比x&(x-1)的二进制1的个数多1个，所以可以使用动态规划

x:          `1011000`

x-1:       `1010111`

x&(x-1):`1010000`

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            ans[i] = ans[i & (i - 1)] + 1;
        }
        return ans;
    }
};
```

### [交替位二进制数](https://leetcode.cn/problems/binary-number-with-alternating-bits/)

```cpp
class Solution {
public:
    bool hasAlternatingBits(int n) {
        // 假设n右移一位后是x，如果n是01交替的二进制数，那么n^x应该全是1，再加1之后就只有最高位是1
        int x = n >> 1;
        long long m = (n ^ x) + 1LL; // 为防止溢出，用long long接收
        // 使m的1的个数减1，那么m的值应该是0
        m = m & (m - 1);
        return m == 0;
    }
};
```

### [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

可以优化成常数空间复杂度，维护两个变量就行了

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 每天的状态要么是持有股票，要么是不持有股票
        // dp[i][0]: 第i天持有股票的最大利润
        // dp[i][1]: 第i天不持有股票的最大利润
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            // 可能是前面买的，也可能是当天买的
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            // 可能是前面卖的，也可能是今天卖的
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
		
        // 最后一天肯定不持有股票才是最大利润
        return dp[n - 1][1];
    }
};
```

### [买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)



可以优化成常数空间复杂度，维护4个变量就行了

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();

        /*
        每天的状态:
        0.第一次买入股票dp[i][0]
        1.第一次卖出股票dp[i][1]
        2.第二次买入股票dp[i][2]
        3.第二次卖出股票dp[i][3]
        */
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = -prices[0];
        dp[0][3] = 0;

        for (int i = 1; i < n; i++) {
            // 可能之前就买入，也可能今天第一次买入，本金是0
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            // 可能之前就卖出，也可能今天第一次卖出，利润建立在第一次买入之上
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            // 可能之前就买入，也可能今天第二次买入，本金是第一次卖出的最大利润
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] - prices[i]);
            // 可能之前就卖出，也可能今天第二次卖出，利润建立在第二次买入之上
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] + prices[i]);
        }

        return dp[n - 1][3];
    }
};
```

买卖股票的整体思路就是弄清楚每天有多少个状态，而这些状态下的最大利润可以通过前一天的哪些状态推得，比如如果有冷却期的情况下，如果要当天买入的话只能在冷却期的后一天买入

### [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

思路：

利用二叉搜索树的中序遍历是升序的特性，处理到的每一个节点是在升序序列中是上一个节点的后一位，因此cur就可以加1，当cur==k时，就代表当前节点是第k小的元素

拓展：`二叉搜索树中第K大的元素`

中序遍历是左中右，我们变一下递归顺序，转变成右中左，这样就成了降序了，因此只需要把inorder(node->right,k)和inorder(node->left,k)交换一下顺序即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int cur;
    int ans;

    void inorder(TreeNode* node, int k) {
        if (!node)
            return;
        inorder(node->left, k);
        cur++;
        if (cur == k)
            ans = node->val;
        if (cur > k)
            return;
        inorder(node->right, k);
    }

    int kthSmallest(TreeNode* root, int k) {
        cur = 0;
        ans = 0;
        inorder(root, k);
        return ans;
    }
};
```



### [ 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

思路：归并排序

```cpp
class Solution {
public:
    int ans = 0;
	
    // 合并两个有序数组[left,mid],[mid+1,right]
    void merge(vector<int>& record, int left, int mid, int right) {
        int n = right - left + 1;
        vector<int> vec(n, 0);

        int idx = 0;
        int start1 = left, start2 = mid + 1;
        while (start1 <= mid && start2 <= right) {
            if (record[start1] <= record[start2]) {
                vec[idx++] = record[start1++];
            } else {
                // record[start1+1...mid]>record[start1]>record[start2]
                // 逆序对有(record[start],record[start2])..record[mid],record[start2])
                ans += mid - start1 + 1;
                vec[idx++] = record[start2++];
            }
        }

        while (start1 <= mid) {
            vec[idx++] = record[start1++];
        }
        while (start2 <= right) {
            vec[idx++] = record[start2++];
        }

        for (int k = 0; k < vec.size(); k++) {
            record[left + k] = vec[k];
        }
    }

    void mergeSort(vector<int>& record, int left, int right) {
        if (left < right) {
            int mid = left + ((right - left) >> 1);
            mergeSort(record, left, mid);
            mergeSort(record, mid + 1, right);
            merge(record, left, mid, right);
        }
    }

    int reversePairs(vector<int>& record) {
        mergeSort(record, 0, record.size() - 1);
        return ans;
    }
};
```

### [最长公共子序列(LCS)](https://leetcode.cn/problems/qJnOS7/)

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size();
        int len2 = text2.size();

        // 以text1[0,i-1]和text2[0,j-1]子串的最长公共子序列长度
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));

        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 删掉text1[i-1]或删掉text2[j-1]
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[len1][len2];
    }
};
```



### [最长递增子序列(LIS)](https://leetcode.cn/problems/longest-increasing-subsequence/)

**普通解法**

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        int ans = 1;
        // dp[i]:以nums[i]结尾的最长严格递增子序列
        vector<int> dp(n, 1);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ans = max(ans, dp[i]);
        }

        return ans;
    }
};
```

**进阶解法**：贪心

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // 因为如果要有最长的递增子序列，那么就要让值的增长速度尽可能慢，因此就要值尽可能小
        // g[i]: 长度为i+1的递增子序列中尾元素的最小值
        vector<int> g;

        /*
        g肯定是递增的
        反证法：
        假设g不递增，g[i]<g[i-1]，既然小的数都可以是长度为i+1的递增子序列的尾元素，
        那就必然存在着一个小于g[i]的数为长度是i的递增子序列的尾元素即g[i-1]，与条件矛盾，所以g不递增不成立
        */

        for (auto& x : nums) {
            // 从g中找到第一个大于等于x的元素
            // 如果元素可以重复，即非严格递增，那么改为upper_bound即可
            auto it = lower_bound(g.begin(), g.end(), x);
            if (it == g.end()) {
                // g中不存在大于等于x的元素，说明x可以是扩张子序列的尾元素
                g.emplace_back(x);
            } else {
                // it指向的元素是g中第一个大于等于x的元素，假设为g[j]
                // 此时g[j] >= x > g[j-1]
                // 更新最小值
                *it = x;
            }
        }

        // g大小的最大值就是最长递增子序列的长度
        return g.size();
    }
};

// 优化空间，原地修改
// 把[nums.begin(),end]当作g数组，由于x遍历到的元素要么是end指向的元素，要么在end后面，所以*it=x必然不会篡改x
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        auto end = nums.begin();
        for (int x : nums) {
            auto it = lower_bound(nums.begin(), end, x);
            *it = x;
            if (it == end)
                end++;
        }
        return end - nums.begin();
    }
};
```





### [合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
        // 两链表都为空，或其中一个链表为空
        if (!head1 && !head2)
            return nullptr;
        else if (!head1)
            return head2;
        else if (!head2)
            return head1;

        ListNode* dummy_head = new ListNode(-1);
        ListNode* cur_dummy = dummy_head;
        ListNode* cur1 = head1;
        ListNode* cur2 = head2;

        while (cur1 && cur2) {
            if (cur1->val < cur2->val) {
                cur_dummy->next = cur1;
                cur1 = cur1->next;
            } else {
                cur_dummy->next = cur2;
                cur2 = cur2->next;
            }
            cur_dummy = cur_dummy->next;
        }

        if (cur1)
            cur_dummy->next = cur1;
        if (cur2)
            cur_dummy->next = cur2;

        return dummy_head->next;
    }

    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        if (left > right)
            return nullptr;
        else if (left == right)
            return lists[left];
        int mid = left + ((right - left) >> 1);
        return mergeTwoLists(merge(lists, left, mid),
                             merge(lists, mid + 1, right));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```



### 词频统计topK

思路：分治（由于内存不够，分批处理数据）+大顶堆（大小为k，通过词频来比较）



### [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 哈希表(记录词频)+小顶堆(排序词频)
        unordered_map<int, int> occurences;
        for (int& n : nums) {
            occurences[n]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>,
                       greater<pair<int, int>>>
            que;

        for (auto& p : occurences) {
            if (que.size() == k) {
                if (p.second > que.top().first) {
                    que.pop();
                    // 队列的emplace是传入构造元素的参数，而不是直接传入元素，这样可以在emplace内部构造，而不是拷贝
                    que.emplace(p.second, p.first);
                }
            } else {
                que.emplace(p.second, p.first);
            }
        }

        vector<int> ans(k);
        int i = 0;
        while (!que.empty()) {
            ans[i++] = que.top().second;
            que.pop();
        }

        return ans;
    }
};
```



### [划分字母区间](https://leetcode.cn/problems/partition-labels/)

对于只有小写字母的哈希可以用26数组

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int n = s.size();
        // 记录每个字母最后出现的下标
        unordered_map<char, int> last_idx;
        for (int i = 0; i < n; i++) {
            last_idx[s[i]] = i;
        }

        int max_idx = 0; // 当前处理片段里的所有字母的最后一个下标中的最大值
        int len = 0; // 当前片段长度
        vector<int> res;

        for (int i = 0; i < n; i++) {
            max_idx = max(max_idx, last_idx[s[i]]);
            len++;
            // 当前片段的所有字母的最后一个下标都不超过i，那么就可以分段了
            if (i == max_idx) {
                res.emplace_back(len);
                len = 0;
                max_idx = 0;
            }
        }

        return res;
    }
};
```



### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode* head) {
        if (!head || !head->next)
            return false;
        ListNode* fast = head;
        ListNode* slow = head;
        do {
            fast = fast->next->next;
            slow = slow->next;
            // 有环，二者必然会相遇
            if (slow == fast)
                return true;
        } while (fast && fast->next);

        return false;
    }
};
```

### [最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        int ans = 0;

        // 以nums1[i-1]结尾的nums1子数组和以nums2[j-1]结尾的nums2子数组中最长公共子数组的长度
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = max(ans, dp[i][j]);
            }
        }

        return ans;
    }
};

// 空间优化
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        int ans = 0;

        vector<int> dp(m + 1, 0);
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= 1; j--) {
                if (nums1[i - 1] == nums2[j - 1])
                    dp[j] = dp[j - 1] + 1;
                else // 这里也必须更新，否则会沿用前面版本的数组，不准确了
                    dp[j] = 0; // 注意这里！！！
                ans = max(ans, dp[j]);
            }
        }

        return ans;
    }
};
```



### [全排列（不包含重复元素）](https://leetcode.cn/problems/VvJkup/)

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> visited;

    void dfs(vector<int>& nums, int k) {
        // 递归终止条件：全部数都已加入
        if (k == nums.size()) {
            res.emplace_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (visited[i])
                continue;
            path.emplace_back(nums[i]);
            visited[i] = true;
            dfs(nums, k + 1);
            path.pop_back();
            visited[i] = false;
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        visited.resize(nums.size(), false);
        dfs(nums, 0);
        return res;
    }
};
```



### [全排列 II （包含重复元素）](https://leetcode.cn/problems/7p8L0Z/)

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> visited;

    void dfs(vector<int>& nums, int k) {
        if (k == nums.size()) {
            res.emplace_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            // 去重
            if (visited[i])
                continue;
            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])
                continue;

            path.emplace_back(nums[i]);
            visited[i] = true;
            dfs(nums, k + 1);
            path.pop_back();
            visited[i] = false;
        }
    }

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        res.clear();
        path.clear();
        visited.resize(nums.size(), false);

        // 排序数组，让相同元素聚集到一起，方便去重
        sort(nums.begin(),nums.end());
        dfs(nums, 0);
        return res;
    }
};
```



### [多数元素](https://leetcode.cn/problems/majority-element/)

思路：摩尔投票

维护两个变量t和c，t是当前票数最多的值，c是t的票数，假设x是当前遍历到的元素

- c==0：更新候选元素t
- c>0：
  - t!=x：c--，反对
  - t==x：c++，支持

所以，哪个元素的总数最多，最终一定会胜出，只适用于元素总数超过一半的情况

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int t, c = 0;
        for (int& x : nums) {
            if (c == 0) {
                t = x;
                c = 1;
            } else if (t == x)
                c++;
            else
                c--;
        }

        return t;
    }
};
```



### [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

思路：快慢指针找环入口

**规则：**

`slow=nums[slow]`

`fast=nums[nums[fast]]`

由于存在一个唯一的重复元素，因此必然会成环，而环的入口就是该重复元素，因为是唯一一个入度=2的元素(有两个下标对应的元素值都是该重复元素值)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        fast = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
};
```



### [颜色分类](https://leetcode.cn/problems/sort-colors/)

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();

        // p0: 当前红色应该存放的下标
        // p2: 当前蓝色应该存放的下标
        int p0 = 0, p2 = n - 1;
        // i不能超过p2，因为p2后面都是蓝色了，不用处理
        for (int i = 0; i <= p2; i++) {
            // 把蓝色放到p2，nums[p2]可能已经是蓝色，所以需要不断交换，直到交换的nums[p2]不是蓝色
            while (i <= p2 && nums[i] == 2) {
                swap(nums[i], nums[p2--]);
            }

            // 如果是红色，要放到p0
            if (nums[i] == 0) {
                swap(nums[i], nums[p0++]);
            }
        }
    }
};
```



### [篮球游戏](https://hydro.ac/d/HWOD2023/p/OD429)

思路：模拟+双端队列



```cpp
#include <iostream>
#include <deque>
using namespace std;

int main()
{
    string pushStream;
    string popStream;
    getline(cin, pushStream);
    getline(cin, popStream);

    deque<int> push_list;
    deque<int> pop_list;

    for (int i = 0; i < pushStream.size(); i++)
    {
        if (pushStream[i] == ',')
            continue;

        push_list.push_back(atoi(&pushStream[i]));
        pop_list.push_back(atoi(&popStream[i]));
    }

    string res;
    deque<int> cur_deq;
    int n = push_list.size();

    for (int i = 0; i < n; i++)
    {
        // 只能从右边加入篮球
        cur_deq.push_back(push_list[i]);
        while (!cur_deq.empty())
        {
            // 可以从左边取出
            if (pop_list.front() == cur_deq.front())
            {
                res += "L";
                cur_deq.pop_front();
                pop_list.pop_front();
            }
            // 可以从右边取出篮球
            else if (pop_list.front() == cur_deq.back())
            {
                res += "R";
                cur_deq.pop_back();
                pop_list.pop_front();
            }
            else
            {
                break;
            }
        }
    }

    cout << (res.size() == n ? res : "NO") << endl;
}
```

### [二叉搜索树与双向链表](https://www.nowcoder.com/share/jump/3478599141712370139515)

关键点：

由于是双向链表，因此需要记录前驱节点，而每处理一个节点，就需要把前驱节点更新为该节点

```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
  public:
    TreeNode* preNode = nullptr; // 前驱节点

    void inorder(TreeNode* node) {
        if (!node)return;
        inorder(node->left);
        // 处理当前节点
        node->left = preNode;
        if (preNode) {
            preNode->right = node;
        }
        preNode = node;
        inorder(node->right);
    }

    TreeNode* Convert(TreeNode* pRootOfTree) {
        if (!pRootOfTree)return nullptr;

        // 链表开头是值最小的节点
        TreeNode* new_head = pRootOfTree;
        while (new_head->left)new_head = new_head->left;

        inorder(pRootOfTree);

        return new_head;
    }
};
```

### [二叉树的下一个结点](https://www.nowcoder.com/share/jump/3478599141712372163684)

关键点：

记录上一个节点，通过next指针找到根节点，然后按中序遍历的顺序，只要上一个节点等于传入的pNode，那么当前节点就是pNode的下一个节点

```cpp
/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {

    }
};
*/
class Solution {
  public:
    TreeLinkNode* preNode = nullptr;
    TreeLinkNode* cur_preNode = nullptr;
    TreeLinkNode* res = nullptr;

    void inorder(TreeLinkNode* node) {
        if (!node)return;
        // 已经找到结果了，不用继续遍历了
        if (res)return;
        inorder(node->left);
        if (cur_preNode == preNode)res = node;
        cur_preNode = node;
        inorder(node->right);
    }

    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        // 找到根节点
        preNode = pNode;
        while (pNode->next)pNode = pNode->next;

        inorder(pNode);
        return res;
    }
};
```

### [序列化二叉树](https://www.nowcoder.com/share/jump/3478599141712377652030)

关键点：

序列化的时候是通过','来区分每个节点，从队列中取出一个节点，然后处理其左右节点即可，那么反序列化也是一样，从队列中取出一个节点然后处理其左右节点即可

```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
#include <cstdlib>
#include <cstring>
#include <queue>
#include <string>
#include <vector>
class Solution {
  public:
    char* Serialize(TreeNode* root) {
        string res;
        if (!root)return nullptr;

        queue<TreeNode*>que;
        que.push(root);
        while (!que.empty()) {
            for (int i = que.size(); i > 0; i--) {
                TreeNode* node = que.front();
                que.pop();
                if (node) {
                    // 用to_string，因为一个char表示不了大于一位的数
                    res += to_string(node->val);
                    res.push_back(',');// 用','分割开每个节点（节点值数位可能会大于1）
                    que.push(node->left);
                    que.push(node->right);
                } else {
                    res.push_back('#');
                    res.push_back(',');
                }
            }
        }

        char* ret = new char[res.size() + 1];
        strcpy(ret, res.c_str());

        return ret;
    }
    TreeNode* Deserialize(char* str) {
        if (!str)return nullptr;

        string s(str);
        if (str[0] == '#')return nullptr;

        queue<TreeNode*>que;
        TreeNode* root = new TreeNode(atoi(s.c_str()));
        s = s.substr(s.find_first_of(',') + 1);
        que.push(root);

        while (!que.empty() && !s.empty()) {
            TreeNode* node = que.front();
            que.pop();

            if (s[0] == '#') {
                node->left = nullptr;
                s = s.substr(2);
            } else {
                node->left = new TreeNode(atoi(s.c_str()));
                que.push(node->left);
                s = s.substr(s.find_first_of(',') + 1);
            }

            if (s[0] == '#') {
                node->right = nullptr;
                s = s.substr(2);
            } else {
                node->right = new TreeNode(atoi(s.c_str()));
                que.push(node->right);
                s = s.substr(s.find_first_of(',') + 1);
            }
        }

        return root;
    }
};
```

### 二叉搜索树的最近公共祖先

关键点：

不能只靠值的大小比较来判断是否是公共祖先，还要确保当前节点是p、q的根节点或根节点的祖宗节点

```cpp
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @param p int整型
     * @param q int整型
     * @return int整型
     */
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        if (!root)return -1;
        if ((p >= root->val && q <= root->val) || (p <= root->val &&
                q >= root->val)) {
            return root->val;
        } else if (p < root->val && q < root->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        return lowestCommonAncestor(root->right, p, q);
    }
};
```

### 在二叉树中找到两个节点的最近公共祖先

```cpp
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @param o1 int整型
     * @param o2 int整型
     * @return int整型
     */
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        if (!root)return -1;
        if (root->val == o1 || root->val == o2)return root->val;

        int left = lowestCommonAncestor(root->left, o1, o2);
        int right = lowestCommonAncestor(root->right, o1, o2);

        if (left == -1)return right;
        if (right == -1)return left;

        // left和right都不等于-1，说明o1和o2分别在root的左右子树，因此root就是最近的公共节点
        return root->val;
    }
};
```

### [HJ16 购物单](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, m;
    cin >> N >> m;
    // 由于价格是10的整数倍，处理一下以降低空间/时间复杂度
    N /= 10;
    // 附件的价格应该存放到主件对应数组中去，因为是有联系的
    // 价格，最多只会有两件附件
    vector<vector<int>>prices(61, vector<int>(3, 0));
    // 满意度
    vector<vector<int>>priceMultiplyPriority(61, vector<int>(3, 0));
    for (int i = 1; i <= m; ++i) {
        int v, p, q;
        cin >> v >> p >> q;
        v /= 10;
        p *= v;
        if (q == 0) {
            prices[i][0] = v;
            priceMultiplyPriority[i][0] = p;
        } else {
            if (prices[q][1] == 0) {
                // 无附件
                prices[q][1] = v;
                priceMultiplyPriority[q][1] = p;
            } else {
                // 有一个附件
                prices[q][2] = v;
                priceMultiplyPriority[q][2] = p;
            }
        }
    }

    // 使用分组背包
    vector<vector<int>>dp(m + 1, vector<int>(N + 1, 0));
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= N; ++j) {
            int v0 = prices[i][0];
            int v1 = prices[i][1];
            int v2 = prices[i][2];
            int p0 = priceMultiplyPriority[i][0];
            int p1 = priceMultiplyPriority[i][1];
            int p2 = priceMultiplyPriority[i][2];
            // 购买主件
            dp[i][j] = j >= v0 ? max(dp[i - 1][j], dp[i - 1][j - v0] + p0) : dp[i - 1][j];
            // 购买第一件附件
            dp[i][j] = j >= (v0 + v1) ? max(dp[i][j],
                                            dp[i - 1][j - v0 - v1] + p0 + p1) : dp[i][j];
            // 购买第二件附件
            dp[i][j] = j >= (v0 + v2) ? max(dp[i][j],
                                            dp[i - 1][j - v0 - v2] + p0 + p2) : dp[i][j];
            // 购买两件附件
            dp[i][j] = j >= (v0 + v1 + v2) ? max(dp[i][j],
                                                 dp[i - 1][j - v0 - v1 - v2] + p0 + p1 + p2) : dp[i][j];
        }
    }

    cout << dp[m][N] * 10 << endl;

    return 0;
}
// 64 位输出请用 printf("%lld")
```

### [HJ17 坐标移动](https://www.nowcoder.com/practice/119bcca3befb405fbe58abe9c532eb29?tpId=37&tqId=21240&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

```cpp
#include <iostream>
#include <bits/stdc++.h>
#include <regex>
#include <sstream>
#include <string>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    string s, t;
    
    // 获取整个字符串
    while (getline(cin, s)) {
        stringstream ss(s);
        pair<int, int>p(0, 0);
        // 将ss分段赋给t，分隔符是;，即t是两个;中间的内容
        while (getline(ss, t, ';')) {
            if (t.empty())continue;
            string _ = t.substr(1);
            // 正则表达式匹配距离
            if (regex_match(_, regex("[0-9]*"))) {
                switch (t[0]) {
                    case 'A':
                        p.first -= stoi(_);
                        break;
                    case 'D':
                        p.first += stoi(_);
                        break;
                    case 'W':
                        p.second += stoi(_);
                        break;
                    case 'S':
                        p.second -= stoi(_);
                        break;
                    default:
                        break;
                }
            }
        }
        cout << p.first << "," << p.second << endl;
    }
}
// 64 位输出请用 printf("%lld")
```

### [HJ27 查找兄弟单词](https://www.nowcoder.com/share/jump/3478599141712569598773)

```cpp
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

bool isBrother(const string& s1, const string& s2) {
    if (s1.size() == s2.size()) {
        // 不能是同一个
        if(s1==s2)return false;

        unordered_map<char, int>mp1;
        unordered_map<char, int>mp2;

        for (auto& c : s1) {
            mp1[c]++;
        }
        for (auto& c : s2) {
            mp2[c]++;
        }

        for (auto& p : mp1) {
            if (p.second != mp2[p.first])return false;
        }

        return true;
    }
    return false;
}

int main() {
    int n = 0;
    while (cin >> n) {
        vector<string>words(n);
        for (int i = 0; i < n; ++i) {
            cin >> words[i];
        }

        string x;
        cin >> x;
        int k;
        cin >> k;

        vector<string>brothers;
        for (auto& word : words) {
            if (isBrother(word, x))brothers.emplace_back(word);
        }
        sort(brothers.begin(), brothers.end());

        cout << brothers.size() << endl;
        if (k < brothers.size()) {
            cout << brothers[k - 1] << endl;
        }
    }
}
// 64 位输出请用 printf("%lld")
```

### [HJ50 四则运算]()

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

string mp = "+-*/)]}";

bool cmp(char c1, char c2) {
    if (c1 == '(') {
        return false;
    } else if ((c1 == '+' || c1 == '-') && (c2 == '*' || c2 == '/')) {
        return false;
    }
    return true;
}

// 计算
void doCal(stack<double>& st, stack<char>& so) {
    double b = st.top();
    st.pop();
    double a = st.top();
    st.pop();
    char op = so.top();
    so.pop();
    if (op == '+')a = a + b;
    else if (op == '-')a = a - b;
    else if (op == '*')a = a * b;
    else if (op == '/')a = a / b;
    st.push(a);
}

int main() {
    string s;
    while (getline(cin, s)) {
        stack<double>st;
        stack<char>so;
        so.push('(');
        s += ')';
        bool nextIsOp = false;
        for (int i = 0; i < s.size(); ++i) {
            // 左括号
            if (s[i] == '{' || s[i] == '[' || s[i] == '(') {
                so.push('(');
            } 
            // 右括号 => 把括号里的内容都计算了
            else if (s[i] == ')' || s[i] == ']' || s[i] == '}') {
                while (so.top() != '(')doCal(st, so);
                so.pop();
            } 
            // 运算符 => 比较和栈顶运算符的优先级，如果s[i]优先级较低，需要先计算栈里的
            else if (nextIsOp) {
                while (cmp(so.top(), s[i]))doCal(st, so);
                so.push(s[i]);
                nextIsOp = false;
            }
            // 数字 => 将整个数值压栈
            else {
                int j = i;
                if (s[j] == '-' || s[j] == '+')i++;
                while (mp.find(s[i]) == mp.npos)i++;
                string t = s.substr(j, i - j);
                st.push((double)stoi(t));
                i--;
                nextIsOp = true;
            }
        }
        cout << st.top() << endl;
    }
}
// 64 位输出请用 printf("%lld")
```



## C++

下面这段代码会在编译时，因为调用show函数时，会调用A的拷贝构造函数，而A的拷贝构造函数是私有的无法访问到，因此报错

```cpp
#include <iostream>
using namespace std;
class A
{
    A(const A &) {}

public:
    int num;
    A() { num = 5; }
};
void show(A a)
{
    cout << a.num << endl;
}

int main()
{
    A a;
    show(a);
    return 0;
}
```

### 底层const、顶层const

```cpp
// iter: T* const
vector<T>::iterator iter = vec.begin();
// cIter: const T*
vector<T>::const_iter cIter=vec.begin();
```



### 左值引用和右值引用

![image-20240320151340925](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151340925.png)

![image-20240320151612193](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320151612193.png)

- **左值**: 可取地址的

- **右值**:不是左值就是右值，即不可取地址的

  - **纯右值**: 纯粹的临时值（即使指代的对象是持久存在的），不跟对象关联的字面量值

  - **将亡值**: 一般是指类型为右值引用类型的返还值，T&&类型的函数返回值、std::move返回值

    `std::move`实现方式和`std::forward`类似，也是通过完美引用和强制类型转换
    
    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

- **左值引用**: 对左值进行引用

- **右值引用**: 对右值进行引用

```cpp
int &a = 2; // 左值引用绑定到右值，编译失败
int b = 2; // b是非常量左值
const int &c = b; // 常量左值引用绑定到非常量左值，编译通过
const int d = 2; // d是常量左值
const int &e = c; // 常量左值引用绑定到常量右值，编译通过
const int &b = 2; // 常量左值引用绑定到右值，编译通过

右值引用通常不能绑定到任何左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
```



> 为什么要引入右值引用？

- `替代需要销毁对象的拷贝，提高效率`：比如vector的push_back和emplace_back方法，push_back方法是先生成一个对象，然后将该对象拷贝到尾部。而emplace_back方法如果传入的是右值的话，那么会直接在尾部构造元素，而不是拷贝一个构造好的旧对象后再把旧对象销毁，避免不必要的拷贝

- `移动含有不能共享资源的类对象`：比如unique_ptr中包含不能被共享的指针对象，这些类对象不能被拷贝但是可以被移动，原理是先通过std::move把一个左值转变为右值后，再进行右值引用，因为转换完之后是将亡值，传入的左值把所有权都交出去了

  **示例**

  ```cpp
  unique_ptr<int> up = make_unique<int>(10);
  // auto up1 = up; 错误，unique_ptr是独占型指针，不能多个unique_ptr对象共享同一指针
  auto up2(move(up));
  ```

  



### 内存对齐

`内存对齐规则：类成员变量的起始地址偏移量必须是其大小的整数倍`

```cpp
// 24
// A的内存分布，对齐double(8)：
// [a][b1][b2][b3][b4][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
struct A {
	char a;
	int b;
	double c;
	char d;
};

// 32
/*
A的内存分布，对齐double(8)：
[a][b1][b2][b3][b4][0][0][0] [e1][e2][e3][e4][0][0][0][0] [c1][c2][c3][c4][c5][c6][c7][c8] [d]0][0][0][0][0][0][0]
*/
struct B {
	char a;
	int b;
    int e;
	double c;
	char d;
};
```

> 为什么需要内存对齐？

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

  假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。
  现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。





### 纯虚函数、虚函数、虚函数表

https://zhuanlan.zhihu.com/p/75172640

https://zhuanlan.zhihu.com/p/270614081





**纯虚函数**

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，继承该类的派生类必须实现该函数



何时使用纯虚函数：

（1）当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；

（2）这个方法必须在派生类(derived class)中被实现；

  如果满足以上两点，可以考虑将该方法申明为纯虚函数.

`一个类如果有纯虚函数，那么它就是抽象类，不能被实例化`

**纯虚函数的作用：**

- 提供接口规范
- 实现多态



**虚函数、虚函数表**

虚函数：被virtual修饰的类成员函数

每个包含了虚函数的类都包含了一张虚函数表

当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。



```cpp
// 类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318203825639.png" alt="image-20240318203825639" style="zoom:150%;" />



虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。



> 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

<img src="https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205416612.png" alt="image-20240318205416612" style="zoom:150%;" />



**子类的虚表**

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图所示。

![image-20240318205547970](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318205547970.png)

`对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数`



```cpp
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

![image-20240318210458446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318210458446.png)





示例代码：

```cpp
#include<iostream>
using namespace std;

class Base {
public:
	Base(){}
	virtual ~Base(){}
	virtual void func() {
		cout << "base func" << endl;
	}
};

class Derived :public Base {
public:
	Derived(){}
	virtual ~Derived(){}
	virtual void func() {
		cout << "derived func" << endl;
	}
	virtual void func2() {};
};

int main() {}
```



`Derived类内存分布`

一个对象所占内存是其所有成员属性所占内存的总和内存对齐后的大小，如果有虚函数的话还要在加上虚函数表指针

一个派生类所占内存包括它所有的基类大小加上它自己的成员属性的总和内存对齐后的大小，如果如果有虚函数的话还要再加上虚函数表指针

```
1>class Base	size(8):
1>	+---
1> 0	| {vfptr}
1>	+---
1>Base::$vftable@:
1>	| &Base_meta
1>	|  0
1> 0	| &Base::{dtor}
1> 1	| &Base::func

===================================================================================================================

1>class Derived	size(8):
1>	+---
1> 0	| +--- (base class Base)
1> 0	| | {vfptr}
1>	| +---
1>	+---
1>Derived::$vftable@:
1>	| &Derived_meta
1>	|  0
1> 0	| &Derived::{dtor}
1> 1	| &Derived::func
1> 2	| &Derived::func2
```

`派生类是从基类继承的虚函数表，就像继承其它成员属性一样，派生类不会再自己生成一张虚函数表，而对于派生类的虚函数，会在虚函数表中对应位置修改或添加虚函数指针，但虚函数是派生类独有(基类没有)时，会添加到该虚函数表中`





### static和const

`static`：

- 将具有**外部链接**属性的变量或函数转换为**内部属性**
- 将具有**自动存储期限**的变量转换为**静态存储期限**



`const`：

- const修饰的变量无法修改值
- const重载成员函数，这样非常量对象无法调用常量成员函数



### extern

如果想在多个文件之间共享const变量，必须在变量的声明（在不包含改变量的文件）前加上extern关键字



### const限定符

![image-20240319210655314](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240319210655314.png)





### 无符号与有符号的比较

![image-20240320134747641](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320134747641.png)



### 字符串相加

![image-20240320135448633](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135448633.png)

![image-20240320135506201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320135506201.png)



### 迭代器

vector的rbegin()方法会返回一个反向迭代器指向最后一个元素，该迭代器执行++操作会往前面移动一个元素

it->func() = (*it).func()



### 数组

![image-20240320144822974](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320144822974.png)



![image-20240320145742474](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320145742474.png)



![image-20240320150054220](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320150054220.png)





### 显示转换

- static_cast：static_cast的使用基本等价于隐式转换的一种类型转化运算符，可使用于需要明确隐式转换的地方。就相当于把隐式转换给明确写了出来而已。

  ![image-20240320152952804](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320152952804.png)

- const_cast：const_cast的大部分使用主要是将常量指针转换为常指针。常量指针指向的空间的内容不允许被修改，但是使用const_cast进行强制转换就可以修改。

  ![image-20240320153131766](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153131766.png)

- reinterpret_cast

  ![image-20240320153225174](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320153225174.png)

- dynamic_cast

  `dynamic_cast`是四个强制类型转换操作符中最特殊的一个，因为它支持`运行时`识别指针和引用。用于`类继承层次间的指针或引用转换`主要用于**安全的向下转型**，至于向上转型（子类的对象赋给父类的指针或引用）本身就是安全的，因此没必要使用dynamic_cast

```cpp
#include <iostream>
using namespace std;

class MyClass
{
public:
    void foo() { cout << "Non-const foo" << endl; }
    void foo() const { cout << "Const foo" << endl; }
};

int main()
{
    int i, j;

    // static_cast
    double slope = static_cast<double>(j) / i;
    void *p = nullptr;
    double *dp = static_cast<double *>(p);

    // const_cast
    const MyClass obj;
    obj.foo();                        // 调用const版本的foo
    const_cast<MyClass &>(obj).foo(); // 通过const_cast调用非const版本的foo

    // reinterpret_cast
    int *ip;
    char *pc = reinterpret_cast<char *>(ip);

    return 0;
}
```



### try语句块和异常处理

![image-20240320161334919](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320161334919.png)



![image-20240320181841608](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320181841608.png)



**寻找异常的处理代码过程**

![image-20240320182252095](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240320182252095.png)





### 万能引用、引用折叠、完美转发

**万能引用**

```cpp
void foo(int &&i){}; // i为右值引用

template <typename T>
void bar(T &&t) {} // t为万能引用

constexpr int get_val() { return 5; }
int &&x = get_val(); // x为右值引用
auto &&y = get_val(); // y为万能引用
```

右值引用只能绑定一个右值，而万能引用既能绑定左值，也能绑定右值



**引用折叠**

所谓的完能引用实际上是发生了类型推导，在这个推导的过程中，如果初始化的源对象是一个左值，则目标对象会推导出一个左值引用，反之如果源对象是一右值，则会推导出一个左值引用



引用折叠：C++11添加的一套引用叠加推导规则

有一个左值引用，那么最终类型就是左值引用（遇左则左）

![image-20240322190230326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322190230326.png)





万能引用+引用折叠用于实现完美转发，完美转发避免了额外的拷贝

一般来说，传个引用就可以避免拷贝了，但是由于引用是左值引用，所以当传入右值时就不行了。因此完美转发就实现了可以同时处理左值和右值



**完美转发**

示例代码：

```cpp
template<typename T>
void print(T & t){
    std::cout << "Lvalue ref" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "Rvalue ref" << std::endl;
}

template<typename T>
void testForward(T && v){
    //虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！
    print(v); //永远调用左值版本的print
    
    print(std::forward<T>(v)); //底层实际上就是static_cast<T&&>(v)
    
    print(std::move(v)); //永远调用右值版本的print

    std::cout << "======================" << std::endl;
}

int main(int argc, char * argv[])
{
    int x = 1;
    testForward(x); //实参为左值
    testForward(std::move(x)); //实参为右值
}
```

运行结果：

> ```text
> Lvalue ref
> Lvalue ref
> Rvalue ref
> /======================
> Lvalue ref
> Rvalue ref
> Rvalue ref
> /======================
> ```



本质问题在于无论是左值、右值在当作函数参数传递时，函数的参数在被使用时都会被当作左值，因为该参数在内存中已经有了位置


在STL中随处可见这种问题，C++11引入的emplace_back，它接受左值也接受右值作为参数，接着，它转调用construct函数，而construct函数转调用placement new，placement new根据传入的参数是左值还是右值再决定调用拷贝构造函数还是移动构造函数



`std::forward`实现如下：

```cpp
template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}
```





### emplace_back和push_back

```cpp
#include <iostream>
#include <vector>
using namespace std;

class A
{
public:
    A() = default;
    A(const A &rhs)
    {
        cout << "copy constructor" << endl;
    }
    A(A &&rhs)
    {
        cout << "move constructor" << endl;
    }
};

int main(int argc, char *argv[])
{
    vector<A> vec;
    vec.reserve(20);
    A temp;
	
    // 虽然temp2是右值引用，但它实际上是一个左值
    A &&temp2 = move(temp);
    cout << &temp2 << "\n"
         << &temp << endl;

    // 调用的构造函数，调用的vector的方法
    vec.push_back(temp);               // copy , push_back(const value_type& __x)
    vec.push_back(std::move(temp));    // move , push_back(value_type&& __x)
    vec.push_back(A());                // move , push_back(value_type&& __x)
    vec.emplace_back(temp);            // copy , emplace_back(_Args&&... __args);
    vec.emplace_back(std::move(temp)); // move , emplace_back(_Args&&... __args);
    vec.emplace_back(A());             // move , emplace_back(_Args&&... __args);
}
```

运行结果：

> ```text
> 0x61fddf
> 0x61fddf
> copy constructor
> move constructor
> move constructor
> copy constructor
> move constructor
> move constructor
> ```





### 封装、继承和多态

`封装`

**定义：**将数据和操作数据的方法结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互

**好处：**减少耦合、类内部的结构可以自由修改、更好控制类成员变量、隐藏属性和实现细节



`继承`

**定义：**可以使用已存在的类定义新类，新类可以定义新属性和新方法，但是不能选择性的继承父类的成员

**好处：**使用继承可以非常方便地复用之前的代码，大大提高开发效率

**多重继承：**一个派生类可以同时继承多个基类，由于可能会有成员命名冲突，因此对于同名成员，需要在前面加上类名和域解析符::



`多态`

**定义：**函数调用可以有多种形态

- 静态多态：函数重载和模版
- 动态多态：基类指针或引用调用重写虚函数（虚函数和继承）

**多态的构成条件：**

1. 必须通过基类的指针或引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类重写了该虚函数

**好处：**

假设现在有一个基类，类型是人，在源代码中，会调用人的说话方法，这是一个虚函数，但人可以分为多个国家的人，每个国家的语言不一样，我们只需要继承基类人，然后重写对应的说话方法，就可以实现不用改动源代码，而是在运行时会根据基类指针或引用实际绑定的值来调用到对应的函数。这样大大降低了新添功能的复杂度



### STL容器释放

STL容器释放时，会调用元素的析构函数。**但是如果元素类型是指针时，并不会释放指针，需要我们先遍历容器一个个释放后，才能释放容器**，可以存放智能指针，而不是普通指针



### struct和class的区别

唯一区别就是默认访问权限，class默认访问权限是private，而struct是public



### 可变数据成员

const对象可以改变一个可变成员的值

![image-20240323234802597](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240323234802597.png)



### 类的声明和定义

`在声明之后，定义之前，类为不完整类型，只能用于指向该类型的指针或引用或者用于声明（不是定义）使用该类型做为形参类型或者返回类型的函数。`





### 菱形继承与虚继承

`菱形继承的带来的问题`

类A和类B继承于同一个基类R，现在有一个类C同时继承类A和类B，此时类C的对象中会有两个同样的R，一份来自于A，另一份来自于B，这样会造成内存浪费。并且还会带来二义性

**示例代码**

```cpp
#include <iostream>
using namespace std;

class GrandParent
{
public:
    GrandParent()
    {
        cout << "GrandParent constructor" << endl;
    }
    GrandParent(int m_gp) : gp(m_gp) {}
    int gp;
};

class Father : public GrandParent
{
public:
    Father()
    {
        cout << "Father constructor" << endl;
    }
    Father(int m_father, int m_gp) : father(m_father) {}
    int father;
};

class Mother : public GrandParent
{
public:
    Mother()
    {
        cout << "Mother constructor" << endl;
    }
    Mother(int m_mother) : mother(m_mother) {}
    int mother;
};

class Son : public Father, public Mother
{
public:
    Son(int m_son)
    {
        son = m_son;
        cout << "Son constructor" << endl;
    }
    int son;
};

int main()
{
    // 生成一个son对象，由于是菱形继承，Father类和Mother类会各构造一次，而GrandParent会构造两次
    Son son(0);
    // 并且son使用GrandParent中的gp，还需要加上域解析符，不然会有二义性
    son.Father::gp;
    son.Mother::gp;
}
```

**输出结果**

> GrandParent constructor
> Father constructor 
> GrandParent constructor
> Mother constructor 
> Son constructor 



**Son内存分布**

```
1>class Son	size(20):
1>	+---
1> 0	| +--- (base class Father)
1> 0	| | +--- (base class GrandParent)
1> 0	| | | gp
1>	| | +---
1> 4	| | father
1>	| +---
1> 8	| +--- (base class Mother)
1> 8	| | +--- (base class GrandParent)
1> 8	| | | gp
1>	| | +---
1>12	| | mother
1>	| +---
1>16	| son
1>	+---
```



为了解决上述问题，引入了`虚基类`和`虚继承`

**虚基类：**在间接继承共同基类时只保留一份基类成员。虚基类不是在声明基类时声明的，是在声明派生类指定继承方式时，通过在继承方式前加`virtual`关键字

`对于具有共同基类的派生类最好采用虚继承的方式，避免多份基类成员的拷贝`

**虚继承：**在指定派生类继承方式前面加上`virtual`关键字



`C++编译系统只会执行最后的派生类对基类的初始化，而忽略其它派生类对虚基类的构造函数调用，从而避免对虚基类的同一成员多次初始化。因此虚基类只会构造一次，就是最后的派生类，在这里就是Son类，会执行GrandParent的构造函数，因为对于Son来说，GrandParent并不是虚基类`



**示例代码**

```cpp
#include <iostream>
using namespace std;

class GrandParent
{
public:
    GrandParent()
    {
        cout << "GrandParent constructor" << endl;
    }
    GrandParent(int m_gp) : gp(m_gp) {}
    int gp;
};

// Father是GrandParent的公用派生类，GrandParent是Father的虚基类
class Father : virtual public GrandParent
{
public:
    Father()
    {
        cout << "Father constructor" << endl;
    }
    Father(int m_father, int m_gp) : father(m_father) {}
    int father;
};

// Mother是GrandParent的公用派生类，GrandParent是Mother的虚基类
class Mother : virtual public GrandParent
{
public:
    Mother()
    {
        cout << "Mother constructor" << endl;
    }
    Mother(int m_mother) : mother(m_mother) {}
    int mother;
};

class Son : public Father, public Mother
{
public:
    Son(int m_son)
    {
        son = m_son;
        cout << "Son constructor" << endl;
    }
    int son;
};

int main()
{
    // 生成一个son对象，虽然间接继承了共同基类，但是只会有一份GrandParent成员
    Son son(0);
    // 直接访问gp，不具有二义性
    son.gp;
}
```

**输出结果**

> GrandParent constructor
> Father constructor
> Mother constructor
> Son constructor

**Son内存分布**

```
1>class Son	size(48):
1>	+---
1> 0	| +--- (base class Father)
1> 0	| | {vbptr}
1> 8	| | father
1>  	| | <alignment member> (size=4)
1>  	| | <alignment member> (size=4)
1>	| +---
1>16	| +--- (base class Mother)
1>16	| | {vbptr}
1>24	| | mother
1>  	| | <alignment member> (size=4)
1>  	| | <alignment member> (size=4)
1>	| +---
1>32	| son
1>  	| <alignment member> (size=4)
1>  	| <alignment member> (size=4)
1>	+---
1>	+--- (virtual base GrandParent)
1>40	| gp
1>	+---
```



### final和override

- `override`: 显示声明派生类要**重写虚函数**
- `final`: 
  - 修饰虚函数：显示声明该虚函数**不可被派生类重写**
  - 修饰类：显示声明该类**不可被继承**





### explicit

`explicit`关键字用于抑制构造函数的隐式转换



### 静态成员变量

![image-20240326000140513](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240326000140513.png)





### C++11新特性

- 自动类型推导：auto
- 范围based-for循环
- 智能指针
- 空指针常量nullptr代替NULL
- Lambda表达式
- 强制类型转换
- 右值引用和移动语义
- 引入新的容器std::unordered_map和std::unordered_set



### lambda表达式

```cpp
[capture list](parameters) -> return_type {body}
```

- `capture list`：捕获列表，用来捕获外部局部变量，可以是值捕获(`[=]`)、引用捕获`[&]`，或特定变量的捕获`[x, &y]`
- `parameters`：参数列表
- `return_type`：返回类型，可以省略由编译器推导出来
- `body`：函数体

> 为什么有了参数列表，还需要捕获列表呢？



有一种例子，比如给sort函数写的排序规则的lambda表达式中，参数列表只能有两个，即容器中的元素，此时如果想传入第三个参数的话，就必须通过捕获列表传输了



所以捕获列表应该是用于解决默写情况下lambda表达式的参数个数有限制的情况



### 临时变量存放在哪里

1. 函数内部的临时变量：栈
2. 表达式中的临时变量：寄存器
3. 全局临时变量：静态存储区



### 假如现在一个数据量比较大，比如达到兆级，一般放在哪里?

1. 磁盘：空间大，速度慢
2. 内存：不算特别大，速度快
3. 数据库：数据需要结构化存储和管理



### C++没有内存回收，C++中分配内存要考虑到什么问题?

1. 内存泄漏
2. 重复释放
3. 野指针
4. 内存越界
5. 内存对齐
6. 内存拷贝
7. 内存分配效率
8. 异常安全：比如判断分配结果是否正确



### 避免内存泄漏的方法有哪些?

1. 手动释放内存
2. 使用智能指针
3. 避免循环引用





### 在使用过程中主动释放，但是很难避免程序在运行过程中中途退出的情况，内存也会泄漏，那有没有其他更好的方式避免内存泄漏?

1. 避免使用裸指针：尽量使用智能指针
2. 使用内存池管理



### 智能指针是用什么方式避免内存泄漏的?

1. 自动释放内存
2. 引用计数
3. 避免悬挂指针：在释放对象指针后，会将其置为空指针
4. 管理数组内存：会调用delete[]
5. 异常安全性：即使发生异常，智能指针也可以正确地释放内存





## 数据结构

### 红黑树

性质：

1. 节点为红色或黑色
2. NIL节点(叶子节点)为黑色
3. 红色节点的子节点为黑色
4. 从根节点到NIL节点的每条路径上的黑色节点数量相同



### 智能指针

`智能指针的目的：`帮助我们自动释放指针

#### 共享指针内部实现

**智能指针类型：**

1. shared_ptr: 允许多个指针指向同一对象

   强引用计数：用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)

   弱引用计数：用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)

2. unique_ptr: “独占”所指向的对象

3. weak_ptr: 弱引用，指向shared_ptr所管理的对象。可以通过weak_ptr::lock()方法获得shared_ptr，但是要注意内部对象是否已被释放



**shared_ptr内部实现原理**

```cpp
class __declspec(novtable) _Ref_count_base
{	// common code for reference counting
private:
	_Atomic_counter_t _Uses;   //记录了引用资源的shared_ptr的个数
	_Atomic_counter_t _Weaks;  //记录了weak_ptr的个数
}

template<class _Ty>
class _Ptr_base
{
private:
    element_type * _Ptr{ nullptr };      //指向资源
    _Ref_count_base * _Rep{ nullptr };   //指向资源引用计数
}

template<class _Ty>
class shared_ptr : public _Ptr_base<_Ty>
```



**unique_ptr实现要点：**

- 不需要引用计数
- 拷贝构造，重载operator等成员函数都在后面加上deleted关键字，表示不实现





**make_shared的优势和劣势：**

通过`new`的方式，是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化

通过`make_shared`的方式，是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数），然后用A的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）

```cpp
// new: 分配两次内存(一次分配a的内存，一次分配共享信息内存)，并且会造成内存碎片化
A *a = new A;
shared_ptr<A> pa(a);

// make_shared: 只分配一次内存(内部对象内存、共享信息内存一起分配)，且内部对象和共享信息控制块内存连续
auto p = make_shared<A>(1);
```

![image-20240318174921402](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174921402.png)



![image-20240318174936806](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318174936806.png)

```cpp
// shared_ptr

#include <iostream>
using namespace std;

class Count
{
public:
    Count() : count(1) {}

    void increase()
    {
        ++this->count;
    }

    void decrease()
    {
        --this->count;
    }

    int get_count() const
    {
        return this->count;
    }

private:
    // 初始化为0，预防空指针情况
    int count = 0;
};

template <typename T>
class SharedPtr
{
public:
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}
    explicit SharedPtr(T *ptr) : ptr_(ptr), count_(new Count()) {}
    SharedPtr(const SharedPtr<T> &other)
    {
        ptr_ = other.ptr_;
        count_ = other.ptr_;
        count_->increase();
    }

    ~SharedPtr()
    {
        if (this->count_ != nullptr)
        {
            this->count_->decrease();
            if (count_->get_count() == 0)
            {
                delete ptr_;
                delete count_;
                ptr_ = nullptr;
                count_ = nullptr;
            }
        }
    }

    SharedPtr<T> &operator=(const SharedPtr<T> &other)
    {
        if (ptr_ != other.ptr_)
        {
            this->count_->decrease();
            if (this->count_->get_count() == 0)
            {
                delete this->ptr_;
                delete this->count_;
                this->ptr_ = nullptr;
                this->count_ = nullptr;
            }
        }
        this->ptr_ = other.ptr_;
        this->count_ = other.count_;
        count_->increase();
    }

    T *get()
    {
        return ptr_;
    }

    T *operator->
    {
        return ptr_;
    }

    T &operator*
    {
        return *ptr_;
    }

    int get_count() const
    {
        if (count_ == nullptr)
            return 0;
        return count_->get_count();
    }

private:
    T *ptr_;
    Count *count_;
};

```



#### 循环引用问题

![image-20240318175337344](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318175337344.png)

产生原因详解：

根据代码执行顺序，share_ptr指针指向new创建的一个Person对象，也就是图中栈空间的person指针指向了堆空间的Person对象，引用计数为1，同理，car指针也指向了堆空间的Car对象，引用计数亦为1。

接下来，Person对象里的成员m_car指向Car对象，Car对象的引用计数加1后为2，Car对象的m_person也指向Person对象，Person对象引用计数也加1为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1后为1，后释放person指针，Person对象的引用计数也减为1。由于Person对象和Car对象都是建立再堆空间上，两者相互依赖，都在等待对方释放。

可以看到，这个例子中，堆空间里的 Person对象 与 Car对象互相使用着，导致双方的 shared_ptr 强引用数量不会为0，所以不会自动释放内存，产生了内存泄漏。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;
class A
{
public:
    shared_ptr<B> inner_b;
};

class B
{
public:
    shared_ptr<A> inner_a;
};

int main()
{
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a.get()->inner_b = b; // b的引用计数是2
    b.get()->inner_a = a; // a的引用计数是2
    // 释放a和b，此时a和b的引用计数仍是1，所以其内部对象无法正确释放
    a.~shared_ptr();
    b.~shared_ptr();
    cout << a.use_count() << endl; // 1
    cout << b.use_count() << endl; // 1
}
```



解决方案：weak_ptr

![image-20240318180105547](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180105547.png)

![image-20240318180113901](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240318180113901.png)

根据之前的分析可知，前三句代码执行完后，Person对象的引用计数为1，Car对象的引用计数为2。而第四条语句car->m_person = person执行的便是途中虚线弱引用的语句，不增加Person对象的引用计数。因此，Person对象的引用计数为1，Car对象的引用计数为2。

若此时代码执行结束，栈空间上的car指针先进行释放，Car对象的引用计数减1为1，后释放person指针，Person对象的引用计数减1后为0，Person对象释放内存空间，因此m_car成员变量也得到释放，Car对象引用计数减1后为0，Car对象也得到释放。因此不会产生内存泄漏。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class B;
class A
{
public:
    weak_ptr<B> inner_b;
};

class B
{
public:
    shared_ptr<A> inner_a;
};

int main()
{
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a.get()->inner_b = b; // b的引用计数是1，因为weak_ptr不增加强引用计数
    b.get()->inner_a = a; // a的引用计数是2
    // 释放a，a的引用计数减1，此时a和b的引用计数都是1
    a.~shared_ptr(); 
    // 释放b，b的引用计数减1变成0，因此可以释放b的内部对象，调用b的内部对象的析构函数
    // 然后会调用到inner_a的析构函数，a的引用计数也减1，a的内部对象也可以释放
    b.~shared_ptr(); 
    // a、b的内部对象都正常释放了
}
```



#### 共享指针线程安全

共享指针本身不负责多线程安全，而应该由程序员负责



**线程安全的定义**

多线程操作一个共享数据时，保证所有线程的行为是符合预期的则称为线程安全



**智能指针的线程安全隐患**

1. 引用计数的加减操作是否线程安全
2. 修改shared_ptr指向是否线程安全
3. shared_ptr\<T\>的T并发操作的安全性



> shared_ptr中除了有一个指向对象的指针，还有一个指向控制块的指针，里面存放了所有管理智能指针的数据（强引用计数、弱引用计数等），说明是在堆上的



**结论**

1）同一个shared_ptr被多个线程“读”是安全的；

2）同一个shared_ptr被多个线程“写”是不安全的；

3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的，因为采用原子操作保证该区域的引用计数值被互斥地访问



#### STL容器线程安全

STL（Standard Template Library）容器通常不是线程安全的。STL容器在设计上不考虑多线程并发访问的情况，因此在多线程环境下，对容器进行并发读写操作可能导致数据竞争和未定义行为。

如果需要在多线程环境下使用STL容器，需要采取额外的措施来确保线程安全，比如使用互斥锁（mutex）来保护容器的访问，或者使用线程安全的替代容器，如`std::shared_mutex`、`std::shared_timed_mutex`和`std::atomic`等。



### emplace_back无法取代push_back

![image-20240322140202982](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240322140202982.png)





### deque与queue

`deque可以通过下标来取元素`

`queue不可以通过下标取元素`



## 数据库

### 优化查询性能常见的方式

- 索引优化
- 合适的数据类型
- 查询语句优化
- 表结构设计
- 分区和分表
- 缓存



### 索引的作用：

- 提高检索速度
- 加速排序
- 加速连接
- 提高数据唯一性
- 减少磁盘IO



### 基础篇

#### COUNT函数

> - COUNT有几种用法？`COUNT(expr)、COUNT(常量)、COUNT(*)`
> - COUNT(字段名)和COUNT(\*)的查询结果有什么不同？`前者不统计NULL值，后者统计`
> - COUNT(1)和COUNT(\*)之间有什么不同？`COUNT(*)是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化`
> - COUNT(1)和COUNT(\*)之间的效率哪个更高？`起始是一样的，但由于COUNT(*)是标准语法，因此更推荐使用COUNT(*)`
> - 为什么《阿里巴巴Java开发手册》建议使用COUNT(\*)`理由同上`
> - MySQL的MyISAM引擎对COUNT(\*)做了哪些优化？`每张表都单独记录了行数`
> - MySQL的InnoDB引擎对COUNT(\*)做了哪些优化？`通过低成本的索引进行扫表，只关注表的记录数而不关注字段内容`
> - 上面提到的MySQL对COUNT(\*)做的优化，有一个关键的前提是什么？`优化的前提是查询语句中不包含where条件和group by条件`
> - SELECT COUNT(\*) 的时候，加不加where条件有差别吗？`加where条件COUNT(*)就没有优化了`
> - COUNT(\*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？`见下面第二条`

1. COUNT(expr): 返回SELECT语句检索的行中expr值不为NULL的数量，结果是一个BIGINT值

   如果查询结果没有命中任何记录，则返回0

   COUNT(*)的统计结果中，会包含NULL的行数

2. `COUNT(常量)` 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数。

   而`COUNT(列名)`表示的是查询符合条件的列的值不为NULL的行数。

   `COUNT(*)`是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化

3. COUNT(*)的优化：

   - MyISAM

     MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。

   - InnoDB

     InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。

     但是，InnoDB还是针对COUNT(*)语句做了些优化的。

     通过低成本的索引进行扫表，而不关注表的具体内容。

     InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

     **MySQL会优先选择最小的非聚簇索引来扫表。**

     优化的前提是查询语句中不包含where条件和group by条件。

4. COUNT(字段)

   进行全表扫描，判断指定字段的值是否为`NULL`，不为`NULL`则累加。

   性能比`count(1)`和`count(*)`慢。



### 索引篇

#### 聚簇索引和非聚簇索引

- 聚簇索引（Clustered Index），也叫主键索引，并不是一种单独的索引类型，而是一种`数据存储方式`。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。`无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引`。InnoDB的聚簇索引实际上是`将索引和数据保存中同一个B+Tree中`。InnoDB通过`主键`聚集数据，`如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替`。如果没有这样的索引，InnoDB会隐式定义一个主键（自增id）来作为聚簇索引。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080712264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

  

- 非聚簇索引（NoClustered  Index），又叫`二级索引`。`二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值`。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，`获得行的主键值，然后使用主键去聚簇索引中查找数据行`，这需要`两次`B+Tree查找。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080810940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

#### UNIQUE

UNIQUE创建的是`唯一索引`





#### 索引下推ICP

- 没有使用ICP的情况下：
  1. 存储引擎读取索引记录
  2. 根据索引中的主键值，定位并读取完整的行记录
  3. 存储引擎把记录交给Server层去检测该记录是否满足where条件
- 使用ICP的情况下：
  1. 存储引擎读取索引记录（不是完整的行记录）
  2. 判断where条件部分能否用索引中的列（比如联合索引中的后面的字段）来做检查，条件不满足，则处理下一行索引记录
  3. 条件满足，使用索引中的主键值去主键索引B+树定位并读取完整的行记录（这就是回表）
  4. 索引把记录交给Server层，让Server层去判断是否满足where条件中的其余部分







### 日志篇

#### undolog、redolog、binlog有什么用，是如何保证事务的四大特性的

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E6%8F%90%E7%BA%B2.png)



##### 为什么需要undolog？

`undolog(回滚日志)：`保证了事务的原子性

`undolog`是一种用于撤销回退的日志。在事务没提交之前，`undolog`会记录更新前的数据到`undolog`日志文件中，当事务回滚时，可以利用`undolog`回滚

![回滚事务](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



每当InnoDB引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到undolog

- 在`插入`一条记录时，要把这条记录的`主键值`记录下来，回滚时只需要将把这个主键对应的记录`删掉`即可
- 在`删除`一条记录时，要把这条记录中的内容都记下来，回滚时再把由这些内容组成的记录`插入`到表中就好了
- 在`更新`一条记录时，要把被更新的列的旧值记录下来，回滚时再把这些记录的对应列更新为旧值即可



一条记录的每一次更新操作产生的`undolog`格式都有一个`trx_id`事物id和`roll_pointer`指针

- 通过trx_id可以知道该记录是被哪个事务修改的
- 通过roll_pointer指针可以将这些undolog串成一个链表，这个链表就被成为`版本链`

版本链如下图：

![版本链](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



**undolog还有一个作用，通过ReadView + undolog 实现MVCC（多版本并发控制）**

![image-20240324223318346](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240324223318346.png)



对于`读提交`和`可重复读`隔离级别的事物来说，它们的快照读（普通select语句）是通过Read View+undolog来实现的，区别在于创建Read View时机不同：

- `读提交`隔离级别是在每个select都会生成一个新的Read View，这就意味着事务期间多次读取同一个数据，前后两次读取到的数据可能不一致，这是因为在这期间可能会有其它事务提交，然后修改了这个数据
- `可重复读`隔离级别是启动事务时生成一个ReadView，然后整个事务期间都在用这个Read View，这样就保证了事务期间读到的数据都是事务启动前的数据

这两个隔离级别的实现是通过`事务的ReadView里的字段`和`记录中两个隐藏列(trix_id和roll_pointer)`的比对，如果不满足可见性，就会顺着undolog版本链找到满足其可见性的记录，从而控制并发事务访问同一个记录的行为，这就是`MVCC(多版本并发控制)`



**undolog两大作用：**

1. `实现事务回滚，保证了事务的原子性`
2. `实现MVCC(多版本控制链的关键因素之一)。`MVCC是通过ReadView+undolog实现的。undolog为每条记录保存多份历史数据，MySQL在执行普通select语句时，会根据事务的ReadView的信息，顺着undolog版本链找到满足其可见性的记录



> undolog是如何持久化到磁盘的？

undolog和数据页持久化到磁盘的策略是一样的，都是需要通过redolog来保证持久化



##### 为什么需要redolog？

内存是不可靠的，万一断点重启，还没来得及落盘的脏页数据就会丢失



为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以redolog的形式记录下来，这时候这个更新才算完成了



`WAL(Write-Ahead Logging)技术是MySQL的写操作并不是立刻写到磁盘上，而是先写日志，然后再在合适的时间写到磁盘上`



> 什么是redolog？

`redolog是物理日志，记录了某个数据页做了什么修改，比如对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新`，每当执行一个事务时就会产生一条或多条物理日志



在事务提交时，只需要先将redolog持久化到磁盘，就可以保证当系统崩溃重启后，虽然内存中的脏页数据还没有同步到磁盘中，但是可以根据redolog的内容，将所有数据恢复到最新状态



`在内存修改了undolog，需要记录对应的redolog`



**undolog和redolog的区别：**

- `redolog`记录的是此次事务**完成后**的数据状态，记录的是更新后的值
- `undolog`记录的是此次事务**开始前**的数据状态，记录的是更新前的值

![事务恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



**redolog保证了事务四大特性中的持久性**





> redolog要写到磁盘，数据也要写到磁盘，为什么不直接把数据写入磁盘呢？

**写入redolog的方式使用了追加操作，所以磁盘操作是**`顺序写`**而写入数据的磁盘操作是**`随机写`，顺序写比随机写高效很多



**为什么需要redolog**

- 保证了事物的持久性
- 将写操作从随机写变成了顺序写





`产生的redolog并不是直接写入磁盘的`，redolog也有自己的缓存——redolog buffer，每当产生一条redolog时，会先写入到redolog buffer，后续在合适的时间才持久化到磁盘

![事务恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/redologbuf.webp)



> 缓存在redolog buffer中的redolog什么时候持久化到磁盘？

- MySQL正常关闭时
- 当redolog buffer中记录的写入量大于redolog buffer内存空间的一半时，会触发落盘
- `InnoDB的后台线程每隔一秒，将redolog buffer持久化到磁盘`
- 每次事务提交时，都会将存在redolog buffer中的redolog持久化到磁盘



> redolog文件写满了怎么办？

InnoDB存储引擎有一个redolog文件组，由两个redolog文件组成。

redolog文件组是通过`循环写`的方式工作的，从头开始写，写到末尾又回到开头，相当于一个环形。

因此InnoDB会先写第一个redolog文件，写满了就写第二个，如果第二个也满了，就回到第一个文件继续写

![重做日志文件组写入过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png)

redolog是为了防止Buffer pool中的脏页丢失设计的，如果脏页刷新到了磁盘中，redolog对应的记录也就没用了，这时候就可以擦除这些旧记录，以腾出空间记录新的更新操作



redolog是循环写的方式，InnoDB用write pos标识redolog当前记录写到的位置，用checkpoint表示当前要擦除的位置

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/checkpoint.png)

- write pos 和 checkpoint 的移动都是顺时针方向；
- write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；
- check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；



`当write pos追上checkpoint时，就代表redolog文件满了，此时MySQL会被阻塞，会停下来将Buffer Pool中的脏页刷新到磁盘中，然后标记redolog哪些记录可以被擦除，接着对旧的redolog记录进行擦除，擦除完记录也就腾出了空间，就可以继续记录了，MySQL恢复运行`





##### 为什么需要binlog？

`undolog`和`redolog`都是存储引擎生成的

MySQL在完成一条更新操作后，Server层还会生成一条`binlog`，等事务提交时，会将该事物执行过程中产生的所有binlog统一写入binlog文件



**binlog文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作**



> redolog和binlog有什么区别？

1. **适用对象不同**
   - binlog是MySQL的Server层实现的日志，所有存储引擎都可以使用
   - redolog是InnoDB存储引擎实现的日志
2. **文件格式不同**
   - binlog有3种格式类型，分别是`STATEMENT（默认格式）`，`ROW`、`MIXED`，区别如下：
     - `STATEMENT`：每一条修改数据的SQL语句都会被记录到binlog中（相当于记录了逻辑操作，所以针对这种格式，binlog可以成为逻辑日志），主从复制中slave端再根据SQL语句重现，但STATEMENT有动态函数的问题，比如uuid或者now这些函数，在不同库的执行结果并不相同
     - `ROW`：记录行数据最终被修改成什么样了（这种格式的日志，并不能成为逻辑日志），不会出现STATEMENT格式下动态函数的问题。但ROW的缺点是每行数据的变化结果都会被记录，使得binlog文件过大，而在STATEMENT格式下只会记录一个UPDATE语句而已
     - `MXED`：包含了STATEMENT和ROW格式，根据不同的情况自动使用STATEMENT和ROW模式
   - redolog是物理日志，记录的是**某个表空间**中的**某个数据页**做了**什么修改**
3. **写入方式不同**
   - binlog是追加写，写满了一个文件就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志
   - redolog是循环写，日志空间大小是固定的，全部写满就从头开始写，会覆盖以前的日志，保存的是未被刷盘的脏页记录
4. **用途不同**
   - binlog用于备份恢复、主从复制
   - redolog用于故障恢复



> 如果不小心整个数据库的数据被删除了，能使用redolog文件恢复数据吗？

不可以使用redolog文件恢复，只能使用binlog文件恢复



**因为redolog文件只是保存了未被刷盘的脏页数据，而binlog文件保存的全量日志，也就是保存了所有数据变更的情况**





> 主从复制是如何实现的



MySQL主从复制依赖于binlog，也就是记录MySQL上的所有变化并以二进制的形式保存在磁盘中，复制的过程就是将binlog中的数据从主库传输到从库上

这个过程是**异步**的，也就是主库上执行事务操作的线程不会等待复制binlog的线程同步完成

![MySQL 主从复制过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

MySQL集群的主从复制过程主要有3个阶段：

1. `写入binlog`：主库写binlog，提交事务，并更新本地存储数据
2. `同步binlog`：把binlog复制到所有从库上，每个从库把binlog写到暂存日志(`relaylog`)中
3. `回放binlog`：回放binlog，并更新存储引擎中的数据

具体详细过程如下：

1. MySQL主库在收到客户端提交事务的请求之后，会先写入binlog，然后再提交事务，更细存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应
2. 从库会创建一个专门的I/O线程连接主库的log dump线程，来接收主库的binlog日志，再把binlog日志信息写入relaylog中，再返回给主库"复制成功"的响应
3. 从库会创建一个用于回放binlog的线程，去读relaylog中继日志，然后回放binlog，把数据更新到存储引擎中，最终实现主从的数据一致性



**在完成主从复制之后，可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行**

![MySQL 主从架构](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)





> 从库是不是越多越好？

不是的，从库数量越多，也就会有越多的I/O线程连接到主库，而主库也要创建同样多的log dump线程来处理从库复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽





> MySQL主从复制还有哪些模型？

1. `同步复制`：MySQL主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。
   - 性能差
   - 可用性差：主库和任一从库出问题都会影响业务
2. `异步复制(默认模型)`：MySQL主库提交事务的线程并不会等到binlog同步到从库。
   - 一旦主库宕机，数据就会丢失
3. `半同步复制`：MySQL提交事务的线程不需要等待所有从库复制成功的响应，只需要等待一部分从库复制成功的响应即可返回给客户端结果。这样即使主库宕机，也有一部分从库的数据完成了更新，不存在数据丢失的风险





> binlog什么时候刷盘？

**事务执行过程中，先把日志写到binlog cache（server层的cache），等到事务提交时，再把binlog cache写到binlog文件，并清空binlog cache**

一个事物的binlog是不能被拆开的，因为这样会破坏事务的原子性

`一个线程只能由一个事物在执行，MySQL给每个线程分配了一块内存用于缓冲binlog，也就是binlog cache`

![binlog cach](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/binlogcache.drawio.png)





##### 为什么需要两阶段提交？

事务提交后，redolog和binlog都需要持久化到磁盘，但这两个是独立的逻辑，因此可能出现半成功的状态，这样就造成了两份日志之间的逻辑不一致



半成功情况：

- redolog持久化成功，binlog持久化失败：主库是新值，从库是旧值
- binlog持久化成功，redolog持久化失败：主库是旧值，从库是新值

所以半成功情况下会出现主从数据不一致





`两阶段`：分为prepare阶段和commit阶段

![两阶段提交](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)



![时刻 A 与时刻 B](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

![image-20240325114437188](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240325114437188.png)





> 事务还没提交时，redolog会被持久化到磁盘吗？

会的。

事务执行过程中，redolog是直接写在redolog buffer中的，而MySQL后台线程每隔一秒会把redolog buffer中的日志持久化到磁盘中



`事务还没提交时，MySQL崩溃了，但是redolog已经持久化到磁盘，MySQL重启后，数据不一致怎么办？`

这种情况下，MySQL会进行回滚操作，因为事务还没提交时，binlog是还没持久化到磁盘的。

**因此，redolog可以在事务提交前持久化到磁盘，而binlog必须在事务提交后才可以持久化到磁盘**





> 两阶段提交有什么问题？

- **磁盘I/O次数高**：每个事务提交都会进行两次fsync（刷盘），一次是redolog刷盘，一次是binlog刷盘
- **锁竞争激烈**：多事务情况下并不能保证两者的提交顺序一致，因此需要多加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致



`MySQL引入了binlog组提交机制，当有多个事务提交的时候，会将多个binlog刷盘操作合成一个，从而减少了磁盘I/O的次数`

- **flush 阶段**：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；
- **sync 阶段**：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；
- **commit 阶段**：各个事务按顺序做 InnoDB commit 操作；

上面的**每个阶段都有一个队列**，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。

![每个阶段都有一个队列](http://keithlan.github.io/image/mysql_innodb_arch/commit_4.png)

对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，**锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率**。



##### 优化MySQL磁盘I/O

1. 组提交
2. 设置binlog在足量的事物提交后再统一刷盘



##### 如何保证事务的四大特性？

**事务的四大特性(ACID)：**

- `原子性`：一个事务的操作要么全部成功，要么全部失败回滚

  实现：undolog

- `一致性`：保证原子性、隔离性、持久性

- `隔离性`：通过MVCC保证，多个事务并发执行时，事务内部的操作与其它事务是隔离的，并发执行的各个事务之间互不影响

  实现：隔离级别

  - 读未提交：脏读、幻读、不可重复读
  - 读已提交：每做一次普通查询都会更新ReadView，会出现幻读、不可重复读
  - 可重复读：事务执行过程中都只有事务开始前的ReadView，会出现幻读，但是可通过MVCC机制（ReadView+undolog）避免部分幻读
  - 串行化：事务是串行执行的，不存在并发问题

- `持久性`：事务一旦提交后，它对数据库的改变就应该是永久性的，接下来的其它操作或故障不应该对其有任何影响

  实现：redolog





## 计算机网络

### 网卡接收数据包后的流程

#### 网络模型

**OSI七层网络模型：**

- `应用层`：负责给应用程序提供统一接口
- `表示层`：负责把数据转换成兼容另一个系统能识别的格式
- `会话层`：负责建立、管理和终止表示层实体之间的通信会话
- `传输层`：负责端到端的数据传输
- `网络层`：负责数据的路由、转发和分片
- `数据链路层`：负责数据的封帧和差错检测，以及MAC寻址
- `物理层`：负责在物理网络中传输数据帧



**TCP/IP模型：**

- `应用层`：负责提供给应用程序接口，例如HTTP、DNS、FTP等
- `传输层`：负责端到端的通信，比如TCP、UDP
- `网络层`：负责网络包的封装、分片、路由、转发，比如IP、ICMP等
- `网络接口层`：负责网络包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测以及通过网卡传输网络帧等

![image-20240327094758905](C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240327094758905.png)



**应用层：**提供数据

**传输层：**添加TCP头

**网络层：**添加IP头

**网络接口层：**添加帧头帧尾

`帧头(SOH)帧尾(EOT)的作用：`

- **帧定界：**如果只接收到SOH而没有接收到EOT，那么就代表这是一个不完整的帧，应该丢弃
- **帧同步：**在帧头的控制字段中加入一个数据长度的字段，用于指示这个帧的数据部分有多长





#### Linux接收数据包的流程

- `网络接口层：`检查报文的合法性，不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是IPv4还是IPv6，然后去掉帧头帧尾
- `网络层：`取出IP包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。如果确定了是交给本机的，就判断上一层的协议是TCP还是UDP（通过IP头部的协议号来判断，TCP是6，UDP是17），接着去掉IP头
- `传输层：`取出TCP头或UDP头，根据四元组(源IP、源端口、目的IP、目的端口)作为标识，找出对应的Socket，并把数据放入Socket的接收缓冲区
- `应用层：`应用程序调用Socket接口，将内核的Socket接收缓冲区的数据拷贝到应用层的缓冲区，然后唤醒用户进程



#### Linux发送数据包的流程

1. `应用层：`应用程序调用Socket发送数据包，由于是系统调用，所以会从用户态陷入内核态中的Socket层，内核会申请一个内核态的sk_buff内存，`将用户发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区`
2. `传输层：`从Socket发送缓冲区取出sk_buff。如果使用的是TCP传输协议的话，会`先拷贝一个sk_buff副本`，直到收到对方的ACK后才释放掉。这是因为TCP是支持丢失重传的，如果网络包丢失了，那么就再传输一份sk_buff拷贝即可。`添加TCP头`
3. `网络层：`选取路由（确认下一跳的IP），填充IP头，对超过MTU大小的数据包进行分片
4. `网络接口层：`通过ARP协议获取下一跳的MAC地址，然后对sk_buff填充帧头帧尾，接着将sk_buff放到网卡的发送队列中
5. `通知网卡：`触发**软中断**通知网卡驱动程序，驱动程序将会从发送队列中读取sk_buff，将这个sk_buff挂到RingBuffer中，接着将sk_buff数据映射到网卡可访问的内存DMA区域，最后触发真实的发送
6. `清理缓存：`发送完成后，网卡设备触发一个**硬中断**来释放内存，主要是释放`sk_buff内存`(收到ACK应答后)和`RingBuffer内存`

**注意：**网络协议栈从上到下的sk_buff一直都是同一个结构体，只不过是在填充各协议头时移动了data指针而已



> 发送数据时，涉及几次内存拷贝操作？

1. 将用户待发的数据拷贝到内核态中的sk_buff
2. 使用TCP协议的情况下，每一个sk_buff都会被拷贝出一个副本
3. IP层发送sk_buff大于MTU时，会再申请额外的sk_buff，并将原来的sk_buff拷贝为多个小的sk_buff



**四元组（源IP、源端口、目的IP、目的端口）确认一个连接，只要有一个参数不同，那么就是不同的连接，一个端口可以有不同的连接，并且TCP和UDP协议即使四元组相同，但是同样可以绑定到同一个端口，因为它们是由不同的协议堆栈栈处理的**



### TCP如何保证可靠性

`TCP保证可靠性的机制`

1. **校验和**：计算3部分(TCP首部、TCP数据、TCP伪首部)
2. **序列号/确认应答**
3. **超时重传**
4. **最大消息长度MSS**
5. **滑动窗口控制**
6. **拥塞窗口控制**





### UDP数据包的最大长度是多少？为什么？

UDP数据包的最大长度=64KB-8B(UDP头)-20B(IP头)





### TCP 和 UDP 可以使用同一个端口吗？

`可以`

操作系统会根据IP头部的`协议号字段`以及`端口号`来区分服务





### http常见响应码有哪些？

- `1xx:`提示消息，表示目前是协议处理的中间状态
- `2xx:`成功，报文已经收到并被正确处理
- `3xx:`重定向，资源位置发生变动，需要客户端重新发送请求
- `4xx:`客户端错误，请求报文有误，服务器无法处理
- `5xx:`服务端错误，服务器在处理请求时内部发生了错误

200：请求成功，如果是非HEAD请求，服务器返回的响应头都会有body数据

204：与200基本相同，但是响应头没有body数据

206：表示响应返回的body数据并不是资源的全部

301：永久重定向

302：临时重定向

401：请求要求身份验证

403：服务器拒绝请求，通常是因为没有权限访问

404：无法找到此页面

405：请求的方法类型不支持

500：服务器内部出错

### http各个版本的特性？

**HTTP/1.1相比HTTP/1.0性能上的改进**

- 使用长连接
- 支持管道传输，只要第一个请求发送出去了，不必等其回来，就可以发送第二个请求出去，可以减少整体的响应时间



**HTTP/1.1性能瓶颈**

- 请求/响应头部未经压缩就发送，首部信息越多延迟越大，只能压缩Body部分
- 发送冗长的首部，每次发送相同的首部造成的浪费多
- 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是队头阻塞
- 没有请求控制优先级
- 请求只能从客户端开始，服务器只能被动响应



**HTTP/2相比HTTP/1.1性能上的改进**

- `头部压缩`：

  在客户端和服务端同时维护一张头信息表，所有字段都会存入这个表生成一个索引号，之后就只发送索引号，不发送同样字段了

- `二进制格式`：

  头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧

- `并发传输`：

  一个TCP连接包含多个Stream，Stream里可以包含一个或多个Message，Message对应HTTP/1中的请求或响应，由HTTP头部和包体构成。Message里包含一条或多个Frame，Frame是HTTP/2最小单位，以二进制压缩格式存放HTTP/1中的内容（头部和包体）

  **针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream  的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应**。

- `服务器主动推送资源`:

  客户端的StreamID是奇数，服务器StreamID是偶数

  ![image-20240327221735048](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240327221735048.png)





### TCP拥塞控制

- 慢启动：cwnd扩大一倍直至和ssthresh相等

- 拥塞避免：每次加 1/cwnd 

- 拥塞发生：超时重传或快速重传

  - 超时重传+慢启动：ssthresh设置为cwnd/2，cwnd=1，过于激进网络卡顿

  - 快速重传+快速恢复：`目的只是快速重传丢失的包，一旦对方接收完丢失的包，就会进入拥塞避免状态`

    1. cwnd/=2，ssthresh=cwnd（进入快速恢复之前）
    2. 进入快速恢复
    3. cwnd=ssthresh+3
    4. 重传丢失的数据包
    5. 如果再收到重复的ACK，cwnd+1
    6. 如果收到新数据的ACK后，把cwnd设置为第一步的ssthresh的值，原因是该ACK确认了新的数据，说明从duplicated ACK时的数据都已收到，恢复过程结束，可以回到之前的状态了，即将再次进入拥塞避免状态

    ![image-20240327222630603](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240327222630603.png)



> 哪些因素会影响窗口大小？

- `接收方窗口大小`
- `带宽和延迟`
- `拥塞控制`
- `路由器和网络设备`
- `操作系统和应用程序`



### 网络通信属于大端还是小端

`网络通信中使用的是大端序列化方式`





### ARP协议流程

![image-20240327231209407](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240327231209407.png)





### HTTP面试常问题目

**大纲**

![image-20240328100710039](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328100710039.png)



#### HTTP基本概念

> HTTP是什么？描述一下

HTTP是超文本传输协议



> 能否详细解释 `超文本传输协议`？

HTTP可以拆成三个部分：

- 超文本
- 传输
- 协议

![image-20240328101039681](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328101039681.png)

1. `协议`

   使用计算机能够理解的语言确立了一种计算机之间交流通信的规范

2. `传输`

   两点之间传输数据

3. `超文本`

   超越了普通文本（字符）的文本，文字、图片、视频等混合体

   HTML就是常见的超文本



**HTTP是一个在计算机世界里专门在两点之间传输文字、图片、视频等超文本数据的规范**





> HTTP常见字段

- `Host`：指定服务器的域名

  Host: www.A.com

  有了Host字段，就可以将请求发往同一台服务器上的不同网站

- `Content-Length`：本次回应的数据长度

  Content-Length:1000

- `Connection`：客户端要求服务器使用TCP持久连接，以便其它请求复用

  HTTP/1.1版本的默认连接都是持久连接，但为了兼容老版本的HTTP，需要指定Connection首部字段的值为Keep-Alive

  Connection: Keep-alive

- `Content-Type`：服务器回应时告诉客户端这是什么类型的数据

  Content-Type: text/html; charset=utf-8

  表明发送的是网页，且编码是UTF-8

- `Accept`：声明自己可以接受哪些数据格式

  Accept: \*/\*

  表示客户端可以接受任何格式的数据

- `Content-Encoding`：数据的压缩方式，表示服务区返回的数据使用了什么压缩方式

  Content-Encoding: gzip

  表示采用了gzip方式压缩

- `Accept-Encoding`：说明自己可以接受哪些压缩方法

  Accept-Encoding: gzip, deflate



#### GET与POST

> 说一下GET和POST的区别？

`GET`方法是请求从服务器获取资源

`POST`方法是相反操作，向URI指定的资源提交数据，数据就放在报文的body里



> GET和POST方法都是安全和幂等的吗？

- `安全`：在HTTP协议中，安全指请求方法不会破坏服务器上的资源
- `幂等`：多次执行相同的操作，结果都是相同的



`GET`方法是**安全**且**幂等**的，因为它是只读操作，无论操作多少次，服务器上的资源都不会修改

`POST`方法既不安全也不幂等，因为会修改服务器上的资源



#### HTTP特性

> 你知道的HTTP(1.1)有点有哪些，怎么体现的？

HTTP最突出的优点是：简单、灵活和易于扩展、应用广泛和跨平台



- `简单`：

  HTTP基本的报文格式就是header+body，头部信息也是key-value简单文本的格式，易于理解

- `灵活和易于扩展`：

  HTTP协议里的各类请求方法，URI/URL，状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充

  同时HTTP是工作在最顶层，则它的下层可以随意变化

  HTTPS就是在HTTP与TCP层之间增加了SSL/TLS安全传输层，HTTP/3甚至把TCP换成了基于UDP的QUIC

- `应用广泛和跨平台`

  从台式浏览器到手机各种APP都在使用HTTP协议



> 缺点呢？

HTTP的缺点：双刃剑（无状态、明文传输）、不安全

- `无状态`：

  好处：服务器不会记录HTTP状态，所以不需要额外的资源来记录状态信息，这可以减轻服务器的负担

  坏处：由于不会记录HTTP状态，因此在做具有关联性的操作时会非常繁琐，每一步都需要知道用户身份

  对于无状态的解决方案，有`Cookie`技术

  `Cookie`通过在请求和响应报文中写入Cookie信息来控制客户端的状态

  ![image-20240328105838097](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328105838097.png)

- `明文传输`

  好处：传输过程中的信息方便阅读

  坏处：信息中的内容都暴露了，毫无隐私可言

- `不安全`

  - 通信使用明文（不加密），内容可能会被窃听
  - 不验证通信方的身份，因此有可能遭遇伪装
  - 无法证明报文的完整性，所以内容可能是被篡改过的



> HTTP/1.1性能如何？

HTTP协议是基于TCP/IP，并且使用了 请求-应答的通信模式，所以性能的关键就在于这两个地方

- `长连接`：只要双方都没有请求断开连接，那么连接就一直存在，HTTP/1.0使用的是短连接，每发起一个请求都要新建一次TCP连接，而且是串行请求
- `管道网络运输`：客户端可以发起多个请求，只要第一个请求发送出去了，不用等其回来，就可以发第二个请求出去，**减少整体的响应时间**，但服务器还是安装顺序响应请求，要是前面回应的特别慢，后面就会有很多请求排队等待响应，这就是**队头阻塞**
- `队头阻塞`：当顺序发送的请求序列中的一个请求因为某种原因阻塞时，在后面排队的所有请求也一同被阻塞了，会导致客户端一直请求不到数据





### HTTP与HTTPS

> HTTP与HTTPS有哪些区别？

- `报文加密`：HTTP是明文传输，HTTPS使得报文能够加密传输
- `握手过程`：HTTP在TCP三次握手后就可以进行HTTP的报文传输，但是HTTPS在TCP三次握手后，还需要进行SSL/TLS的握手过程，才可进入加密报文传输
- `端口号`：HTTP端口号是80，HTTPS端口号是443
- `身份确认`：HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



> HTTPS解决了HTTP的哪些问题？

HTTP的安全隐患：

- `窃听风险`：由于是明文传输，信息是裸露的
- `篡改风险`：由于HTTP不检查报文完整性，所以报文被篡改了也无法发现
- `冒充风险`：HTTP不验证通信方的身份



**HTTPS在HTTP与TCP层之间加入了SSL/TLS协议**

![image-20240328111328470](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328111328470.png)

HTTP通过以下机制解决了上述风险：

- `信息加密`
- `校验机制`
- `身份证书`



> HTTPS是如何解决上面的三个风险的？

- `混合加密`的方式实现信息的`机密性`，解决了窃听风险
- `摘要算法`的方式来实现`完整性`，解决了篡改风险
- 将服务器公钥放入到`数字证书`中，解决了冒充风险



1. `混合加密`

   ![image-20240328111614758](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328111614758.png)

   HTTPS采用的是`对称加密`和`非对称加密`结合的混合**加密**方式：

   - 在通信建立前采用`非对称加密`的方式交换**会话秘钥**，后续就不再使用非对称加密
   - 在通信过程中全部使用`对称加密`的**会话秘钥**的方式加密明文数据

   **采用混合加密的方式的原因：**

   1. `对称加密`只使用一个密钥，运算速度快，秘钥可以保密，无法做到安全的密钥交换
   2. `非对称加密`使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了秘钥交换问题但速度慢

2. `摘要算法`

   `摘要算法`用来实现`完整性`，能够为数据生成独一无二的“指纹”，由于校验数据完整性，解决篡改风险

   ![image-20240328112230878](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328112230878.png)

   客户端在发送明文之前会通过摘要算法算出明文的“指纹”，发送的时候把**指纹+明文**一起加密成密文之后，发送给服务器，服务器解密之后，用相同的摘要算法算出发送过来的明文，通过比较客户端算出的值和服务器算出的值，如果相同，说明数据是完整的，并没有被篡改过

3. `数字证书`

   客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密

   **如何保证公钥不被篡改？**

   `将服务器公钥放在数字证书，只要证书是可信的，公钥就是可信的`

   ![image-20240328113258181](C:/Users/86135/AppData/Roaming/Typora/typora-user-images/image-20240328113258181.png)



> HTTPS是如何建立连接的？期间交互了什么？

1. 客户端向服务器索要公钥并验证
2. 双方协商生成`会话秘钥`
3. 双方采用`会话秘钥`进行加密通信

前两步即SSL/TLS的建立过程，即握手阶段



SSL/TLS的**握手阶段**涉及四次通信

![image-20240328113509744](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328113509744.png)

SSL/TLS协议建立的详细流程：

1. `ClientHello`

   首先，由客户端向服务器发起加密通信请求

   客户端主要向服务器发送以下信息：

   - 客户端支持的SSL/TLS协议版本
   - 客户端生产的随机数（`Client Random`），后面用于生产会话密钥
   - 客户端支持的密码套件列表，如RSA加密算法

2. `ServerHello`

   服务器收到客户端的请求后，向客户端响应，回应内容如下：

   - 确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通话
   - 服务器生成的随机数（`Server Random`），后面用于生成会话秘钥
   - 确认的密码套件列表
   - 服务器的数字证书

3. `客户端回应`

   客户端收到服务器的相应之后，首先通过浏览器或者操作系统中的CA公钥，确认服务器证书的真实性

   如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务端发送如下信息：

   - 一个随机数（`pre-master key`），该随机数会被服务器公钥加密
   - 加密通信算法改变通知，表示随后的信息都用会话密钥加密通信
   - 客户端握手结束通知，表示客户端的握手阶段已经结束，这一项同时把之前所有内容发生的数据做个摘要，用来供服务端校验

   上面`pre-master key`就是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的会话密钥

4. `服务器的最后回应`

   服务器收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的会话秘钥，然后向客户端发送最后的信息：

   - 加密通信算法改变通知，表示随后都使用会话密钥进行加密通信
   - 服务器握手结束通知，表示服务器的握手阶段已经结束，这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验





#### HTTP/1.1、HTTP/2、HTTP/3 演变

> 说说HTTP/1.1相比HTTP/1.0提高了什么性能？



性能上的改进：

- 长连接
- 管道传输

性能瓶颈：

- 请求/响应头部未经压缩就发送
- 发送冗长的首部
- 队头阻塞，服务器是根据请求的顺序来处理的
- 没有请求优先级控制
- 不能主动推送资源



> HTTP/2相比HTTP/1.1做了什么优化

**HTTP/2协议是基于HTTPS的，所以HTTP/2的安全性也是有保障的**



HTTP/2相比HTTP/1.1性能上的改进：

1. `头部压缩`

   在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后不发送同样的字段，只发送索引号

2. `二进制格式`

   头信息和数据体都是二进制，统称为帧，头信息帧和数据帧，方便计算机处理，不用再将明文转成二进制，提高传输效率

3. `数据流`

   每个请求或回应的所有数据包，称为一个数据流，客户端还可以指定数据流的优先级、优先级高的请求，服务器就先响应请求

4. `多路复用`

   **一个连接中并发多个请求或回应，而不用按照顺序一一回应**

5. `服务器推送`

   html+css



> HTTP/2有哪些缺陷？HTTP/3做了哪些优化？

HTTP主要问题在于：多个HTTP请求复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的

所以一旦发生丢包现象，就会出发TCP的重传机制，**这样在一个TCP连接汇总的所有的HTTP请求都必须等待这个丢了的包被重传回来**

- HTTP/1.1中的管道传输中如果有一个请求阻塞了，那么队列后的请求也统统被阻塞了
- HTTP/2多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求



这都是基于TCP传输层的问题，`所以HTTP/3把HTTP下层的TCP协议改成了UDP`

![image-20240328122555182](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328122555182.png)





UDP是不管顺序，也不管丢包的，所以不会出现HTTP/1.1的对头阻塞和HTTP/2的一个丢包全部阻塞的问题



但是由于UDP是不可靠传输，因此需要QUIC协议来实现可靠性传输

- QUIC有自己的一套机制可以保证传输的可靠性，当某个流发生丢包时，只会阻塞这个流，其他流不会受影响
- HTTPS要建立一个连接，要花费六次交互，显示建立三次握手，然后是TLS/1.3的三次握手，QUIC直接把以往的TCP和TLS/1.3的六次交互合并成了3次，减少了交互次数

![image-20240328122927151](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240328122927151.png)







## 操作系统

### 用户态与内核态

`用户态：`运行用户程序的状态，权限受到限制。只能在操作系统划分的特定空间内运行。用户态下运行的程序不能直接访问硬件设备或执行特权指令，所有对硬件的访问都必须通过操作系统进行。在用户态下，应用程序通过系统调用来请求操作系统提供的服务，例如，文件操作、网络通信等都需要通过系统调用来实现。当应用程序发出系统调用后，会触发上下文切换，将CPU的控制权交给系统内核，进入内核态



`内核态：`内核态是运行操作系统程序、操作硬件的状态，拥有最高权限。处于内核态下的CPU可以执行任何指令，访问所有内存地址



这两种状态是操作系统为了安全和管理设计的





> `为什么要区分用户态和内核态？`

1. **安全性：**将操作系统和用户程序的运行环境隔离开有助于防止用户程序给内核带来不可修复的破坏。用户程序无法更改操作系统的关键资源
2. **稳定性：**用户程序崩溃不会影响到内核的运行，内核仍然可以正常工作
3. **性能：**内核态拥有最高权限，可以执行一些权限级别较高的工作，比如直接访问硬件。不需要为每个用户程序都提供这样的权限



`系统调用：`操作系统内核提供给用户的接口，用于请求操作系统的服务，比如读写文件、网络通信等都需要通过系统调用实现



### 乐观锁与悲观锁

`乐观锁：`不会上锁，只是在提交数据时判断数据是否已被修改，如果被修改过，放弃操作，否则改写值

`悲观锁：`认为别的线程同时也会篡改数据，所以会上锁



**乐观锁实现机制：**

1. CAS机制：

   - 需要读写的内存位置
   - 进行比较的预期值A
   - 准备写入的新值B

   CAS操作一般是原子和自旋的

2. 版本号机制：在数据中加一个字段version，每当数据被修改一次，版本号加1



**两者适用场景**

- 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。

- 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。



**CAS的问题：**

- **ABA问题**

  - 进程P1在共享变量中读到值为A
  - P1被抢占了，进程P2执行
  - P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。
  - P1回来看到共享变量里的值没有被改变，于是继续执行。

  `解决方法：`**我们在compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。**

- **执行不成功时，一直自旋等待**

  `解决方法：`**设置最大尝试次数**

- **只能保证一个共享变量的原子操作**

  - 对一个共享变量执行操作时，可以循环CAS方式确保原子操作。

  - 但是对多个共享变量，就不灵了。

  `解决方法：`**这里可以使用锁，或把多个共享变量合并为1个共享变量，如i=2,j=a,合并为ij=2a。然后用CAS操作ij**





### 进程间的通信方式

- 匿名管道：半双工
- 命名管道：fifo文件
- 消息队列
- 共享内存
- 套接字
- 信号量



### 线程间通信方式

- 共享内存
- 互斥锁
- 条件变量：条件变量用于在多个线程之间进行条件等待和通知。线程可以在条件变量上等待某个条件成立，当条件成立时，另一个线程可以通过条件变量通知等待线程。
- 信号量
- 消息队列





### 调度算法

#### 银行家算法

Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，`把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可`。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。



安全状态概念：

![](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125164249992-1856910147.png)

1. 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2. 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即`系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态`。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即`每当进程提出资源请求且系统的资源能够满足该请求`时：

系统将判断满足此次资源请求后系统状态是否安全？

- 安全：给该进程分配资源
- 不安全：不分配资源，申请资源的进程将阻塞



银行家算法的执行有个`前提条件`，即要求进程预先提出自己的`最大资源请求`，并`假设系统拥有固定的资源总量`。



### 内存管理

#### 为什么要有虚拟内存？

**大纲**

![img](https://cdn.xiaolincoding.com//mysql/other/970ec527d1c1417eab0d3246e77405f9.png)

##### 虚拟内存

`虚拟内存地址：`程序所使用的内存地址叫做虚拟内存地址

`物理内存地址：`实际存在硬件里面的空间地址叫做物理内存地址



进程持有的虚拟内存地址会通过CPU‘芯片的内存管理单元（MMU）的映射关系，转变成物理内存地址，再通过物理内存地址访问

![img](https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png)



**操作系统主要通过两种方式来管理虚拟内存地址和物理内存地址的映射关系的，分别是内存分段和内存分页**

##### 内存分段

程序是由若干个逻辑段组成的，比如可以分层代码段、数据段、堆、栈。**不同的段有不同的属性，所以就用分段的形式把这些段分离出来**



分段机制下的虚拟地址由两部分组成，`段选择因子`和`段内偏移量`

![img](https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png)

`段选择因子`里面最重要的是段号，用作段表的索引。`段表`里面保存的是这个`段的基地址`、`段的界限`、`特权等级`等

虚拟地址中的`段内偏移量`加上`段基地址`就能得到物理内存地址



**分段机制会把虚拟地址分成4个段，每个段在段表中有一个项，这个项包括段基地址、段界限和特权等级等**

![img](https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png)



分段的方式解决了程序不需要关心具体的物理地址的问题，但是也有两个问题：

1. 内存碎片
2. 内存交换效率低



`出现内存碎片的原因：`内存碎片分为内部内存碎片和外部内存碎片，由于分段机制是进程申请多少就给多少，因此不会出现内部内存碎片，外部内存碎片出现的原因是每个段的长度不固定，所以未必能恰好使用所有的内存空间，会产生多个不连续的小物理内存，导致新的程序无法被装载（即使空闲内存空间总和足够），但由于不连续，所以无法分配。解决的方法是将某些程序先写到磁盘上，再重新加载回内存，但是重新加载回来后的内存地址变了，应该紧紧跟着前面已被使用的内存空间。

这个内存交换空间，在Linux里，就是Swap空间



`内存交换效率低的原因：`由于是通过内存交换的方式来解决外部内存碎片问题，因此要访问磁盘，而磁盘的访问速度比内存慢太多了。如果此时要换出的段大小比较大，那么所消耗的时间就会比较久



**为了解决内存分段的 外部内存碎片和内存交换效率低的问题，就出现了内存分页**



##### 内存分页

`分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小`，这样一个连续并且尺寸固定的内存空间，叫**页**，在Linux下，每一页是`4KB`大小



虚拟内存地址和物理内存地址通过页表来管理映射关系：

![img](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png)



`解决外部内存碎片问题：`内存分页由于内存空间都是预先划分好的，也就不会像分段机制一样，段与段之间有间隙非常小的内存空间。但是由于内存分页机制分配内存的最小单位是一页，即使程序大小不足一页，也会分配一页，所以会有内部内存碎片



`解决内存交换效率低问题：`如果内存空间不够，操作系统会把**最近未被使用**的内存页面释放掉，也就是暂时写在硬盘上。所以一次性写入磁盘的也只有一个页或几个页，不会花太多时间，内存交换效率就比较高



更进一步，分页机制使得我们在加载程序时，不需要一次性把程序都加载到物理内存中，**可以先建立虚拟内存地址和物理内存地址的映射关系后，等程序需要用到对应的虚拟内存地址的指令和数据后，再加载到物理内存里面**



**分页机制的映射管理**

![img](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)

1. 虚拟地址分为页号和页内偏移量
2. 通过页号在页表中找到对应的物理页号
3. 找到对应物理页加上页内偏移量就是对应的物理地址了



`简单分页的缺陷`

在32位的环境下，虚拟内存空间是4GB，一个页是4KB大小，所以大概有100万(2^20)个页，每个页表项需要4个字节大小来存储，所以整个4GB空间的映射就需要有4MB的内存来存储页表

假设有100个进程，那么就需要400MB大小来存储这些页表



**为了解决这个问题，需要采用多级页表**



**多级页表**



`在32位环境下，如果使用了二级页表，一级有1024个页表项，这些页表项指向对应二级页表，而由于进程一般很少会使用到全部的虚拟内存空间，因此一级页表中的有些页表项是空的，也就意味着根本不用创建对应的二级页表，假设有20%的虚拟内存空间被使用了，那么页表所占空间就是一级页表加创建的二级页表大小，即4KB+20%×4MB=0.804MB`





虽然多级页表解决了空间上的问题，但是虚拟地址转到物理地址就多了几道转换的工序，显然就降低了转换效率

程序是有局部性的，程序访问到的数据在短时间内很大概率会再次访问到，因此可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是就加入了一个专门存放程序最常访问的页表项的缓存，就是`TLB(Translation Lookaside Buffer)`，通常成为`页表缓存`、`转址旁路缓存`、`快表`

![img](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)



有了TLB后，CPU在寻址时，会先查TLB，如果没找到，才会继续查常规的页表



##### 段页式内存管理

内存分段和内存分页合在一起就是段页式



- 将程序划分为多个有逻辑意义的段
- 再把每个段分为多个页

这样，地址结构就由段号、段内页号和页内偏移三部分组成

![img](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)





##### 总结

`为什么要有虚拟地址？`

1. 虚拟内存可以使程序的运行内存超过物理内存，由于程序运行符合局部性原理，CPU访问内存会有很明显的重复性，对于没有经常被使用的内存，可以把它交换到物理内存之外，比如swap区域
2. 每个进程都有自己的页表，所以每个进程的页表是独有的，一个进程不可以访问到其它进程的页表，这样就把每个进程的地址空间隔离开来，解决了多进程地址冲突的问题
3. 页表项除了有物理地址外，还有一些标志性的比特位，比如可以控制一个页的读写权限，以及标志一个页是否存在或者是否为脏页，为操作系统提供了更好的安全性





#### 进程虚拟内存空间分布

![虚拟内存空间划分](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)



1. .text(代码段)：

   用于存放程序代码的区域， 编译时确定， 只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。

2. .data(数据段):

   用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常所说的静态存储区，赋了`初值(不为0)的全局变量、常量和静态变量`都存放在这个域。

3. .bss：

   bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

   data段（已手动初始化的数据）为数据分配空间，数据保存在目标文件中。

   data段包含经过初始化的全局变量以及它们的值。

   BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区。

4. 堆：

   向高地址伸长

5. 栈：

   向低地址伸长





### 网络系统

#### 零拷贝

**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8F%90%E7%BA%B2.png)



##### DMA（Direct Memory Access直接内存访问）

没有DMA技术前，I/O的过程如下：

1. CPU发出对应指令给磁盘控制器，然后返回
2. 磁盘接收到指令后，开始准备数据，然后把数据放到磁盘控制器的内部缓冲区，之后产生一个中断
3. CPU收到中断信号后，停下手头的工作，接着把磁盘控制器的内部缓冲区一个一个字节读到自己的寄存器中，然后再把寄存器中的数据写入到内存，CPU在数据传输阶段是无法执行其它任务的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/I_O%20%E4%B8%AD%E6%96%AD.png)





**DMA技术**：在进行I/O设备和内存的数据传输时，全部由DMA控制器完成，而CPU不再参与任何跟数据搬运相关的事情，这样就可以解放CPU去处理别的事务了

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png)



内核缓冲区是内核利用一部分物理内存分配出来的



##### 传统文件传输

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)

4次上下文切换（用户态和内核态之间的切换）

4次拷贝：

1. 从磁盘控制器的内部缓冲区拷贝到内核缓冲区，由DMA完成
2. 内核缓冲区拷贝到用户缓冲区，由CPU完成
3. 用户缓冲区拷贝到内核socket缓冲区，由CPU完成
4. 从内核socket缓冲区拷贝到网卡缓冲区，由DMA完成



`提高文件传输效率，从两个方面优化，一是减少用户态与内核态的切换，二是减少内存拷贝次数`

##### 优化文件传输的性能

1. 减少用户态与内核态的切换：减少系统调用的次数
2. 由于从内核缓冲区拷贝到用户缓冲区的数据并不会再加工，所以数据可以不用拷贝到用户空间，因此用户缓冲区没有存在的必要



##### 实现零拷贝

1. **mmap+write**

   mmap系统调用会把内核缓冲区的数据直接映射到用户空间，因此内核与用户空间就不需要进行任何拷贝操作了

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)

   流程如下：

   1. 应用进程调用mmap后，DMA会把磁盘中的数据拷贝到内核缓冲区中，用户进程和内核共享这块内核缓冲区
   2. 应用进程再调用write，数据从内核缓冲区拷贝到内核socket缓冲区，由CPU完成
   3. 最后，把数据从socket缓冲区拷贝到网卡缓冲区，由DMA完成

   仍需要4次上下文切换和3次拷贝

   

2. **sendfile**

   系统调用函数：

   ```c
   #include <sys/socket.h>
   ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
   ```

   out_fd: 目的端文件描述符

   in_fd: 源端文件描述符

   offset: 源端偏移量

   count: 要复制的数据长度

   ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)

   减少了一次系统调用，因此少了两次上下文切换

   但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。

   你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

   ```shell
   $ ethtool -k eth0 | grep scatter-gather
   scatter-gather: on
   ```

   

   对于支持SG-DMA技术的网卡，sendfile系统调用过程如下：

   1. 将数据从磁盘拷贝到内核缓冲区，由DMA完成
   2. 缓冲区描述符和数据长度传到socket缓冲区，SG-DMA控制器可以直接将数据从内核缓冲区拷贝到网卡缓冲区，不需要将数据从内核缓冲区拷贝到socket缓冲区

   `这就是零拷贝技术，因为不存在内存层面上的数据拷贝，意味着全程没有通过CPU来拷贝数据，所有的数据都是通过DMA来传输。只需要2次上下文切换和2次拷贝`



##### PageCache

前面的第一步拷贝都是拷贝到内核缓冲区，这个内核缓冲区实际上是磁盘高速缓存（PageCache）

零拷贝如果使用PageCache技术，那么性能可以进一步提升



**PageCache提高性能的方式：**

1. 由于`局部性原理`，刚被访问的数据再次被访问的概率很高，于是用PageCache来缓存最近被访问的数据，当空间不足时淘汰掉最久未被访问的缓存

   因此，在读取磁盘数据时，优先去PageCache找，如果没有再到磁盘中读取，然后缓存PageCache

2. 预读功能：比如，假设 read 方法每次只会读 `32 KB` 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。



**但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能**



##### 大文件传输方式

读取文件时，进程会进入阻塞状态，我们可以采用异步I/O的方式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E8%BF%87%E7%A8%8B.png)



读操作分为两部分：

- 前半部分：内核向磁盘发起读请求，但是可以不等待数据就位就返回，于是进程此时就可以处理后面的任务
- 后半部分：当内核将磁盘中的数据拷贝到进程缓冲区后，进程接收到内核的通知，再去处理数据



异步I/O要绕开PageCache

绕开PageCache的叫直接I/O，使用PageCache的是缓存I/O，对于磁盘，异步I/O只支持直接I/O



大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。



`在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术`。



**传输文件方式：**

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；





#### I/O多路复用：select/poll/epoll

`IO多路复用是通过一种机制实现同时监视多个IO流的方法`



**大纲**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8F%90%E7%BA%B2.png)



##### socket编程

服务端：

1. 调用socket(int domain, int type, int protocol)函数，创建网络协议为IPv4，以及传输协议为TCP的Socket
2. 调用bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数，给这个Socket绑定一个IP地址和端口
   - 绑定端口的目的：通过端口号找到应用程序
   - 绑定IP的目的：找到对应网卡，因为每个网卡都有对应的IP地址
3. 调用 listen(int sockfd, int backlog)函数监听,backlog限制accept队列（全连接队列）的大小
4. 调用accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)函数连接客户端，如果此时没有客户端连接，则会阻塞等待下一个客户端的连接



客户端：

创建好socket之后，调用connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)函数发起连接



然后TCP三次握手就开始了，

在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：

- 一个是「还没完全建立」连接的队列，称为 **TCP 半连接队列**，这个队列都是没有完成三次握手的连接，此时服务端处于 `syn_rcvd` 的状态；
- 一个是「已经建立」连接的队列，称为 **TCP 全连接队列**，这个队列都是完成了三次握手的连接，此时服务端处于 `established` 状态；

当 TCP 全连接队列不为空后，服务端的 `accept()` 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。

注意，监听的 Socket 和真正用来传数据的 Socket 是两个：

- 一个叫作**监听 Socket**；
- 一个叫作**已连接 Socket**；

连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 `read()` 和 `write()` 函数来读写数据。





**线程池**的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理



##### IO多路复用

使用多进程/多线程来管理每个socket的开销比较大，因此使用I/O多路复用技术



概念：一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。



select/poll/epoll: `进程可以通过一个系统调用函数从内核中获取多个事件`



1. `select`

   - 函数：

     ```c
     int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
     ```

   - 实现方式：将已连接时Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核中，内核遍历文件描述符集合，如果有网络事件产生，那么就将Socket标记为可读可写，接着再把整个文件描述符集合拷贝回用户，用户进程遍历文件描述符集合，如果找到可读可写的Socket，代表着有网络事件，再对其进行读写

   - 弊端：select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

2. `poll`

   - 函数：

     ```c
     struct pollfd {
     　　 int fd;           /*文件描述符*/
     　　 short events;     /*监控的事件*/
     　　 short revents;    /*监控事件中满足条件返回的事件*/
     };
     int poll(struct pollfd *fds, unsigned long nfds, int timeout);   
     ```

   - 实现方式：poll和select的唯一区别在于，poll是通过动态数组来管理文件描述符的，以链表的方式组织。突破了select的文件描述符个数限制，但仍受到系统文件描述符限制，并且poll依旧是把文件描述符数组拷贝到内核中，然后内核遍历数组判断是否有网络事件发生，如果有就标记为可读可写，接着再拷回用户态，用户进程遍历文件描述符数组判断是否可读可写，再做相应的处理

3. `epoll`

   - 函数：

     ```c
     // 该函数生成一个 epoll 专用的文件描述符。
     int epoll_create(int size);
     
     // epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
     int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
     
     // 等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。返回需要处理的事件数目
     int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
     ```

   - 用法：

     ```c
     int s = socket(AF_INET, SOCK_STREAM, 0);
     bind(s, ...);
     listen(s, ...)
     
     int epfd = epoll_create(...);
     epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
     
     while(1) {
         int n = epoll_wait(...);
         for(接收到数据的socket){
             //处理
         }
     }
     ```

   - 从两个方面解决`select`和`poll`的问题:

     1. 传入参数：epoll在内核中使用红黑树来跟踪所有进程的待检测的文件描述符，由于内核有文件描述符集合的信息，因此用户进程只需要传入一个待检测的socket即可
     2. 检测有事件发生的socket：epoll使用事件驱动，内核里维护了一个链表来记录就绪事件，当某个socket有时间发生时，就回通过回调函数加入到该就绪时间链表当中，当用户调用epoll_wait()函数时，返回有事件发生的文件描述符个数，不需要像select和poll去遍历整个文件描述符集合

     内核会将就绪事件链表拷贝到用户空间中，即第二个参数events，这样就知道有哪些socket是有事件的

   - `边缘触发（edge-triggered，ET）`:

     使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；

     **如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作，直到系统调用（如 `read` 和 `write`）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。**

     **一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。**

   - `水平触发（level-triggered，LT）`:

     使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

     **如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。**

   - 一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

   - select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。



##### epoll_wait等待的时候会释放CPU吗？

`在IO多路复用中使用epoll_wait等待IO事件的时候，进程会释放CPU。`

在Linux中，进程状态将会变成"S"（可中断睡眠状态）或"D"（不可中断睡眠状态，通常等待IO）。两个状态下，进程都不会占用CPU资源，因为它们都是不同形式的睡眠状态，CPU会切换到其他进程或线程继续工作。 **"S"状态是可中断的睡眠状态，表示进程正在等待某个条件的满足或某个事件的发生。这种状态下的等待是可以被信号打断的**，*例如，系统调用如read()在没有数据可读时会使进程进入"S"状态，但接收到信号后，进程可以从系统调用中返回，处理信号*。 **"D"状态则是不可中断的睡眠状态，进程在这种状态下一般是正在等待某个硬件级别的IO操作完成**，*例如，等待磁盘IO或网络IO。这种状态的进程不能被信号打断，因为它们通常涉及到一些必须完成的硬件操作*。 `当你调用epoll_wait时，如果当前没有IO事件，进程会进入"S"状态。如果系统调用涉及到硬件级别的不可中断IO操作，进程可以进入"D"状态。这样设计是为了在IO操作期间不消耗CPU资源，同时允许其他进程或线程使用CPU。 所以，使用epoll_wait时，进程会进入睡眠状态直到事件发生，从而释放CPU。`





### 进程管理

#### 进程和线程

**大纲**



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/3-%E6%8F%90%E7%BA%B2.jpg)

##### 进程

进程：运行中的程序就被称为进程，是**资源分配的基本单位**



> 并发和并行的区别

![并发与并行](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

并行：同一时间CPU可以执行多个任务

并发：假设1秒内，CPU可以快速切换不同进程执行，宏观看来，CPU就像在同一时间执行多个任务一样



##### 进程的状态

CPU从一个进程切换到另一个进程前，需要保留当前进程的状态，以便后续恢复

![七种状态变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

- 创建状态：进程正在被创建时的状态
- 就绪状态：可运行，由于其它进程处于运行状态而停止运行
- 运行状态：该时刻占用CPU
- 阻塞状态：该进程正在等待某一时间发生(如等待I/O)而暂时停止运行，这时，即使给它CPU控制权，它也无法运行
- 结束状态：进程正在从系统中消息的状态
- 挂起状态：进程并不占用实际物理内存空间的情况
  - 就绪挂起状态：进程在外存（磁盘），只要进入内存立马能执行
  - 阻塞挂起状态：进程在外存（磁盘）并等待某个事件的完成



导致进程挂起的原因不只是进程所使用的内存空间不在物理内存，还包括如下情况：

- 通过sleep让进程间歇性挂起，其原理是设置一个计时器，到期后叫醒进程
- 用户希望挂起一个程序的执行，比如在Linux中使用的ctrl+z挂起进程



##### 进程的控制结构

在操作系统中，使用进程控制块（PCB），来描述进程的



`PCB`是进程存在的唯一标识，意味着一个进程的存在，必然会有一个PCB，如果进程消失了，那么对应的PCB也会消失



> `PCB`具体包含的信息

- **进程描述信息：**

  - **进程标识符：**标识各个进程，每个进程都有一个并且唯一的标识符
  - **用户标识符：**进程所属的用户，用户标识符主要为共享和保护服务

- **进程控制和管理信息：**

  - **进程当前的状态：**如new、ready、running、waiting或blocking等
  - **进程优先级：**进程抢占CPU的优先级

- **资源分配清单：**

  有关内存地址空间或虚拟地址空间的信息，所打开的文件列表和使用的I/O设备的信息

- **CPU相关信息：**

  CPU中各个寄存器的值，当进程被切换时，CPU各寄存器的值都保存到相应的PCB中，以便进程重新执行时能从断点处继续执行



> 每个`PCB`是如何组织的

通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列：

- 把所有处于就绪状态的进程链在一起，就是就绪队列
- 把所有因等待事件完成而处于阻塞状态的进程链在一起，就是阻塞队列

![就绪队列和阻塞队列](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg)

除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除



##### 进程的上下文切换

`进程的上下文切换`: 一个进程切换到另一个进程运行

`CPU上下文`：CPU寄存器和程序计数器



**进程是由内核管理和调度的，因此进程的上下文切换只能发生在内核态**



进程的上下文切换不仅包含了虚拟内存空间、栈和全局变量等用户空间资源，还包含了内核堆栈、寄存器等内核空间资源



> 发生进程上下文切换的常见场景

- 时间片耗尽
- 系统资源不足
- 进程调用sleep主动挂起
- 被高优先级的进程抢占CPU
- 硬件中断



##### 线程

`线程是CPU调度运行的基本单位`



同一进程内的多个线程可以共享代码段、数据段、打开的文件列表等，但每个线程又都有独立的寄存器和栈



线程的优点：

- 一个进程中可以同时存在多个线程
- 各个线程之间可以并发执行
- 同一进程的各个线程之间共享地址空间和文件等资源

线程的缺点：

- 当一个线程崩溃时，会导致同一进程下的所有线程都崩溃了



##### 线程的上下文切换

- 同一进程的线程上下文切换：由于虚拟内存是共享的，只需切换线程的栈、寄存器等不共享的数据即可
- 不同进程的线程上下文切换：和进程上下文切换一样，需要切换虚拟内存空间、全局变量和栈表等用户空间资源，还需要切换内核堆栈、寄存器等内核空间资源



##### 线程的实现

- **用户线程：**在用户空间实现的线程，不由内核管理，是由用户态的线程库来完成管理
- **内核线程：**在内核中实现的线程，由内核管理
- **轻量级线程：**在内核中来支持用户线程



**用户线程和内核线程的对应关系**

1. 多对一

   ![多对一](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

2. 一对一

   ![一对一](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/18-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)

3. 多对多

   ![多对多](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/19-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)





> ​	用户线程的优势和缺陷

**多对一**

![用户级线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)



用户线程的整个管理和调度都是由线程库函数来完成的，操作系统不直接参与



用户线程的优点：

- TCB由线程库函数来维护，可以用于不支持线程的操作系统
- 用户线程的切换不进入用户态，速度更快

用户线程的缺点：

- 由于操作系统不参与线程的调度，一个线程发起系统调用而导致阻塞，同一进程下的所有用户线程都不能执行了
- 当一个线程开始运行后，除非它主动交出CPU使用权，否则它所在进程的其它线程是无法运行的，因为用户态线程没有办法打断当前运行中的线程，它没有这个特权，只有操作系统有，但是用户线程并非操作系统管理的
- 由于时间片是分给进程的，与其它进程相比，多线程情况下，每个线程分配到的时间片较少，执行慢





> 内核线程的优势和缺陷

**一对一**

![内核线程模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)



内核线程是由操作系统管理的，所以对应TCB是保留在内核中的，因此线程的创建、终止和管理都是由操作系统完成的



内核线程的优点：

- 在一个进程当中，当一个线程发起系统调用而阻塞并不会影响其它线程的运行
- 多线程的进程会被分配到更多时间片

内核线程的缺点：

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息
- 线程的创建、终止和切换都是通过系统调用的方式来进行，每次都要进入内核态，开销更大



> 轻量级线程的优点和缺陷

**轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度**。



在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：

- `1 : 1`，即一个 LWP 对应 一个用户线程；
- `N : 1`，即一个 LWP 对应多个用户线程；
- `M : N`，即多个 LWP 对应多个用户线程；

![LWP 模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/22-LWP.jpg)



**1 : 1 模式**

一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。

- 优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；
- 缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。

**N : 1 模式**

多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。

- 优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；
- 缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。

**M : N 模式**

根据前面的两个模型混搭一起，就形成 `M:N` 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。

- 优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。

**组合模式**

如上图的进程 5，此进程结合 `1:1` 模型和 `M:N` 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。



##### 调度

另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：

- **非抢占式调度算法**挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。



`五大调度原则`

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。



**调度算法**

- 先来先服务
- 最短作业优先
- 高响应比优先
- 时间片轮转调度
- 最高优先级调度
- 多级反馈队列



#### 进程和线程的比较

1. 进程是资源分配（包括内存、打开的文件等）的基本单位，线程是CPU调度的基本单位

2. 进程拥有一个完整的资源平台，而线程只独享必不可缺的资源，比如寄存器和栈

3. 线程同样具有就绪、运行、阻塞三种基本状态，也同样具有状态之间的转换

4. 线程能减少并发执行的时间和空间开销

   具体体现在如下几点：

   - 线程的创建时间更快，因为进程创建时，还需要资源管理信息，比如内存管理信息和文件管理信息，而线程的创建过程中，不会涉及这些资源管理信息，而是共享它们
   - 线程的终止时间更快，因为线程需要释放的资源更少
   - 线程切换的效率更高，因为线程的切换只需要切换寄存器和栈，对于虚拟内存空间，由于同一进程下的线程是共享的，因此不需要切换。而进程切换时需要切换页表，页表的切换十分耗时。进程和线程的切换都要进入内核态
   - 线程间的数据传递效率更高，因为线程是共享内存和文件资源的，因此不需要经过内核就可以完成数据的传递



#### 进程退出时，假设存在没有释放的资源，应该怎么做？

- 显示释放资源：显示释放内存、文件描述符、网络连接等，比如调用free和close
- 注册退出处理函数：使用atexit函数注册一个退出处理函数，在进程退出时自动调用。
- 利用操作系统的资源回收机制
- 使用工具检查内存泄漏



#### 进程间通信

**大纲**

![image-20240331153334705](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331153334705.png)



每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程间通信必须通过内核。

![image-20240331154014909](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331154014909.png)



##### 管道

- **匿名管道**

  创建：`int pipe(int fd[2])`

  fd[0]是管道读取端描述符，fd[1]是管道的写入端描述符

  匿名管道是特殊的文件，只存在于内存，不存在于文件系统中

  ![image-20240331154310390](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331154310390.png)

  `所谓的管道，实际上就是内核中的一串缓存`

  应用场景：具有关系的进程

  ![image-20240331154722281](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331154722281.png)

  由于管道只能一端读入，一端写出，这就是半双工，如果父子进程他同时写的话，就会发生混乱，因此如果想要实现父子进程互相通信，就要有两个管道

  ![image-20240331154919256](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331154919256.png)

- **命名管道**

  创建：`int mkfifo(const char *pathname, mode_t mode);`

  命名管道属于设备文件系统中的呀一个文件

  应用场景：在不相关的进程间也能相互通信



不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时自然也是从内核中获取，同时通信数据都遵循`先进先出原则`，不支持lseek之类的文件定位操作



读写管道的方式是调用传统文件读写的read/write，开销主要在两方面，一个是用户态切换到内核态，另一个是从内核缓冲区和用户缓冲区之间的拷贝，read/write都会传入一个用户缓冲区，read时将数据从内存缓冲区拷贝到用户缓冲区，write时从用户缓冲区拷贝到内核缓冲区



##### 消息队列

创建与数据传输：

```c
int msgget(key_t key, int msgflg);
msgid = msgget(0x1234, 0666|IPC_CREAT);
int msgsnd(int msqid, void *msgp, int msgsz, int msgflg);
int msgrcv(int msgid, void *msgp, int msgsz, long msgtyp, int msgflg);
int msgctl(int msqid, IPC_RMID, NULL);
```



`消息队列是保存在内核中的消息链表，分成独立的消息体`，哪个进程要发送数据，直接把数据放在对应消息队列后就可以正常返回，另一个进程需要时再去读取数据即可



**不足之处**

- `消息队列不适合大数据的传输`：因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。
- `消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销`



##### 共享内存

消息队列的读取和写入的过程，都会发生用户态与内核态之间的消息拷贝过程



`共享内存机制：`

拿出一块虚拟地址空间来，映射到相同的物理内存中去

![image-20240331161450779](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331161450779.png)



##### 信号量

信号量：为了防止多进程竞争共享内存资源，而造成的数据错乱，所以需要保护机制，使得共享内存资源在任意时刻只能被一个进程访问。



**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。



- P操作：信号量减1
- V操作：信号量加1



![image-20240331161731979](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240331161731979.png)





##### 信号

上面的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要使用`信号`的方式来通知进程**



信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，有以下几种用户进程对信号的处理方式：

- 执行默认操作
- 捕捉信号
- 忽略信号：`SIGKILL`和`SEGSTOP`信号是无法捕捉和忽略的



##### 总结

各IPC的缺点：

1. `匿名管道`：
   - 只能在具有父子关系间的进程间通信
   - 半双工通信，只能一端写一端读
   - 用户态与内核态切换的开销
   - 内核和用户缓冲区的拷贝
2. `命名管道`：
   - 可以在匿名进程间通信
   - 数据的传输是先进先出的
   - 用户态与内核态切换的开销
   - 内核和用户缓冲区的拷贝
3. `消息队列`
   - 消息体大小有限制
   - 消息链表大小有限制
   - 不适合大量数据的传输
   - 用户态与内核态切换的开销
   - 内核和用户缓冲区的拷贝
4. `共享内存`：解决了上面的问题，可以传输大量数据，不用频繁切换用户态与内核态，不需要用户缓冲区与内核缓冲区之间的拷贝
   - 多进程并发竞争共享内存问题，因此引入`信号量`使得任意时刻只能有一个进程操作共享内存









## 离散数学

### 拓扑序列

拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点 u  到顶点 v 的每个有向边  uv， u 在序列中都在 v 之前。



拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。



不是所有的有向图都是有拓扑序的，只有**有向无环图**才有拓扑序，所以**有向无环图又被称为拓扑图**。



## 计算机概论

### 原码、反码和补码

|      | 原码（符号位：正0负1） | 反码（原码除符号位取反） | 补码（反码+1） |
| ---- | ---------------------- | ------------------------ | -------------- |
| 10   | 0000 1010              | 0111 0101                | 0111 0110      |
| -10  | 1000 1010              | 1111 0101                | 1111 0110      |



