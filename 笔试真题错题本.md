## 算法

### [旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 1.转置
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = i + 1; j < matrix[i].size(); ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // 2.反转数组
        for (int i = 0; i < n; ++i) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```



### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>res;
        int n=matrix.size();
        int m=matrix[0].size();

        pair<int,int>left_up(0,0);
        pair<int,int>right_down(n-1,m-1);

        while(left_up.first<=right_down.first&&left_up.second<=right_down.second){
            int up=left_up.first;
            int left=left_up.second;
            int down=right_down.first;
            int right=right_down.second;

            // 只剩一行
            if (up==down){
                for(int j=left;j<=right;j++){
                    res.emplace_back(matrix[up][j]);
                }
                break;
            }

            // 只剩一列
            if (left==right){
                for(int i=up;i<=down;i++){
                    res.emplace_back(matrix[i][left]);
                }
                break;
            }

            for(int j=left;j<right;j++){
                res.emplace_back(matrix[up][j]);
            }
            for(int i=up;i<down;i++){
                res.emplace_back(matrix[i][right]);
            }
            for(int j=right;j>left;j--){
                res.emplace_back(matrix[down][j]);
            }
            for(int i=down;i>up;i--){
                res.emplace_back(matrix[i][left]);
            }

            left_up.first+=1;
            left_up.second+=1;
            right_down.first-=1;
            right_down.second-=1;
        }

        return res;
    }
};
```



### [打乱数组](https://leetcode.cn/problems/shuffle-an-array/)

![image-20240321112356263](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321112356263.png)

```cpp
class Solution {
public:
    Solution(vector<int>& nums) { this->nums = nums; }

    vector<int> reset() { return this->nums; }

    vector<int> shuffle() {
        vector<int> res = nums;
        int n = nums.size();

        for (int i = 0; i < n; ++i) {
            swap(res[i], res[i + rand() % (n - i)]);
        }
        
        return res;
    }

private:
    vector<int> nums;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```



### [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

思路：

- 双向链表：最近访问的元素放在链表头，最长时间没访问的元素在链表尾，由于查找、放置和删除节点时只会对头尾节点做操作，因此可以加一对虚拟头尾节点管理
- 整体维护一张哈希表，键值是key，value值是双向链表中的节点
- get(): 查找哈希表中有无对应键值，有则返回对应元素，并把该元素移到头节点，没有则返回-1
- put(): 查找有无对应键值，有则更新value值即可，并移到头节点。没有就需要添加，先判断LRU缓存是否已满，如果没满则添加到链表头，满了的话删掉尾节点然后再加到链表头

```cpp
struct DoubleLinkedNode {
    int key, value;
    DoubleLinkedNode* prev;
    DoubleLinkedNode* next;

    DoubleLinkedNode() : key(-1), value(-1), prev(nullptr), next(nullptr) {}
    DoubleLinkedNode(int key, int val)
        : key(key), value(val), prev(nullptr), next(nullptr) {}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        dummy_head = new DoubleLinkedNode();
        dummy_tail = new DoubleLinkedNode();
        dummy_head->next = dummy_tail;
        dummy_tail->prev = dummy_head;
        size = 0;
        this->capacity = capacity;
    }

    int get(int key) {
        // 如果不存在，返回-1
        if (link_map.count(key) == 0)
            return -1;

        DoubleLinkedNode* key_node = link_map[key];
        // 更新访问时间
        moveToHead(key_node);
        return key_node->value;
    }

    void put(int key, int value) {
        // 如果存在，更新值，并更新时间
        if (link_map.count(key) != 0) {
            DoubleLinkedNode* key_node = link_map[key];
            key_node->value = value;
            moveToHead(key_node);
            // 及时返回，否则出了if还会继续执行，不符合逻辑
            return;
        }

        // 如果不存在
        // 先判断是否还有空间
        if (size == capacity) {
            // 空间已满
            // 删除链表尾(最久未被访问的元素)
            DoubleLinkedNode* tail_node = dummy_tail->prev;
            removeNode(tail_node);
            // 从link_map中删去key值
            link_map.erase(tail_node->key);
            // 更新元素个数
            --size;
        }

        // 空间充足
        // 初始化节点
        DoubleLinkedNode* new_node = new DoubleLinkedNode(key, value);
        // 加入到链表头
        addToHead(new_node);
        // 加入到link_map
        link_map[key] = new_node;
        // 更新元素个数
        ++size;
    }

    // 将节点加入链表头，用于put新添节点时
    void addToHead(DoubleLinkedNode* node) {
        DoubleLinkedNode* head_next = dummy_head->next;
        dummy_head->next = node;
        node->prev = dummy_head;
        head_next->prev = node;
        node->next = head_next;
    }

    // 移除节点，不止链表尾，因为还有将中间节点移出链表再添加到链表头的情况
    void removeNode(DoubleLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        node->prev = nullptr;
        node->next = nullptr;
    }

    // 将链表中的节点移动到链表头，满足更新key值对应value，和访问key时的情况
    void moveToHead(DoubleLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

private:
    unordered_map<int, DoubleLinkedNode*> link_map;
    DoubleLinkedNode* dummy_head;
    DoubleLinkedNode* dummy_tail;
    int size;
    int capacity;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### [三数之和](https://leetcode.cn/problems/3sum/)

思路：

排序数组后，定义双指针，由于数组是有序的，因此双指针的移动也是有规律的，假设当前和小于0，那么就让左指针往右移(nums[left]<=nums[left+1])，否则就让右指针左移(nums[right]>=nums[right-1])

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for (int i = 0; i < n - 2; ++i) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 去重
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return res;
    }
};
```



### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

思路：

由于连在一起的陆地算一块岛屿，因此遍历二维数组时，碰到一块陆地就将其所在岛屿的所有陆地沉下去（dfs），防止重复计算

```cpp
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 越界或者陆地不连续就停止
        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() ||
            grid[i][j] == '0')
            return;

        // 沉下去
        grid[i][j] = '0';
        dfs(grid, i - 1, j);
        dfs(grid, i + 1, j);
        dfs(grid, i, j - 1);
        dfs(grid, i, j + 1);
    }

    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int n = grid.size(), m = grid[0].size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }

        return res;
    }
};
```



### [数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

思路：

维护小顶堆A和大顶堆B，各维护一半元素，小顶堆A维护值较大的那一半（），大顶堆B维护值较小的那一半

![image-20240321213513781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20240321213513781.png)

```cpp
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        int m=A.size();
        int n=B.size();

        // num需要和A、B中的元素都比较之后才知道应该放在哪
        // A、B元素个数相同，加入A
        if(m==n){
            // num有可能属于较小的那一半，因此先加入B，再将B的堆顶元素加入A
            B.push(num);
            A.push(B.top());
            B.pop();
        }else{// m=n+1
            // num有可能属于较大的那一半，因此先加入A，再将A的堆顶元素加入B
            A.push(num);
            B.push(A.top());
            A.pop();
        }
    }

    double findMedian() {
        int m=A.size();
        int n=B.size();

        if(m==n){
            return (A.top()+B.top())/2.0;
        }

        return A.top();
    }

private:
    // A维护较大的一半元素，且元素个数大于等于B
    priority_queue<int, vector<int>, greater<int>> A;
    // B维护较小的一半元素，且元素个数小于等于A
    priority_queue<int, vector<int>, less<int>> B;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



## C++

下面这段代码会在编译时，因为调用show函数时，会调用A的拷贝构造函数，而A的拷贝构造函数是私有的无法访问到，因此报错

```cpp
#include <iostream>
using namespace std;
class A
{
    A(const A &) {}

public:
    int num;
    A() { num = 5; }
};
void show(A a)
{
    cout << a.num << endl;
}

int main()
{
    A a;
    show(a);
    return 0;
}
```



## 数据库

**COUNT函数**

> - COUNT有几种用法？`COUNT(expr)、COUNT(常量)、COUNT(*)`
> - COUNT(字段名)和COUNT(\*)的查询结果有什么不同？`前者不统计NULL值，后者统计`
> - COUNT(1)和COUNT(\*)之间有什么不同？`COUNT(*)是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化`
> - COUNT(1)和COUNT(\*)之间的效率哪个更高？`起始是一样的，但由于COUNT(*)是标准语法，因此更推荐使用COUNT(*)`
> - 为什么《阿里巴巴Java开发手册》建议使用COUNT(\*)`理由同上`
> - MySQL的MyISAM引擎对COUNT(\*)做了哪些优化？`每张表都单独记录了行数`
> - MySQL的InnoDB引擎对COUNT(\*)做了哪些优化？`通过低成本的索引进行扫表，只关注表的记录数而不关注字段内容`
> - 上面提到的MySQL对COUNT(\*)做的优化，有一个关键的前提是什么？`优化的前提是查询语句中不包含where条件和group by条件`
> - SELECT COUNT(\*) 的时候，加不加where条件有差别吗？`加where条件COUNT(*)就没有优化了`
> - COUNT(\*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？`见下面第二条`

1. COUNT(expr): 返回SELECT语句检索的行中expr值不为NULL的数量，结果是一个BIGINT值

   如果查询结果没有命中任何记录，则返回0

   COUNT(*)的统计结果中，会包含NULL的行数

2. `COUNT(常量)` 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数。

   而`COUNT(列名)`表示的是查询符合条件的列的值不为NULL的行数。

   `COUNT(*)`是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化

3. COUNT(*)的优化：

   - MyISAM

     MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。

   - InnoDB

     InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。

     但是，InnoDB还是针对COUNT(*)语句做了些优化的。

     通过低成本的索引进行扫表，而不关注表的具体内容。

     InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

     **MySQL会优先选择最小的非聚簇索引来扫表。**

     优化的前提是查询语句中不包含where条件和group by条件。

4. COUNT(字段)

   进行全表扫描，判断指定字段的值是否为`NULL`，不为`NULL`则累加。

   性能比`count(1)`和`count(*)`慢。



**聚簇索引和非聚簇索引**

- 聚簇索引（Clustered Index），也叫主键索引，并不是一种单独的索引类型，而是一种`数据存储方式`。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。`无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引`。InnoDB的聚簇索引实际上是`将索引和数据保存中同一个B+Tree中`。InnoDB通过`主键`聚集数据，`如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替`。如果没有这样的索引，InnoDB会隐式定义一个主键（自增id）来作为聚簇索引。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080712264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

  

- 非聚簇索引（NoClustered  Index），又叫`二级索引`。`二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值`。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，`获得行的主键值，然后使用主键去聚簇索引中查找数据行`，这需要`两次`B+Tree查找。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080810940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)



**UNIQUE**

UNIQUE创建的是`唯一索引`



## 操作系统

**银行家算法**

Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，`把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可`。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。



安全状态概念：

![](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125164249992-1856910147.png)

1. 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2. 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即`系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态`。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即`每当进程提出资源请求且系统的资源能够满足该请求`时：

系统将判断满足此次资源请求后系统状态是否安全？

- 安全：给该进程分配资源
- 不安全：不分配资源，申请资源的进程将阻塞



银行家算法的执行有个`前提条件`，即要求进程预先提出自己的`最大资源请求`，并`假设系统拥有固定的资源总量`。





## 离散数学

**拓扑序列**

拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点 u  到顶点 v 的每个有向边  uv， u 在序列中都在 v 之前。



拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。



不是所有的有向图都是有拓扑序的，只有**有向无环图**才有拓扑序，所以**有向无环图又被称为拓扑图**。

