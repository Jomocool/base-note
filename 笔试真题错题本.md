## C++

下面这段代码会在编译时，因为调用show函数时，会调用A的拷贝构造函数，而A的拷贝构造函数是私有的无法访问到，因此报错

```cpp
#include <iostream>
using namespace std;
class A
{
    A(const A &) {}

public:
    int num;
    A() { num = 5; }
};
void show(A a)
{
    cout << a.num << endl;
}

int main()
{
    A a;
    show(a);
    return 0;
}
```



## 数据库

**COUNT函数**

> - COUNT有几种用法？`COUNT(expr)、COUNT(常量)、COUNT(*)`
> - COUNT(字段名)和COUNT(\*)的查询结果有什么不同？`前者不统计NULL值，后者统计`
> - COUNT(1)和COUNT(\*)之间有什么不同？`COUNT(*)是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化`
> - COUNT(1)和COUNT(\*)之间的效率哪个更高？`起始是一样的，但由于COUNT(*)是标准语法，因此更推荐使用COUNT(*)`
> - 为什么《阿里巴巴Java开发手册》建议使用COUNT(\*)`理由同上`
> - MySQL的MyISAM引擎对COUNT(\*)做了哪些优化？`每张表都单独记录了行数`
> - MySQL的InnoDB引擎对COUNT(\*)做了哪些优化？`通过低成本的索引进行扫表，只关注表的记录数而不关注字段内容`
> - 上面提到的MySQL对COUNT(\*)做的优化，有一个关键的前提是什么？`优化的前提是查询语句中不包含where条件和group by条件`
> - SELECT COUNT(\*) 的时候，加不加where条件有差别吗？`加where条件COUNT(*)就没有优化了`
> - COUNT(\*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？`见下面第二条`

1. COUNT(expr): 返回SELECT语句检索的行中expr值不为NULL的数量，结果是一个BIGINT值

   如果查询结果没有命中任何记录，则返回0

   COUNT(*)的统计结果中，会包含NULL的行数

2. `COUNT(常量)` 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数。

   而`COUNT(列名)`表示的是查询符合条件的列的值不为NULL的行数。

   `COUNT(*)`是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化

3. COUNT(*)的优化：

   - MyISAM

     MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。

   - InnoDB

     InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。

     但是，InnoDB还是针对COUNT(*)语句做了些优化的。

     通过低成本的索引进行扫表，而不关注表的具体内容。

     InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

     **MySQL会优先选择最小的非聚簇索引来扫表。**

     优化的前提是查询语句中不包含where条件和group by条件。

4. COUNT(字段)

   进行全表扫描，判断指定字段的值是否为`NULL`，不为`NULL`则累加。

   性能比`count(1)`和`count(*)`慢。



**聚簇索引和非聚簇索引**

- 聚簇索引（Clustered Index），也叫主键索引，并不是一种单独的索引类型，而是一种`数据存储方式`。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。`无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引`。InnoDB的聚簇索引实际上是`将索引和数据保存中同一个B+Tree中`。InnoDB通过`主键`聚集数据，`如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替`。如果没有这样的索引，InnoDB会隐式定义一个主键（自增id）来作为聚簇索引。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080712264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)

  

- 非聚簇索引（NoClustered  Index），又叫`二级索引`。`二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值`。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，`获得行的主键值，然后使用主键去聚簇索引中查找数据行`，这需要`两次`B+Tree查找。

  ![image-20240320225918848](https://img-blog.csdnimg.cn/20201023080810940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70)



**UNIQUE**

UNIQUE创建的是`唯一索引`



## 操作系统

**银行家算法**

Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，`把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可`。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。



安全状态概念：

![](https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191125164249992-1856910147.png)

1. 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
2. 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即`系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态`。

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。**即`每当进程提出资源请求且系统的资源能够满足该请求`时：

系统将判断满足此次资源请求后系统状态是否安全？

- 安全：给该进程分配资源
- 不安全：不分配资源，申请资源的进程将阻塞



银行家算法的执行有个`前提条件`，即要求进程预先提出自己的`最大资源请求`，并`假设系统拥有固定的资源总量`。





## 离散数学

**拓扑序列**

拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点 u  到顶点 v 的每个有向边  uv， u 在序列中都在 v 之前。



拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。



不是所有的有向图都是有拓扑序的，只有**有向无环图**才有拓扑序，所以**有向无环图又被称为拓扑图**。

